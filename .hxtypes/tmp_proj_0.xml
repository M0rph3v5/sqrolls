<haxe>
	<class path="Array" params="T" file="/usr/lib/haxe/std/Array.hx" extern="1">
		<filter public="1" set="method"><f a="f">
	<f a="">
		<c path="Array.T"/>
		<x path="Bool"/>
	</f>
	<c path="Array"><c path="Array.T"/></c>
</f></filter>
		<map public="1" params="S" set="method"><f a="f">
	<f a="">
		<c path="Array.T"/>
		<c path="map.S"/>
	</f>
	<c path="Array"><c path="map.S"/></c>
</f></map>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of [this] Array.
		
		The elements are not copied and retain their identity, so
		a[i] == a.copy()[i] is true for any valid i. However, a == a.copy() is
		always false.</haxe_doc>
		</copy>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of [x] in [this] Array.
		
		This operation modifies [this] Array in place.
		
		If [x] is found by checking standard equality, it is removed from [this]
		Array and all following elements are reindexed acoordingly. The function
		then returns true.
		
		If [x] is not found, [this] Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<insert public="1" set="method">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element [x] at the position [pos].
		
		This operation modifies [this] Array in place.
		
		The offset is calculated like so:
			
		- If [pos] exceeds [this].length, the offset is [this].length.
		- If [pos] is negative, the offset is calculated from the end of [this]
		Array, i.e. [this].length + [pos]. If this yields a negative value,
		the offset is 0.
		- Otherwise, the offset is [pos].
		
		If the resulting offset does not exceed [this].length, all elements from
		and including that offset to the end of [this] Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element [x] at the start of [this] Array.
		
		This operation modifies [this] Array in place.
		
		[this].length and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of [this] Array.
		
		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use Std.string() to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes [len] elements from [this] Array, starting at and including
		[pos], an returns them.
		
		This operation modifies [this] Array in place.
		
		If [len] is < 0 or [pos] exceeds [this].length, the result is the empty
		Array [].
		
		If [pos] is negative, its value is calculated from the end	of [this]
		Array by [this].length + [pos]. If this yields a negative value, 0 is
		used instead.
		
		If the sum of the resulting values for [len] and [pos] exceed
		[this].length, this operation will affect the elements from [pos] to the
		end of [this] Array.
		
		The length of the returned Array is equal to the new length of [this]
		Array subtracted from the original length of [this] Array. In other
		words, each element of the original [this] Array either remains in
		[this] Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts [this] Array according to the comparison function [f], where
		[f(x,y)] returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.
		
		This operation modifies [this] Array in place.
		
		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, haxe.ds.sort.MergeSort.sort() can be used instead.
		
		If [f] is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of [this] Array, starting at and
		including [pos], up to but not including [end].
		
		This operation does not modify [this] Array.
		
		The elements are not copied and retain their identity.
		
		If [end] is omitted or exceeds [this].length, it defaults to the end of
		[this] Array.
		
		If [pos] or [end] are negative, their offsets are calculated from the
		end	of [this] Array by [this].length + [pos] and [this].length + [end]
		respectively. If this yields a negative value, 0 is used instead.
		
		If [pos] exceeds [this].length or if [end} exceeds or equals [pos],
		the result is [].</haxe_doc>
		</slice>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element of [this] Array and returns it.
		
		This operation modifies [this] Array in place.
		
		If [this] has at least one element, [this].length and the index of each
		remaining element is decreased by 1.
		
		If [this] is the empty Array [], null is returned and the length remains
		0.</haxe_doc>
		</shift>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of [this] Array.
		
		This operation modifies [this] Array in place.
		
		If [this].length < 2, [this] remains unchanged.]]></haxe_doc>
		</reverse>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element [x] at the end of [this] Array and returns the offset
		it was added at.
		
		This operation modifies [this] Array in place.
		
		[this].length will increase by 1.</haxe_doc>
		</push>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of [this] Array and returns it.
		
		This operation modifies [this] Array in place.
		
		If [this] has at least one element, [this].length will decrease by 1.
		
		If [this] is the empty Array [], null is returned and the length remains
		0.</haxe_doc>
		</pop>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of [this] Array, with [sep] separating
		each element.
		
		The result of this operation is equal to Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1]).
		
		If [this] is the empty Array [], the result is the empty String "". If
		[this] has exactly one element, the result is equal to a call to
		Std.string(this[0]).
		
		If [a] is null, the result is unspecified.</haxe_doc>
		</join>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of [a] to the elements of
		[this] Array.
		
		This operation does not modify [this] Array.
		
		If [a] is the empty Array [], a copy of [this] Array is returned.
		
		The length of the returned Array is equal to the sum of [this].length
		and [a].length.
		
		If [a] is null, the result is unspecified.</haxe_doc>
		</concat>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of [this] Array.</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.</haxe_doc>
	</class>
	<abstract path="Class" params="T" file="/usr/lib/haxe/std/Class.hx">
		<haxe_doc>An abstract type that represents a Class.
	
	See [Type] for the haXe Reflection API.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="EntityCreator" params="" file="src/EntityCreator.hx">
		<createGrid public="1" set="method" line="24"><f a=""><x path="Void"/></f></createGrid>
		<createImage public="1" set="method" line="14"><f a=""><x path="Void"/></f></createImage>
		<graphics><t path="Graphics"/></graphics>
		<engine><t path="Engine"/></engine>
		<new public="1" set="method" line="9"><f a="engine:graphics">
	<t path="Engine"/>
	<t path="Graphics"/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="Enum" params="T" file="/usr/lib/haxe/std/Enum.hx">
		<haxe_doc>An abstract type that represents an Enum type.
	
	The corresponding enum instance type is EnumValue.
	
	See [Type] for the haXe Reflection API.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/usr/lib/haxe/std/EnumValue.hx">
		<haxe_doc>An abstract type that represents any enum value.
	See [Type] for the haXe Reflection API.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<typedef path="BytesOutput" params="" file="src/Imports.hx" module="Imports"><c path="haxe.io.BytesOutput"/></typedef>
	<typedef path="Signal0" params="" file="src/Imports.hx" module="Imports"><c path="ash.signals.Signal0"/></typedef>
	<typedef path="Signal1" params="T" file="src/Imports.hx" module="Imports"><c path="ash.signals.Signal1"><c path="Signal1.T"/></c></typedef>
	<typedef path="Signal2" params="T1:T2" file="src/Imports.hx" module="Imports"><c path="ash.signals.Signal2">
	<c path="Signal2.T1"/>
	<c path="Signal2.T2"/>
</c></typedef>
	<typedef path="BytesInput" params="" file="src/Imports.hx" module="Imports"><c path="haxe.io.BytesInput"/></typedef>
	<typedef path="BytesBuffer" params="" file="src/Imports.hx" module="Imports"><c path="haxe.io.BytesBuffer"/></typedef>
	<typedef path="Bytes" params="" file="src/Imports.hx" module="Imports"><c path="haxe.io.Bytes"/></typedef>
	<typedef path="Timer" params="" file="src/Imports.hx" module="Imports"><c path="haxe.Timer"/></typedef>
	<typedef path="Engine" params="" file="src/Imports.hx" module="Imports"><c path="ash.core.Engine"/></typedef>
	<typedef path="System" params="" file="src/Imports.hx" module="Imports"><c path="ash.core.System"/></typedef>
	<typedef path="NodeList" params="T" file="src/Imports.hx" module="Imports"><c path="ash.core.NodeList"><c path="NodeList.T"/></c></typedef>
	<typedef path="Entity" params="" file="src/Imports.hx" module="Imports"><c path="ash.core.Entity"/></typedef>
	<typedef path="ListIteratingSystem" params="T" file="src/Imports.hx" module="Imports"><c path="ash.tools.ListIteratingSystem"><c path="ListIteratingSystem.T"/></c></typedef>
	<typedef path="Node" params="T" file="src/Imports.hx" module="Imports"><c path="ash.core.Node"><c path="Node.T"/></c></typedef>
	<typedef path="Mat23" params="" file="src/Imports.hx" module="Imports"><c path="nape.geom.Mat23"/></typedef>
	<typedef path="Transform" params="" file="src/Imports.hx" module="Imports"><c path="components.Transform"/></typedef>
	<typedef path="IAnimatable" params="" file="src/Imports.hx" module="Imports"><c path="starling.animation.IAnimatable"/></typedef>
	<typedef path="Array3" params="T" file="src/Imports.hx" module="Imports"><c path="de.polygonal.ds.Array3"><c path="Array3.T"/></c></typedef>
	<typedef path="Vec2" params="" file="src/Imports.hx" module="Imports"><c path="nape.geom.Vec2"/></typedef>
	<typedef path="Actuate" params="" file="src/Imports.hx" module="Imports"><t path="com.eclecticdesignstudio.motion.Actuate"/></typedef>
	<typedef path="M" params="" file="src/Imports.hx" module="Imports"><c path="de.polygonal.core.math.Mathematics"/></typedef>
	<typedef path="Space" params="" file="src/Imports.hx" module="Imports"><c path="nape.space.Space"/></typedef>
	<typedef path="Body" params="" file="src/Imports.hx" module="Imports"><c path="nape.phys.Body"/></typedef>
	<typedef path="GridS" params="" file="src/Imports.hx" module="Imports"><c path="systems.GridS"/></typedef>
	<typedef path="Grid" params="" file="src/Imports.hx" module="Imports"><c path="components.Grid"/></typedef>
	<typedef path="Array2" params="T" file="src/Imports.hx" module="Imports"><c path="de.polygonal.ds.Array2"><c path="Array2.T"/></c></typedef>
	<typedef path="Random" params="" file="src/Imports.hx" module="Imports"><c path="de.polygonal.core.math.random.Random"/></typedef>
	<typedef path="Tile" params="" file="src/Imports.hx" module="Imports"><c path="components.Tile"/></typedef>
	<typedef path="GridRenderS" params="" file="src/Imports.hx" module="Imports"><c path="systems.GridRenderS"/></typedef>
	<typedef path="Socket" params="" file="src/Imports.hx" module="Imports"><c path="flash.net.Socket"/></typedef>
	<typedef path="Event" params="" file="src/Imports.hx" module="Imports"><c path="flash.events.Event"/></typedef>
	<typedef path="ProgressEvent" params="" file="src/Imports.hx" module="Imports"><c path="flash.events.ProgressEvent"/></typedef>
	<typedef path="IOErrorEvent" params="" file="src/Imports.hx" module="Imports"><c path="flash.events.IOErrorEvent"/></typedef>
	<typedef path="SecurityErrorEvent" params="" file="src/Imports.hx" module="Imports"><c path="flash.events.SecurityErrorEvent"/></typedef>
	<typedef path="EventDispatcher" params="" file="src/Imports.hx" module="Imports"><c path="flash.events.EventDispatcher"/></typedef>
	<typedef path="ByteArray" params="" file="src/Imports.hx" module="Imports"><c path="flash.utils.ByteArray"/></typedef>
	<typedef path="Starling" params="" file="src/Imports.hx" module="Imports"><c path="starling.core.Starling"/></typedef>
	<typedef path="Sprite" params="" file="src/Imports.hx" module="Imports"><c path="starling.display.Sprite"/></typedef>
	<typedef path="Quad" params="" file="src/Imports.hx" module="Imports"><c path="starling.display.Quad"/></typedef>
	<typedef path="Color" params="" file="src/Imports.hx" module="Imports"><c path="starling.utils.Color"/></typedef>
	<typedef path="DisplayObject" params="" file="src/Imports.hx" module="Imports"><c path="starling.display.DisplayObject"/></typedef>
	<typedef path="RenderS" params="" file="src/Imports.hx" module="Imports"><c path="systems.RenderS"/></typedef>
	<typedef path="Display" params="" file="src/Imports.hx" module="Imports"><c path="components.Display"/></typedef>
	<typedef path="DisplayObjectContainer" params="" file="src/Imports.hx" module="Imports"><c path="starling.display.DisplayObjectContainer"/></typedef>
	<typedef path="Graphics" params="" file="src/Imports.hx" module="Imports"><c path="graphics.Graphics"/></typedef>
	<typedef path="Texture" params="" file="src/Imports.hx" module="Imports"><c path="starling.textures.Texture"/></typedef>
	<typedef path="BitmapData" params="" file="src/Imports.hx" module="Imports"><c path="flash.display.BitmapData"/></typedef>
	<typedef path="Bitmap" params="" file="src/Imports.hx" module="Imports"><c path="flash.display.Bitmap"/></typedef>
	<typedef path="XML" params="" file="src/Imports.hx" module="Imports"><c path="flash.xml.XML"/></typedef>
	<typedef path="TextureAtlas" params="" file="src/Imports.hx" module="Imports"><c path="starling.textures.TextureAtlas"/></typedef>
	<typedef path="Image" params="" file="src/Imports.hx" module="Imports"><c path="starling.display.Image"/></typedef>
	<typedef path="MouseEvent" params="" file="src/Imports.hx" module="Imports"><c path="flash.events.MouseEvent"/></typedef>
	<typedef path="KeyboardEvent" params="" file="src/Imports.hx" module="Imports"><c path="flash.events.KeyboardEvent"/></typedef>
	<typedef path="Keyboard" params="" file="src/Imports.hx" module="Imports"><c path="flash.ui.Keyboard"/></typedef>
	<typedef path="TextField" params="" file="src/Imports.hx" module="Imports"><c path="starling.text.TextField"/></typedef>
	<class path="KeyboardInput" params="" file="src/KeyboardInput.hx">
		<isUp public="1" set="method" line="52"><f a="keyCode">
	<x path="Int"/>
	<x path="Bool"/>
</f></isUp>
		<isDown public="1" set="method" line="47"><f a="keyCode">
	<x path="Int"/>
	<x path="Bool"/>
</f></isDown>
		<states><t path="Bytes"/></states>
		<stage><c path="flash.display.Stage"/></stage>
		<onKeyUp public="1"><t path="Signal1"><x path="Int"/></t></onKeyUp>
		<onKeyDown public="1"><t path="Signal1"><x path="Int"/></t></onKeyDown>
		<new public="1" set="method" line="14"><f a="stage">
	<c path="flash.display.Stage"/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="Map" params="K:V" file="/usr/lib/haxe/std/Map.hx">
		<from>
			<c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c>
			<c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c>
			<x path="haxe.ds.HashMap">
				<c path="fromHashMap.K"/>
				<c path="fromHashMap.V"/>
			</x>
			<c path="haxe.ds.ObjectMap">
				<c path="fromObjectMap.K"/>
				<c path="fromObjectMap.V"/>
			</c>
		</from>
		<to>
			<c path="haxe.ds.StringMap"><c path="Map.V"/></c>
			<c path="haxe.ds.IntMap"><c path="Map.V"/></c>
			<x path="haxe.ds.HashMap">
				<c path="toHashMap.K"/>
				<c path="Map.V"/>
			</x>
			<c path="haxe.ds.ObjectMap">
				<c path="toObjectMap.K"/>
				<c path="Map.V"/>
			</c>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.
		
	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.
	
	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.
	
	Maps can also be created with [key1 => value1, key2 => value2] syntax.
	
	Map is an abstract type, it is not available at runtime.]]></haxe_doc>
		<meta><m n=":multiType"/></meta>
	</abstract>
	<typedef path="_Map.IMap" params="K:V" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map"><a>
	<set set="method"><f a="k:v">
	<c path="_Map.IMap.K"/>
	<c path="_Map.IMap.V"/>
	<x path="Void"/>
</f></set>
	<remove set="method"><f a="k">
	<c path="_Map.IMap.K"/>
	<x path="Bool"/>
</f></remove>
	<keys set="method"><f a=""><t path="Iterator"><c path="_Map.IMap.K"/></t></f></keys>
	<iterator set="method"><f a=""><t path="Iterator"><c path="_Map.IMap.V"/></t></f></iterator>
	<get set="method"><f a="k">
	<c path="_Map.IMap.K"/>
	<t path="Null"><c path="_Map.IMap.V"/></t>
</f></get>
	<exists set="method"><f a="k">
	<c path="_Map.IMap.K"/>
	<x path="Bool"/>
</f></exists>
</a></typedef>
	<typedef path="_Map.Hashable" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map"><a><hashCode set="method"><f a=""><x path="Int"/></f></hashCode></a></typedef>
	<class path="Math" params="" file="/usr/lib/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><x path="Float"/></PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.
		
		For example, this is the result of -1.0 / 0.0.
		
		Operations with NEGATIVE_INFINITY as an operand may result in
		Operations with NEGATIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. For detailed information,
		see ...
		
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.
		
		For example, this is the result of 1.0 / 0.0.
		
		Operations with POSITIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. For detailed information,
		see ...
	
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes an invalid number.
		
		NaN stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: Math.sqrt(-1).
		
		All further operations with NaN as an operand will result in NaN.
		
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.
		
		In order to test if a value is NaN, you should use Math.isNaN() function.
		
		(Php) In PHP versions prior to 5.3.1 VC 9 there may be unexpected
		results when performing arithmetic operations with NaN on Windows, see:
			https://bugs.php.net/bug.php?id=42143</haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of [v].
		
		If [v] is positive or 0, the result is unchanged. Otherwise the result
		is -[v].
		
		If [v] is NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is
		POSITIVE_INFINITY.
		
		If [v] is NaN, the result is NaN.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values [a] and [b].
		
		If [a] or [b] are NaN, the result is NaN.
		
		If [a] or [b] are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.
		
		If [a] and [b] are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values [a] and [b].
		
		If [a] or [b] are NaN, the result is NaN.
		
		If [a] or [b] are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If [a] and [b] are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of [v].
		
		The unit of [v] is radians.
		
		If [v] is NaN or infinite, the result is NaN.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of [v].
		
		The unit of [v] is radians.
		
		If [v] is NaN or infinite, the result is NaN.</haxe_doc>
		</cos>
		<tan public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></tan>
		<asin public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></acos>
		<atan public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></atan>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></atan2>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of [v].
		
		exp(1.0) is approximately 2.718281828459.
		
		If [v] is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If [v] is NEGATIVE_INFINITY, the result is 0.0.
		
		If [v] is NaN, the result is NaN.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of [v].
		
		If [v] is negative (including NEGATIVE_INFINITY) or NaN, the result is
		NaN.
		
		If [v] is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If [v] is 0.0, the result is NEGATIVE_INFINITY.
		
		This is the inverse operation of exp, i.e. log(exp(v)) == v always
		holds.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of [v].
		
		If [v] is negative (including NEGATIVE_INFINITY) or NaN, the result is
		NaN.
		
		If [v] is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If [v] is 0.0, the result is 0.0.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds [v] to the nearest Int value.

		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.
		
		TODO: need spec</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest Int value that is not greater than [v].
		
		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.		
		
		TODO: need spec</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest Int value that is not less than [v].

		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.
		
		TODO: need spec</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to 0.0,
		and less than 1.0.</haxe_doc>
		</random>
		<ffloor public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></ffloor>
		<fceil public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fceil>
		<fround public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fround>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if [f] is a finite number.
		
		If [f] is POSITIVE_INFINITY, NEGATIVE_INFINITY or NaN, the result is
		false.
		
		Otherwise the result is true.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if [f] is not a valid number.
		
		If [f] is NaN, the result is true.
		
		Otherwise the result is false. In particular, both POSITIVE_INFINITY and
		NEGATIVE_INFINITY are not considered NaN.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
	</class>
	<class path="MouseInput" params="" file="src/MouseInput.hx">
		<onRightClick public="1"><t path="Signal1"><t path="Vec2"/></t></onRightClick>
		<onClick public="1"><t path="Signal1"><t path="Vec2"/></t></onClick>
		<new public="1" set="method" line="11"><f a="stage">
	<c path="flash.display.Stage"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="Reflect" params="" file="/usr/lib/haxe/std/flash/_std/Reflect.hx">
		<hasField public="1" set="method" line="24" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if an object has a field set. This doesn't take into account the object prototype (class methods).</haxe_doc>
		</hasField>
		<field public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the field of an object, or null if [o] is not an object or doesn't have this field.</haxe_doc>
		</field>
		<getProperty public="1" set="method" line="37" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Similar to field but also supports property (might be slower).</haxe_doc>
		</getProperty>
		<setProperty public="1" set="method" line="47" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Similar to setField but also supports property (might be slower).</haxe_doc>
		</setProperty>
		<fields public="1" set="method" line="59" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of fields of an object, excluding its prototype (class methods).</haxe_doc>
		</fields>
		<copy public="1" params="T" set="method" line="117" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>Make a copy of the fields of an object.</haxe_doc>
		</copy>
		<haxe_doc>The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Std" params="" file="/usr/lib/haxe/std/flash/_std/Std.hx">
		<is public="1" set="method" line="26" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if a value v is of the type t. Returns false if v or t are null.</haxe_doc>
		</is>
		<string public="1" set="method" line="30" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If s is of String, Int, Float or Bool, its value is returned.

		If s is an instance of a class and that class or one of its parent classes has
		a toString() method, that method is called. If no such method is present, the result
		is unspecified.

		If s is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If s is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<haxe_doc>The standard Void type. Only [null] values can be of the type [Void].</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<haxe_doc>The standard Float type, this is a double-precision IEEE 64bit float.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<to><x path="Float"/></to>
		<haxe_doc>The standard Int type. Its precision depends on the platform.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="UInt" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<from><x path="Int"/></from>
		<to><x path="Int"/></to>
		<haxe_doc>The unsigned Int type is only defined for Flash9. It's currently
	handled the same as a normal Int.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<abstract path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<haxe_doc>The standard Boolean type is represented as an enum with two choices.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<haxe_doc>Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the Iterator and advances to the next one.
		
		This method is not required to check hasNext() first. A call to this
		method while hasNext() is false yields unspecified behavior.</haxe_doc>
			</next>
			<hasNext set="method"><f a=""><x path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits iteration over elements of type T.

	Any class with matching hasNext and next fields is considered an Iterator
	and can then be used e.g. in for-loops. This makes it easy to implement
	custom iterators.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.</haxe_doc></class>
	<class path="String" params="" file="/usr/lib/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code [code].
		
		If [code] is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of [this] String from [startIndex] to [endIndex].
		
		If [endIndex] is omitted, [this].length is used instead.
		
		If [startIndex] or [endIndex] are negative, 0 is used instead.
		
		If [startIndex] exceeds [endIndex], they are swapped.</haxe_doc>
		</substring>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns [len] characters of [this] String, starting at position [pos].
		
		If [len] is omitted, all characters from position [pos] to the end of
		[this] String are included.
		
		If [pos] is negative, its values is calculated from the end	of [this]
		String by [this].length + [pos]. If this yields a negative value, 0 is
		used instead.
		
		If [len] is negative, the result is unspecified.</haxe_doc>
		</substr>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits [this] String at each occurence of [delimiter].
		
		If [delimiter] is the empty String "", [this] String is split into an
		Array of [this].length elements, where the elements correspond to the
		characters of [this] String.
		
		If [delimiter] is not found within [this] String, the result is an Array
		with one element, which equals [this] String.
		
		If [delimiter] is null, the result is unspecified.
		
		Otherwise, [this] String is split into parts at each occurence of
		[delimiter]. If [this] String starts (or ends) with [delimiter}, the
		result Array contains a leading (or trailing) empty String "" element.
		Two subsequent delimiters also result in an empty String "" element.</haxe_doc>
		</split>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurence of [str] within [this]
		String.
		
		If [startIndex] is given, the search is performed within the substring
		of [this] String from 0 to [startIndex]. Otherwise the search is
		performed within [this] String. In either case, the returned position
		is relative to the beginning of [this] String.
		
		If [str] cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurence of [str] within [this]
		String.
		
		If [startIndex] is given, the search is performed within the substring
		of [this] String starting from [startIndex]. Otherwise the search is
		performed within [this] String. In either case, the returned position
		is relative to the beginning of [this] String.
		
		If [str] cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at position [index] of [this] String.
		
		If [index] is negative or exceeds [this].length, null is returned.
		
		To obtain the character code of a single character, "x".code can be used
		instead to inline the character code at compile time. Note that this
		only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position [index] of [this] String.
		
		If [index] is negative or exceeds [this].length, the empty String ""
		is returned.</haxe_doc>
		</charAt>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of [this] String are lower case.
		
		Affects the characters [A-Z]. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of [this] String are upper case.
		
		Affects the characters [a-z]. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in [this] String.</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.
	
	A haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of [this] String.
	
	Strings can be constructed using the string literal syntax "string value".
	
	String can be concatenated by using the + operator. If an operand is not a
	String, it is passed through Std.string() first.</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="/usr/lib/haxe/std/StringBuf.hx">
		<b><c path="String"/></b>
		<new public="1" set="method" line="42">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.
		
		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.
	
	Its cross-platform implementation uses String concatenation internally, but
	StringBuf may be optimized for different targets.
	
	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values. However, the internal buffer cannot be modified.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="StringTools" params="" file="/usr/lib/haxe/std/StringTools.hx">
		<lpad public="1" set="method" line="245" static="1"><f a="s:c:l">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
</f></lpad>
		<rpad public="1" set="method" line="267" static="1"><f a="s:c:l">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
</f></rpad>
		<hex public="1" set="method" line="310" static="1"><f a="n:?digits">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></hex>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	'using StringTools' and then acts as an extension to the String class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="Type" params="" file="/usr/lib/haxe/std/flash/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="36" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<haxe_doc>Returns the class of [o], if [o] is a class instance.
		
		If [o] is null or of a different type, null is returned.
		
		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<createInstance public="1" params="T" set="method" line="130" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class [cl], using [args] as arguments to the
		class constructor.
		
		This function guarantees that the class constructor is called.
		
		Default values of constructors arguments are not guaranteed to be
		taken into account.
		
		If [cl] or [args] are null, or if the number of elements in [args] does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if [cl] has no own constructor, the
		result is unspecified.
		
		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="151" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class [cl].
		
		This function guarantees that the class constructor is not called.
		
		If [cl] is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<haxe_doc>The haxe Reflection API allows retrieval of type information at runtime.
	
	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="ash.GenericListIterator" params="TNode" file="libSrc/Ash-Haxe/src/ash/GenericListIterator.hx">
		<next public="1" set="method" line="21"><f a=""><c path="ash.GenericListIterator.TNode"/></f></next>
		<hasNext public="1" set="method" line="16"><f a=""><x path="Bool"/></f></hasNext>
		<previous><t path="ash._GenericListIterator.HasNext"><c path="ash.GenericListIterator.TNode"/></t></previous>
		<new public="1" set="method" line="11"><f a="head">
	<c path="ash.GenericListIterator.TNode"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* An iterator class for any linked lists that
 * has "next" variable in its elements.</haxe_doc>
	</class>
	<typedef path="ash._GenericListIterator.HasNext" params="T" file="libSrc/Ash-Haxe/src/ash/GenericListIterator.hx" private="1" module="ash.GenericListIterator"><a><next><c path="ash._GenericListIterator.HasNext.T"/></next></a></typedef>
	<typedef path="ash.ObjectMap" params="K:V" file="libSrc/Ash-Haxe/src/ash/ObjectMap.hx"><c path="haxe.ds.ObjectMap">
	<c path="ash.ObjectMap.K"/>
	<c path="ash.ObjectMap.V"/>
</c></typedef>
	<class path="ash.core.IFamily" params="TNode" file="libSrc/Ash-Haxe/src/ash/core/IFamily.hx" interface="1">
		<cleanUp public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* The family is about to be discarded. Clean up all properties as necessary. Usually, you will
     * want to empty the NodeList at this time.</haxe_doc>
		</cleanUp>
		<componentRemovedFromEntity public="1" set="method">
			<f a="entity:componentClass">
				<c path="ash.core.Entity"/>
				<x path="Class"><d/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* A component has been removed from an entity. Test whether the entity's inclusion in this family's
     * NodeList should be modified.</haxe_doc>
		</componentRemovedFromEntity>
		<componentAddedToEntity public="1" set="method">
			<f a="entity:componentClass">
				<c path="ash.core.Entity"/>
				<x path="Class"><d/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* A component has been added to an entity. Test whether the entity's inclusion in this family's
     * NodeList should be modified.</haxe_doc>
		</componentAddedToEntity>
		<removeEntity public="1" set="method">
			<f a="entity">
				<c path="ash.core.Entity"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* An entity has been removed from the engine. If it's in this family's NodeList it should be removed.</haxe_doc>
		</removeEntity>
		<newEntity public="1" set="method">
			<f a="entity">
				<c path="ash.core.Entity"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* An entity has been added to the engine. It may already have components so test the entity
     * for inclusion in this family's NodeList.</haxe_doc>
		</newEntity>
		<nodeList public="1" set="null">
			<c path="ash.core.NodeList"><c path="ash.core.IFamily.TNode"/></c>
			<haxe_doc>* Returns the NodeList managed by this class. This should be a reference that remains valid always
     * since it is retained and reused by Systems that use the list. i.e. never recreate the list,
     * always modify it in place.</haxe_doc>
		</nodeList>
		<haxe_doc>* The interface for classes that are used to manage NodeLists (set as the familyClass property
 * in the Engine object). Most developers don't need to use this since the default implementation
 * is used by default and suits most needs.</haxe_doc>
	</class>
	<class path="ash.core.ComponentMatchingFamily" params="TNode" file="libSrc/Ash-Haxe/src/ash/core/ComponentMatchingFamily.hx">
		<implements path="ash.core.IFamily"><c path="ash.core.ComponentMatchingFamily.TNode"/></implements>
		<cleanUp public="1" set="method" line="159"><f a=""><x path="Void"/></f></cleanUp>
		<releaseNodePoolCache set="method" line="150"><f a=""><x path="Void"/></f></releaseNodePoolCache>
		<removeIfMatch set="method" line="127"><f a="entity">
	<c path="ash.core.Entity"/>
	<x path="Void"/>
</f></removeIfMatch>
		<addIfMatch set="method" line="102"><f a="entity">
	<c path="ash.core.Entity"/>
	<x path="Void"/>
</f></addIfMatch>
		<removeEntity public="1" set="method" line="93"><f a="entity">
	<c path="ash.core.Entity"/>
	<x path="Void"/>
</f></removeEntity>
		<componentRemovedFromEntity public="1" set="method" line="81"><f a="entity:componentClass">
	<c path="ash.core.Entity"/>
	<x path="Class"><d/></x>
	<x path="Void"/>
</f></componentRemovedFromEntity>
		<componentAddedToEntity public="1" set="method" line="71"><f a="entity:componentClass">
	<c path="ash.core.Entity"/>
	<x path="Class"><d/></x>
	<x path="Void"/>
</f></componentAddedToEntity>
		<newEntity public="1" set="method" line="62"><f a="entity">
	<c path="ash.core.Entity"/>
	<x path="Void"/>
</f></newEntity>
		<init set="method" line="45"><f a=""><x path="Void"/></f></init>
		<engine><c path="ash.core.Engine"/></engine>
		<nodePool><c path="ash.core.NodePool"><c path="ash.core.ComponentMatchingFamily.TNode"/></c></nodePool>
		<components><t path="ash.ObjectMap">
	<x path="Class"><d/></x>
	<c path="String"/>
</t></components>
		<nodeClass><x path="Class"><c path="ash.core.ComponentMatchingFamily.TNode"/></x></nodeClass>
		<entities><t path="ash.ObjectMap">
	<c path="ash.core.Entity"/>
	<c path="ash.core.ComponentMatchingFamily.TNode"/>
</t></entities>
		<nodeList public="1" set="null">
			<c path="ash.core.NodeList"><c path="ash.core.ComponentMatchingFamily.TNode"/></c>
			<haxe_doc>* The nodelist managed by this family. This is a reference that remains valid always
     * since it is retained and reused by Systems that use the list. i.e. we never recreate the list,
     * we always modify it in place.</haxe_doc>
		</nodeList>
		<new public="1" set="method" line="34">
			<f a="nodeClass:engine">
				<x path="Class"><c path="ash.core.ComponentMatchingFamily.TNode"/></x>
				<c path="ash.core.Engine"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The constructor. Creates a ComponentMatchingFamily to provide a NodeList for the
     * given node class.
     *
     * @param nodeClass The type of node to create and manage a NodeList for.
     * @param engine The engine that this family is managing teh NodeList for.</haxe_doc>
		</new>
		<haxe_doc>* The default class for managing a NodeList. This class creates the NodeList and adds and removes
 * nodes to/from the list as the entities and the components in the engine change.
 *
 * It uses the basic entity matching pattern of an entity system - entities are added to the list if
 * they contain components matching all the public properties of the node class.</haxe_doc>
	</class>
	<class path="ash.core.Engine" params="" file="libSrc/Ash-Haxe/src/ash/core/Engine.hx">
		<update public="1" set="method" line="288"><f a="time">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<removeAllSystems public="1" set="method" line="270"><f a=""><x path="Void"/></f></removeAllSystems>
		<removeSystem public="1" set="method" line="260"><f a="system">
	<c path="ash.core.System"/>
	<x path="Void"/>
</f></removeSystem>
		<get_systems get="inline" set="null" line="249"><f a=""><t path="Iterable"><c path="ash.core.System"/></t></f></get_systems>
		<getSystem public="1" params="TSystem" set="method" line="241"><f a="type">
	<x path="Class"><c path="getSystem.TSystem"/></x>
	<c path="getSystem.TSystem"/>
</f></getSystem>
		<addSystem public="1" set="method" line="226"><f a="system:priority">
	<c path="ash.core.System"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addSystem>
		<releaseNodeList public="1" params="TNode" set="method" line="204"><f a="nodeClass">
	<x path="Class"><c path="releaseNodeList.TNode"/></x>
	<x path="Void"/>
</f></releaseNodeList>
		<getNodeList public="1" params="TNode" set="method" line="179"><f a="nodeClass">
	<x path="Class"><c path="getNodeList.TNode"/></x>
	<c path="ash.core.NodeList"><c path="getNodeList.TNode"/></c>
</f></getNodeList>
		<componentRemoved set="method" line="158"><f a="entity:componentClass">
	<c path="ash.core.Entity"/>
	<x path="Class"><d/></x>
	<x path="Void"/>
</f></componentRemoved>
		<componentAdded set="method" line="146"><f a="entity:componentClass">
	<c path="ash.core.Entity"/>
	<x path="Class"><d/></x>
	<x path="Void"/>
</f></componentAdded>
		<get_entities get="inline" set="null" line="137"><f a=""><t path="Iterable"><c path="ash.core.Entity"/></t></f></get_entities>
		<removeAllEntities public="1" set="method" line="126"><f a=""><x path="Void"/></f></removeAllEntities>
		<getEntityByName public="1" get="inline" set="null" line="118"><f a="name">
	<c path="String"/>
	<c path="ash.core.Entity"/>
</f></getEntityByName>
		<entityNameChanged set="method" line="103"><f a="entity:oldName">
	<c path="ash.core.Entity"/>
	<c path="String"/>
	<x path="Void"/>
</f></entityNameChanged>
		<removeEntity public="1" set="method" line="89"><f a="entity">
	<c path="ash.core.Entity"/>
	<x path="Void"/>
</f></removeEntity>
		<addEntity public="1" set="method" line="67"><f a="entity">
	<c path="ash.core.Entity"/>
	<x path="Void"/>
</f></addEntity>
		<familyClass public="1">
			<x path="Class"><c path="ash.core.IFamily"><d/></c></x>
			<haxe_doc>* The class used to manage node lists. In most cases the default class is sufficient
     * but it is exposed here so advanced developers can choose to create and use a
     * different implementation.
     *
     * The class must implement the IFamily interface.</haxe_doc>
		</familyClass>
		<updateComplete public="1" set="null">
			<c path="ash.signals.Signal0"/>
			<haxe_doc>* Dispatched when the update loop ends. If you want to add and remove systems from the
     * engine it is usually best not to do so during the update loop. To avoid this you can
     * listen for this signal and make the change when the signal is dispatched.</haxe_doc>
		</updateComplete>
		<entityRemoved public="1" set="null"><c path="ash.signals.Signal1"><c path="ash.core.Entity"/></c></entityRemoved>
		<entityAdded public="1" set="null"><c path="ash.signals.Signal1"><c path="ash.core.Entity"/></c></entityAdded>
		<updating public="1">
			<x path="Bool"/>
			<haxe_doc>* Indicates if the engine is currently in its update loop.</haxe_doc>
		</updating>
		<families><t path="ash.ObjectMap">
	<x path="Class"><d/></x>
	<c path="ash.core.IFamily"><d/></c>
</t></families>
		<systemList><c path="ash.core.SystemList"/></systemList>
		<entityList><c path="ash.core.EntityList"/></entityList>
		<entityNames><x path="Map">
	<c path="String"/>
	<c path="ash.core.Entity"/>
</x></entityNames>
		<systems public="1" get="get_systems" set="null"><t path="Iterable"><c path="ash.core.System"/></t></systems>
		<entities public="1" get="get_entities" set="null"><t path="Iterable"><c path="ash.core.Entity"/></t></entities>
		<new public="1" set="method" line="49"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* The Engine class is the central point for creating and managing your game state. Add
 * entities and systems to the engine, and fetch families of nodes from the engine.</haxe_doc>
	</class>
	<class path="ash.core.Entity" params="" file="libSrc/Ash-Haxe/src/ash/core/Entity.hx">
		<nameCount line="26" static="1"><x path="Int"/></nameCount>
		<has public="1" set="method" line="154"><f a="componentClass">
	<x path="Class"><d/></x>
	<x path="Bool"/>
</f></has>
		<getAll public="1" set="method" line="139"><f a=""><c path="Array"><d/></c></f></getAll>
		<get public="1" params="T" set="method" line="128"><f a="componentClass">
	<x path="Class"><d/></x>
	<c path="get.T"/>
</f></get>
		<remove public="1" params="T" set="method" line="109"><f a="componentClass">
	<x path="Class"><d/></x>
	<c path="remove.T"/>
</f></remove>
		<add public="1" params="T" set="method" line="89"><f a="component:?componentClass">
	<c path="add.T"/>
	<x path="Class"><d/></x>
	<c path="ash.core.Entity"/>
</f></add>
		<set_name get="inline" set="null" line="62"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_name>
		<components public="1" set="null"><t path="ash.ObjectMap">
	<x path="Class"><d/></x>
	<d/>
</t></components>
		<next public="1"><c path="ash.core.Entity"/></next>
		<previous public="1"><c path="ash.core.Entity"/></previous>
		<nameChanged public="1">
			<c path="ash.signals.Signal2">
				<c path="ash.core.Entity"/>
				<c path="String"/>
			</c>
			<haxe_doc>* Dispatched when the name of the entity changes. Used internally by the engine to track entities based on their names.</haxe_doc>
		</nameChanged>
		<componentRemoved public="1" set="null">
			<c path="ash.signals.Signal2">
				<c path="ash.core.Entity"/>
				<x path="Class"><d/></x>
			</c>
			<haxe_doc>* This signal is dispatched when a component is removed from the entity.</haxe_doc>
		</componentRemoved>
		<componentAdded public="1" set="null">
			<c path="ash.signals.Signal2">
				<c path="ash.core.Entity"/>
				<x path="Class"><d/></x>
			</c>
			<haxe_doc>* This signal is dispatched when a component is added to the entity.</haxe_doc>
		</componentAdded>
		<name public="1" set="set_name">
			<c path="String"/>
			<haxe_doc>* Optional, give the entity a name. This can help with debugging and with serialising the entity.</haxe_doc>
		</name>
		<new public="1" set="method" line="49"><f a="?name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* An entity is composed from components. As such, it is essentially a collection object for components.
 * Sometimes, the entities in a game will mirror the actual characters and objects in the game, but this
 * is not necessary.
 *
 * <p>Components are simple value objects that contain data relevant to the entity. Entities
 * with similar functionality will have instances of the same components. So we might have
 * a position component</p>
 *
 * <p><code>class PositionComponent
 * {
 *   public var x:Float;
 *   public var y:Float;
 * }</code></p>
 *
 * <p>All entities that have a position in the game world, will have an instance of the
 * position component. Systems operate on entities based on the components they have.</p>]]></haxe_doc>
	</class>
	<class path="ash.core.EntityList" params="" file="libSrc/Ash-Haxe/src/ash/core/EntityList.hx">
		<iterator public="1" set="method" line="59"><f a=""><t path="Iterator"><c path="ash.core.Entity"/></t></f></iterator>
		<removeAll public="1" set="method" line="47"><f a=""><x path="Void"/></f></removeAll>
		<remove public="1" set="method" line="34"><f a="entity">
	<c path="ash.core.Entity"/>
	<x path="Void"/>
</f></remove>
		<add public="1" set="method" line="18"><f a="entity">
	<c path="ash.core.Entity"/>
	<x path="Void"/>
</f></add>
		<tail public="1" set="null"><c path="ash.core.Entity"/></tail>
		<head public="1" set="null"><c path="ash.core.Entity"/></head>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* An internal class for a linked list of entities. Used inside the framework for
 * managing the entities.</haxe_doc>
	</class>
	<class path="ash.core.Node" params="TNode" file="libSrc/Ash-Haxe/src/ash/core/Node.hx">
		<next public="1">
			<c path="ash.core.Node.TNode"/>
			<haxe_doc>* Used by the NodeList class. The next node in a node list.</haxe_doc>
		</next>
		<previous public="1">
			<c path="ash.core.Node.TNode"/>
			<haxe_doc>* Used by the NodeList class. The previous node in a node list.</haxe_doc>
		</previous>
		<entity public="1">
			<c path="ash.core.Entity"/>
			<haxe_doc>* The entity whose components are included in the node.</haxe_doc>
		</entity>
		<haxe_doc><![CDATA[* The base class for a node.
 *
 * <p>A node is a set of different components that are required by a system.
 * A system can request a collection of nodes from the engine. Subsequently the Engine object creates
 * a node for every entity that has all of the components in the node class and adds these nodes
 * to the list obtained by the system. The engine keeps the list up to date as entities are added
 * to and removed from the engine and as the components on entities change.</p>]]></haxe_doc>
		<meta><m n=":autoBuild"><e>'???'</e></m></meta>
	</class>
	<class path="ash.core.NodeList" params="TNode" file="libSrc/Ash-Haxe/src/ash/core/NodeList.hx">
		<merge set="method" line="283"><f a="head1:head2:sortFunction">
	<c path="ash.core.NodeList.TNode"/>
	<c path="ash.core.NodeList.TNode"/>
	<t path="ash.core.SortFunction"><c path="ash.core.NodeList.TNode"/></t>
	<c path="ash.core.NodeList.TNode"/>
</f></merge>
		<mergeSort public="1" set="method" line="251"><f a="sortFunction">
	<t path="ash.core.SortFunction"><c path="ash.core.NodeList.TNode"/></t>
	<x path="Void"/>
</f></mergeSort>
		<insertionSort public="1" set="method" line="179"><f a="sortFunction">
	<t path="ash.core.SortFunction"><c path="ash.core.NodeList.TNode"/></t>
	<x path="Void"/>
</f></insertionSort>
		<swap public="1" set="method" line="120"><f a="node1:node2">
	<c path="ash.core.NodeList.TNode"/>
	<c path="ash.core.NodeList.TNode"/>
	<x path="Void"/>
</f></swap>
		<iterator public="1" set="method" line="111"><f a=""><t path="Iterator"><c path="ash.core.NodeList.TNode"/></t></f></iterator>
		<get_empty get="inline" set="null" line="106"><f a=""><x path="Bool"/></f></get_empty>
		<empty public="1" get="get_empty" set="null"><x path="Bool"/></empty>
		<removeAll public="1" set="method" line="88"><f a=""><x path="Void"/></f></removeAll>
		<remove public="1" set="method" line="71"><f a="node">
	<c path="ash.core.NodeList.TNode"/>
	<x path="Void"/>
</f></remove>
		<add public="1" set="method" line="54"><f a="node">
	<c path="ash.core.NodeList.TNode"/>
	<x path="Void"/>
</f></add>
		<nodeRemoved public="1" set="null">
			<c path="ash.signals.Signal1"><c path="ash.core.NodeList.TNode"/></c>
			<haxe_doc><![CDATA[* A signal that is dispatched whenever a node is removed from the node list.
     *
     * <p>The signal will pass a single parameter to the listeners - the node that was removed.</p>]]></haxe_doc>
		</nodeRemoved>
		<nodeAdded public="1" set="null">
			<c path="ash.signals.Signal1"><c path="ash.core.NodeList.TNode"/></c>
			<haxe_doc><![CDATA[* A signal that is dispatched whenever a node is added to the node list.
     *
     * <p>The signal will pass a single parameter to the listeners - the node that was added.</p>]]></haxe_doc>
		</nodeAdded>
		<tail public="1" set="null">
			<c path="ash.core.NodeList.TNode"/>
			<haxe_doc>* The last item in the node list, or null if the list contains no nodes.</haxe_doc>
		</tail>
		<head public="1" set="null">
			<c path="ash.core.NodeList.TNode"/>
			<haxe_doc>* The first item in the node list, or null if the list contains no nodes.</haxe_doc>
		</head>
		<new public="1" set="method" line="48"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* A collection of nodes.
 *
 * <p>Systems within the engine access the components of entities via NodeLists. A NodeList contains
 * a node for each Entity in the engine that has all the components required by the node. To iterate
 * over a NodeList, start from the head and step to the next on each loop, until the returned value
 * is null. Or just use for in syntax.</p>
 *
 * <p>for (node in nodeList)
 * {
 *   // do stuff
 * }</p>
 *
 * <p>It is safe to remove items from a nodelist during the loop. When a Node is removed form the
 * NodeList it's previous and next properties still point to the nodes that were before and after
 * it in the NodeList just before it was removed.</p>]]></haxe_doc>
	</class>
	<typedef path="ash.core.SortFunction" params="TNode" file="libSrc/Ash-Haxe/src/ash/core/NodeList.hx" module="ash.core.NodeList"><f a=":">
	<c path="ash.core.SortFunction.TNode"/>
	<c path="ash.core.SortFunction.TNode"/>
	<x path="Int"/>
</f></typedef>
	<class path="ash.core.NodePool" params="TNode" file="libSrc/Ash-Haxe/src/ash/core/NodePool.hx">
		<releaseCache public="1" set="method" line="65"><f a=""><x path="Void"/></f></releaseCache>
		<cache public="1" set="method" line="56"><f a="node">
	<c path="ash.core.NodePool.TNode"/>
	<x path="Void"/>
</f></cache>
		<dispose public="1" set="method" line="46"><f a="node">
	<c path="ash.core.NodePool.TNode"/>
	<x path="Void"/>
</f></dispose>
		<get public="1" set="method" line="28"><f a=""><c path="ash.core.NodePool.TNode"/></f></get>
		<cacheTail><c path="ash.core.NodePool.TNode"/></cacheTail>
		<nodeClass><x path="Class"><c path="ash.core.NodePool.TNode"/></x></nodeClass>
		<tail><c path="ash.core.NodePool.TNode"/></tail>
		<new public="1" set="method" line="20">
			<f a="nodeClass">
				<x path="Class"><c path="ash.core.NodePool.TNode"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a pool for the given node class.</haxe_doc>
		</new>
		<haxe_doc>* This internal class maintains a pool of deleted nodes for reuse by the framework. This reduces the overhead
 * from object creation and garbage collection.
 *
 * Because nodes may be deleted from a NodeList while in use, by deleting Nodes from a NodeList
 * while iterating through the NodeList, the pool also maintains a cache of nodes that are added to the pool
 * but should not be reused yet. They are then released into the pool by calling the releaseCache method.</haxe_doc>
	</class>
	<class path="ash.core.System" params="" file="libSrc/Ash-Haxe/src/ash/core/System.hx">
		<update public="1" set="method" line="69"><f a="time">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<removeFromEngine public="1" set="method" line="54"><f a="engine">
	<c path="ash.core.Engine"/>
	<x path="Void"/>
</f></removeFromEngine>
		<addToEngine public="1" set="method" line="43"><f a="engine">
	<c path="ash.core.Engine"/>
	<x path="Void"/>
</f></addToEngine>
		<priority public="1">
			<x path="Int"/>
			<haxe_doc>* Used internally to hold the priority of this system within the system list. This is
     * used to order the systems so they are updated in the correct order.</haxe_doc>
		</priority>
		<next public="1">
			<c path="ash.core.System"/>
			<haxe_doc>* Used internally to manage the list of systems within the engine. The next system in the list.</haxe_doc>
		</next>
		<previous public="1">
			<c path="ash.core.System"/>
			<haxe_doc>* Used internally to manage the list of systems within the engine. The previous system in the list.</haxe_doc>
		</previous>
		<new public="1" set="method" line="31"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* The base class for a system.
 *
 * <p>A system is part of the core functionality of the game. After a system is added to the engine, its
 * update method will be called on every frame of the engine. When the system is removed from the engine,
 * the update method is no longer called.</p>
 *
 * <p>The aggregate of all systems in the engine is the functionality of the game, with the update
 * methods of those systems collectively constituting the engine update loop. Systems generally operate on
 * node lists - collections of nodes. Each node contains the components from an entity in the engine
 * that match the node.</p>]]></haxe_doc>
	</class>
	<class path="ash.core.SystemList" params="" file="libSrc/Ash-Haxe/src/ash/core/SystemList.hx">
		<iterator public="1" set="method" line="95"><f a=""><t path="Iterator"><c path="ash.core.System"/></t></f></iterator>
		<get public="1" params="TSystem" set="method" line="83"><f a="type">
	<x path="Class"><c path="get.TSystem"/></x>
	<c path="get.TSystem"/>
</f></get>
		<removeAll public="1" set="method" line="71"><f a=""><x path="Void"/></f></removeAll>
		<remove public="1" set="method" line="57"><f a="system">
	<c path="ash.core.System"/>
	<x path="Void"/>
</f></remove>
		<add public="1" set="method" line="17"><f a="system">
	<c path="ash.core.System"/>
	<x path="Void"/>
</f></add>
		<tail public="1" set="null"><c path="ash.core.System"/></tail>
		<head public="1" set="null"><c path="ash.core.System"/></head>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Used internally, this is an ordered list of Systems for use by the engine update loop.</haxe_doc>
	</class>
	<class path="ash.signals.ListenerNode" params="TListener" file="libSrc/Ash-Haxe/src/ash/signals/ListenerNode.hx">
		<once public="1"><x path="Bool"/></once>
		<listener public="1"><c path="ash.signals.ListenerNode.TListener"/></listener>
		<next public="1"><c path="ash.signals.ListenerNode"><c path="ash.signals.ListenerNode.TListener"/></c></next>
		<previous public="1"><c path="ash.signals.ListenerNode"><c path="ash.signals.ListenerNode.TListener"/></c></previous>
		<new public="1" set="method" line="19"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A node in the list of listeners in a signal.</haxe_doc>
	</class>
	<class path="ash.signals.ListenerNodePool" params="TListener" file="libSrc/Ash-Haxe/src/ash/signals/ListenerNodePool.hx">
		<releaseCache public="1" set="method" line="47"><f a=""><x path="Void"/></f></releaseCache>
		<cache public="1" set="method" line="40"><f a="node">
	<c path="ash.signals.ListenerNode"><c path="ash.signals.ListenerNodePool.TListener"/></c>
	<x path="Void"/>
</f></cache>
		<dispose public="1" set="method" line="31"><f a="node">
	<c path="ash.signals.ListenerNode"><c path="ash.signals.ListenerNodePool.TListener"/></c>
	<x path="Void"/>
</f></dispose>
		<get public="1" set="method" line="16"><f a=""><c path="ash.signals.ListenerNode"><c path="ash.signals.ListenerNodePool.TListener"/></c></f></get>
		<cacheTail><c path="ash.signals.ListenerNode"><c path="ash.signals.ListenerNodePool.TListener"/></c></cacheTail>
		<tail><c path="ash.signals.ListenerNode"><c path="ash.signals.ListenerNodePool.TListener"/></c></tail>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* This internal class maintains a pool of deleted listener nodes for reuse by framework. This reduces
 * the overhead from object creation and garbage collection.</haxe_doc>
	</class>
	<class path="ash.signals.SignalBase" params="TListener" file="libSrc/Ash-Haxe/src/ash/signals/SignalBase.hx">
		<iterator set="method" line="226"><f a=""><t path="Iterator"><c path="ash.signals.ListenerNode"><c path="ash.signals.SignalBase.TListener"/></c></t></f></iterator>
		<removeAll public="1" set="method" line="211"><f a=""><x path="Void"/></f></removeAll>
		<remove public="1" set="method" line="145"><f a="listener">
	<c path="ash.signals.SignalBase.TListener"/>
	<x path="Void"/>
</f></remove>
		<addNode set="method" line="114"><f a="node">
	<c path="ash.signals.ListenerNode"><c path="ash.signals.SignalBase.TListener"/></c>
	<x path="Void"/>
</f></addNode>
		<addOnce public="1" set="method" line="100"><f a="listener">
	<c path="ash.signals.SignalBase.TListener"/>
	<x path="Void"/>
</f></addOnce>
		<add public="1" set="method" line="87"><f a="listener">
	<c path="ash.signals.SignalBase.TListener"/>
	<x path="Void"/>
</f></add>
		<nodeExists get="inline" set="null" line="63"><f a="listener">
	<c path="ash.signals.SignalBase.TListener"/>
	<x path="Bool"/>
</f></nodeExists>
		<endDispatch set="method" line="41"><f a=""><x path="Void"/></f></endDispatch>
		<startDispatch set="method" line="36"><f a=""><x path="Void"/></f></startDispatch>
		<dispatching><x path="Bool"/></dispatching>
		<toAddTail><c path="ash.signals.ListenerNode"><c path="ash.signals.SignalBase.TListener"/></c></toAddTail>
		<toAddHead><c path="ash.signals.ListenerNode"><c path="ash.signals.SignalBase.TListener"/></c></toAddHead>
		<listenerNodePool><c path="ash.signals.ListenerNodePool"><c path="ash.signals.SignalBase.TListener"/></c></listenerNodePool>
		<nodes><t path="ash.ObjectMap">
	<c path="ash.signals.SignalBase.TListener"/>
	<c path="ash.signals.ListenerNode"><c path="ash.signals.SignalBase.TListener"/></c>
</t></nodes>
		<numListeners public="1" set="null"><x path="Int"/></numListeners>
		<tail public="1"><c path="ash.signals.ListenerNode"><c path="ash.signals.SignalBase.TListener"/></c></tail>
		<head public="1"><c path="ash.signals.ListenerNode"><c path="ash.signals.SignalBase.TListener"/></c></head>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* The base class for all the signal classes.</haxe_doc>
	</class>
	<class path="ash.signals.Signal0" params="" file="libSrc/Ash-Haxe/src/ash/signals/Signal0.hx">
		<extends path="ash.signals.SignalBase"><f a=""><x path="Void"/></f></extends>
		<dispatch public="1" set="method" line="16"><f a=""><x path="Void"/></f></dispatch>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Provides a fast signal for use where no parameters are dispatched with the signal.</haxe_doc>
	</class>
	<class path="ash.signals.Signal1" params="T1" file="libSrc/Ash-Haxe/src/ash/signals/Signal1.hx">
		<extends path="ash.signals.SignalBase"><f a="">
	<c path="ash.signals.Signal1.T1"/>
	<x path="Void"/>
</f></extends>
		<dispatch public="1" set="method" line="16"><f a="object">
	<c path="ash.signals.Signal1.T1"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Provides a fast signal for use where one parameter is dispatched with the signal.</haxe_doc>
	</class>
	<class path="ash.signals.Signal2" params="T1:T2" file="libSrc/Ash-Haxe/src/ash/signals/Signal2.hx">
		<extends path="ash.signals.SignalBase"><f a=":">
	<c path="ash.signals.Signal2.T1"/>
	<c path="ash.signals.Signal2.T2"/>
	<x path="Void"/>
</f></extends>
		<dispatch public="1" set="method" line="16"><f a="object1:object2">
	<c path="ash.signals.Signal2.T1"/>
	<c path="ash.signals.Signal2.T2"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Provides a fast signal for use where two parameters are dispatched with the signal.</haxe_doc>
	</class>
	<class path="ash.tools.ListIteratingSystem" params="TNode" file="libSrc/Ash-Haxe/src/ash/tools/ListIteratingSystem.hx">
		<extends path="ash.core.System"/>
		<update public="1" set="method" line="74" override="1"><f a="time">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<removeFromEngine public="1" set="method" line="61" override="1"><f a="engine">
	<c path="ash.core.Engine"/>
	<x path="Void"/>
</f></removeFromEngine>
		<addToEngine public="1" set="method" line="46" override="1"><f a="engine">
	<c path="ash.core.Engine"/>
	<x path="Void"/>
</f></addToEngine>
		<nodeRemovedFunction><f a="">
	<c path="ash.tools.ListIteratingSystem.TNode"/>
	<x path="Void"/>
</f></nodeRemovedFunction>
		<nodeAddedFunction><f a="">
	<c path="ash.tools.ListIteratingSystem.TNode"/>
	<x path="Void"/>
</f></nodeAddedFunction>
		<nodeUpdateFunction><f a=":">
	<c path="ash.tools.ListIteratingSystem.TNode"/>
	<x path="Float"/>
	<x path="Void"/>
</f></nodeUpdateFunction>
		<nodeClass><x path="Class"><c path="ash.tools.ListIteratingSystem.TNode"/></x></nodeClass>
		<nodeList><c path="ash.core.NodeList"><c path="ash.tools.ListIteratingSystem.TNode"/></c></nodeList>
		<new public="1" set="method" line="37"><f a="nodeClass:nodeUpdateFunction:?nodeAddedFunction:?nodeRemovedFunction">
	<x path="Class"><c path="ash.tools.ListIteratingSystem.TNode"/></x>
	<f a=":">
		<c path="ash.tools.ListIteratingSystem.TNode"/>
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="ash.tools.ListIteratingSystem.TNode"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="ash.tools.ListIteratingSystem.TNode"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* A useful class for systems which simply iterate over a set of nodes, performing the same action on each node. This
 * class removes the need for a lot of boilerplate code in such systems. Extend this class and pass the node type and
 * a node update method into the constructor. The node update method will be called once per node on the update cycle
 * with the node instance and the frame time as parameters. e.g.
 *
 * <code>package;
 * class MySystem extends ListIteratingSystem<MyNode>
 * {
 *     public function new()
 *     {
 *         super(MyNode, updateNode);
 *     }
 *
 *     private function updateNode(node:MyNode, time:Float):Void
 *     {
 *         // process the node here
 *     }
 * }
 * </code>]]></haxe_doc>
	</class>
	<class path="client.ClientMain" params="" file="src/client/ClientMain.hx">
		<main public="1" set="method" line="40" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</main>
		<onResize set="method" line="30"><f a="e">
	<c path="flash.events.Event"/>
	<x path="Void"/>
</f></onResize>
		<starling><t path="Starling"/></starling>
		<new public="1" set="method" line="19"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="starling.events.EventDispatcher" params="" file="lib/starling.swc@starling.events.EventDispatcher" extern="1">
		<addEventListener public="1" set="method"><f a="type:listener">
	<c path="String"/>
	<t path="flash.utils.Function"/>
	<x path="Void"/>
</f></addEventListener>
		<removeEventListener public="1" set="method"><f a="type:listener">
	<c path="String"/>
	<t path="flash.utils.Function"/>
	<x path="Void"/>
</f></removeEventListener>
		<removeEventListeners public="1" set="method"><f a="?type">
	<c path="String"/>
	<x path="Void"/>
</f></removeEventListeners>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="starling.events.Event"/>
	<x path="Void"/>
</f></dispatchEvent>
		<invokeEvent public="1" set="method"><f a="event">
	<c path="starling.events.Event"/>
	<x path="Bool"/>
</f></invokeEvent>
		<bubbleEvent public="1" set="method"><f a="event">
	<c path="starling.events.Event"/>
	<x path="Void"/>
</f></bubbleEvent>
		<dispatchEventWith public="1" set="method">
			<f a="type:?bubbles:?data">
				<c path="String"/>
				<x path="Bool"/>
				<t path="flash.utils.Object"/>
				<x path="Void"/>
			</f>
			<meta><m n=":defParam">
	<e>"bubbles"</e>
	<e>false</e>
</m></meta>
		</dispatchEventWith>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="starling.display.DisplayObject" params="" file="lib/starling.swc@starling.display.DisplayObject" extern="1">
		<extends path="starling.events.EventDispatcher"/>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<removeFromParent public="1" set="method">
			<f a="?dispose">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":defParam">
	<e>"dispose"</e>
	<e>false</e>
</m></meta>
		</removeFromParent>
		<getTransformationMatrix public="1" set="method"><f a="targetSpace:?resultMatrix">
	<c path="starling.display.DisplayObject"/>
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.Matrix"/>
</f></getTransformationMatrix>
		<getBounds public="1" set="method"><f a="targetSpace:?resultRect">
	<c path="starling.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></getBounds>
		<hitTest public="1" set="method">
			<f a="localPoint:?forTouch">
				<c path="flash.geom.Point"/>
				<x path="Bool"/>
				<c path="starling.display.DisplayObject"/>
			</f>
			<meta><m n=":defParam">
	<e>"forTouch"</e>
	<e>false</e>
</m></meta>
		</hitTest>
		<localToGlobal public="1" set="method"><f a="localPoint:?resultPoint">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></localToGlobal>
		<globalToLocal public="1" set="method"><f a="globalPoint:?resultPoint">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></globalToLocal>
		<render public="1" set="method"><f a="support:parentAlpha">
	<c path="starling.core.RenderSupport"/>
	<x path="Float"/>
	<x path="Void"/>
</f></render>
		<setParent public="1" set="method"><f a="value">
	<c path="starling.display.DisplayObjectContainer"/>
	<x path="Void"/>
</f></setParent>
		<base public="1" set="null"><c path="starling.display.DisplayObject"/></base>
		<blendMode public="1"><c path="String"/></blendMode>
		<hasVisibleArea public="1" set="null"><x path="Bool"/></hasVisibleArea>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<transformationMatrix public="1"><c path="flash.geom.Matrix"/></transformationMatrix>
		<root public="1" set="null"><c path="starling.display.DisplayObject"/></root>
		<scaleX public="1"><x path="Float"/></scaleX>
		<touchable public="1"><x path="Bool"/></touchable>
		<scaleY public="1"><x path="Float"/></scaleY>
		<useHandCursor public="1"><x path="Bool"/></useHandCursor>
		<stage public="1" set="null"><c path="starling.display.Stage"/></stage>
		<filter public="1"><c path="starling.filters.FragmentFilter"/></filter>
		<visible public="1"><x path="Bool"/></visible>
		<rotation public="1"><x path="Float"/></rotation>
		<bounds public="1" set="null"><c path="flash.geom.Rectangle"/></bounds>
		<width public="1"><x path="Float"/></width>
		<parent public="1" set="null"><c path="starling.display.DisplayObjectContainer"/></parent>
		<skewX public="1"><x path="Float"/></skewX>
		<pivotX public="1"><x path="Float"/></pivotX>
		<name public="1"><c path="String"/></name>
		<pivotY public="1"><x path="Float"/></pivotY>
		<skewY public="1"><x path="Float"/></skewY>
		<height public="1"><x path="Float"/></height>
		<alpha public="1"><x path="Float"/></alpha>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="starling.display.DisplayObjectContainer" params="" file="lib/starling.swc@starling.display.DisplayObjectContainer" extern="1">
		<extends path="starling.display.DisplayObject"/>
		<addChild public="1" set="method"><f a="child">
	<c path="starling.display.DisplayObject"/>
	<c path="starling.display.DisplayObject"/>
</f></addChild>
		<addChildAt public="1" set="method"><f a="child:index">
	<c path="starling.display.DisplayObject"/>
	<x path="Int"/>
	<c path="starling.display.DisplayObject"/>
</f></addChildAt>
		<removeChild public="1" set="method">
			<f a="child:?dispose">
				<c path="starling.display.DisplayObject"/>
				<x path="Bool"/>
				<c path="starling.display.DisplayObject"/>
			</f>
			<meta><m n=":defParam">
	<e>"dispose"</e>
	<e>false</e>
</m></meta>
		</removeChild>
		<removeChildAt public="1" set="method">
			<f a="index:?dispose">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="starling.display.DisplayObject"/>
			</f>
			<meta><m n=":defParam">
	<e>"dispose"</e>
	<e>false</e>
</m></meta>
		</removeChildAt>
		<removeChildren public="1" set="method">
			<f a="?beginIndex:?endIndex:?dispose">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":defParam">
					<e>"dispose"</e>
					<e>false</e>
				</m>
				<m n=":defParam">
					<e>"endIndex"</e>
					<e>-1</e>
				</m>
				<m n=":defParam">
					<e>"beginIndex"</e>
					<e>0</e>
				</m>
			</meta>
		</removeChildren>
		<getChildAt public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="starling.display.DisplayObject"/>
</f></getChildAt>
		<getChildByName public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="starling.display.DisplayObject"/>
</f></getChildByName>
		<getChildIndex public="1" set="method"><f a="child">
	<c path="starling.display.DisplayObject"/>
	<x path="Int"/>
</f></getChildIndex>
		<setChildIndex public="1" set="method"><f a="child:index">
	<c path="starling.display.DisplayObject"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setChildIndex>
		<swapChildren public="1" set="method"><f a="child1:child2">
	<c path="starling.display.DisplayObject"/>
	<c path="starling.display.DisplayObject"/>
	<x path="Void"/>
</f></swapChildren>
		<swapChildrenAt public="1" set="method"><f a="index1:index2">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swapChildrenAt>
		<sortChildren public="1" set="method"><f a="compareFunction">
	<t path="flash.utils.Function"/>
	<x path="Void"/>
</f></sortChildren>
		<contains public="1" set="method"><f a="child">
	<c path="starling.display.DisplayObject"/>
	<x path="Bool"/>
</f></contains>
		<broadcastEvent public="1" set="method"><f a="event">
	<c path="starling.events.Event"/>
	<x path="Void"/>
</f></broadcastEvent>
		<broadcastEventWith public="1" set="method"><f a="type:?data">
	<c path="String"/>
	<t path="flash.utils.Object"/>
	<x path="Void"/>
</f></broadcastEventWith>
		<numChildren public="1" set="null"><x path="Int"/></numChildren>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="starling.display.Sprite" params="" file="lib/starling.swc@starling.display.Sprite" extern="1">
		<extends path="starling.display.DisplayObjectContainer"/>
		<flatten public="1" set="method"><f a=""><x path="Void"/></f></flatten>
		<unflatten public="1" set="method"><f a=""><x path="Void"/></f></unflatten>
		<getClipRect public="1" set="method"><f a="targetSpace:?resultRect">
	<c path="starling.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></getClipRect>
		<clipRect public="1"><c path="flash.geom.Rectangle"/></clipRect>
		<isFlattened public="1" set="null"><x path="Bool"/></isFlattened>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="client.ClientStage" params="" file="src/client/ClientStage.hx">
		<extends path="starling.display.Sprite"/>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="client.Game" params="" file="src/client/Game.hx">
		<start set="method" line="34"><f a=""><x path="Void"/></f></start>
		<prepare set="method" line="19"><f a=""><x path="Void"/></f></prepare>
		<creator><c path="EntityCreator"/></creator>
		<keyboardInput><c path="KeyboardInput"/></keyboardInput>
		<mouseInput><c path="MouseInput"/></mouseInput>
		<graphics><t path="Graphics"/></graphics>
		<engine><t path="Engine"/></engine>
		<container><t path="DisplayObjectContainer"/></container>
		<new public="1" set="method" line="13"><f a="container:width:height">
	<t path="DisplayObjectContainer"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="starling.animation.IAnimatable" params="" file="lib/starling.swc@starling.animation.IAnimatable" extern="1" interface="1"><advanceTime public="1" set="method"><f a="time">
	<x path="Float"/>
	<x path="Void"/>
</f></advanceTime></class>
	<class path="client._Game.StarlingTickProvider" params="" file="src/client/Game.hx" private="1" module="client.Game">
		<implements path="starling.animation.IAnimatable"/>
		<advanceTime public="1" set="method" line="50"><f a="time">
	<x path="Float"/>
	<x path="Void"/>
</f></advanceTime>
		<onTick public="1"><t path="Signal1"><x path="Float"/></t></onTick>
		<new public="1" set="method" line="46"><f a=""><x path="Void"/></f></new>
	</class>
	<typedef path="com.eclecticdesignstudio.motion.Actuate" params="" file="libSrc/actuate/com/eclecticdesignstudio/motion/Actuate.hx"><c path="motion.Actuate"/></typedef>
	<class path="components.Display" params="" file="src/components/Display.hx">
		<depth public="1"><x path="Float"/></depth>
		<offset public="1"><t path="Mat23"/></offset>
		<displayObject public="1" set="null"><t path="DisplayObject"/></displayObject>
		<new public="1" set="method" line="10"><f a="dpo:offset">
	<t path="DisplayObject"/>
	<t path="Mat23"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="components.Grid" params="" file="src/components/Grid.hx">
		<grid public="1"><t path="Array2"><t path="Tile"/></t></grid>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="components.Tile" params="" file="src/components/Tile.hx">
		<stack public="1"><c path="Array"><x path="Int"/></c></stack>
		<pos public="1"><t path="Vec2"/></pos>
		<new public="1" set="method" line="9"><f a="pos">
	<t path="Vec2"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="components.Transform" params="" file="src/components/Transform.hx">
		<transform public="1"><t path="Mat23"/></transform>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="de.polygonal.core.fmt.ASCII" params="" file="libSrc/core/src/de/polygonal/core/fmt/ASCII.hx">
		<isASCII public="1" get="inline" set="null" line="44" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[Returns true if <i>x</i> is an ASCII character.]]></haxe_doc>
		</isASCII>
		<isDigit public="1" get="inline" set="null" line="50" static="1"><f a="x">
	<x path="Int"/>
	<x path="Bool"/>
</f></isDigit>
		<isWhite public="1" get="inline" set="null" line="56" static="1"><f a="x">
	<x path="Int"/>
	<x path="Bool"/>
</f></isWhite>
		<isPrintable public="1" get="inline" set="null" line="62" static="1"><f a="x">
	<x path="Int"/>
	<x path="Bool"/>
</f></isPrintable>
		<isUpperCaseAlphabetic public="1" get="inline" set="null" line="68" static="1"><f a="x">
	<x path="Int"/>
	<x path="Bool"/>
</f></isUpperCaseAlphabetic>
		<isLowerCaseAlphabetic public="1" get="inline" set="null" line="74" static="1"><f a="x">
	<x path="Int"/>
	<x path="Bool"/>
</f></isLowerCaseAlphabetic>
		<isAlphabetic public="1" get="inline" set="null" line="80" static="1"><f a="x">
	<x path="Int"/>
	<x path="Bool"/>
</f></isAlphabetic>
		<isAlphaNumeric public="1" get="inline" set="null" line="86" static="1"><f a="x">
	<x path="Int"/>
	<x path="Bool"/>
</f></isAlphaNumeric>
		<BACKSPACE public="1" get="inline" set="null" line="91" static="1"><x path="Int"/></BACKSPACE>
		<TAB public="1" get="inline" set="null" line="92" static="1">
			<x path="Int"/>
			<haxe_doc>"\t"</haxe_doc>
		</TAB>
		<NEWLINE public="1" get="inline" set="null" line="93" static="1">
			<x path="Int"/>
			<haxe_doc>"\n"</haxe_doc>
		</NEWLINE>
		<FORMFEED public="1" get="inline" set="null" line="94" static="1">
			<x path="Int"/>
			<haxe_doc>"\f"</haxe_doc>
		</FORMFEED>
		<CARRIAGERETURN public="1" get="inline" set="null" line="95" static="1">
			<x path="Int"/>
			<haxe_doc>"\r"</haxe_doc>
		</CARRIAGERETURN>
		<SPACE public="1" get="inline" set="null" line="96" static="1">
			<x path="Int"/>
			<haxe_doc>' '</haxe_doc>
		</SPACE>
		<EXCLAM public="1" get="inline" set="null" line="97" static="1">
			<x path="Int"/>
			<haxe_doc>!</haxe_doc>
		</EXCLAM>
		<QUOTEDBL public="1" get="inline" set="null" line="98" static="1">
			<x path="Int"/>
			<haxe_doc>"</haxe_doc>
		</QUOTEDBL>
		<NUMBERSIGN public="1" get="inline" set="null" line="99" static="1">
			<x path="Int"/>
			<haxe_doc>#</haxe_doc>
		</NUMBERSIGN>
		<DOLLAR public="1" get="inline" set="null" line="100" static="1">
			<x path="Int"/>
			<haxe_doc>$</haxe_doc>
		</DOLLAR>
		<PERCENT public="1" get="inline" set="null" line="101" static="1">
			<x path="Int"/>
			<haxe_doc>%</haxe_doc>
		</PERCENT>
		<AMPERSAND public="1" get="inline" set="null" line="102" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[&]]></haxe_doc>
		</AMPERSAND>
		<QUOTESINGLE public="1" get="inline" set="null" line="103" static="1">
			<x path="Int"/>
			<haxe_doc>'</haxe_doc>
		</QUOTESINGLE>
		<PARENLEFT public="1" get="inline" set="null" line="104" static="1">
			<x path="Int"/>
			<haxe_doc>(</haxe_doc>
		</PARENLEFT>
		<PARENRIGHT public="1" get="inline" set="null" line="105" static="1">
			<x path="Int"/>
			<haxe_doc>)</haxe_doc>
		</PARENRIGHT>
		<ASTERISK public="1" get="inline" set="null" line="106" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[&#42]]></haxe_doc>
		</ASTERISK>
		<PLUS public="1" get="inline" set="null" line="107" static="1">
			<x path="Int"/>
			<haxe_doc>+</haxe_doc>
		</PLUS>
		<COMMA public="1" get="inline" set="null" line="108" static="1">
			<x path="Int"/>
			<haxe_doc>,</haxe_doc>
		</COMMA>
		<HYPHEN public="1" get="inline" set="null" line="109" static="1">
			<x path="Int"/>
			<haxe_doc>-</haxe_doc>
		</HYPHEN>
		<PERIOD public="1" get="inline" set="null" line="110" static="1">
			<x path="Int"/>
			<haxe_doc>.</haxe_doc>
		</PERIOD>
		<SLASH public="1" get="inline" set="null" line="111" static="1">
			<x path="Int"/>
			<haxe_doc>/</haxe_doc>
		</SLASH>
		<ZERO public="1" get="inline" set="null" line="113" static="1">
			<x path="Int"/>
			<haxe_doc>0</haxe_doc>
		</ZERO>
		<ONE public="1" get="inline" set="null" line="114" static="1">
			<x path="Int"/>
			<haxe_doc>1</haxe_doc>
		</ONE>
		<TWO public="1" get="inline" set="null" line="115" static="1">
			<x path="Int"/>
			<haxe_doc>2</haxe_doc>
		</TWO>
		<THREE public="1" get="inline" set="null" line="116" static="1">
			<x path="Int"/>
			<haxe_doc>3</haxe_doc>
		</THREE>
		<FOUR public="1" get="inline" set="null" line="117" static="1">
			<x path="Int"/>
			<haxe_doc>4</haxe_doc>
		</FOUR>
		<FIVE public="1" get="inline" set="null" line="118" static="1">
			<x path="Int"/>
			<haxe_doc>5</haxe_doc>
		</FIVE>
		<SIX public="1" get="inline" set="null" line="119" static="1">
			<x path="Int"/>
			<haxe_doc>6</haxe_doc>
		</SIX>
		<SEVEN public="1" get="inline" set="null" line="120" static="1">
			<x path="Int"/>
			<haxe_doc>7</haxe_doc>
		</SEVEN>
		<EIGHT public="1" get="inline" set="null" line="121" static="1">
			<x path="Int"/>
			<haxe_doc>8</haxe_doc>
		</EIGHT>
		<NINE public="1" get="inline" set="null" line="122" static="1">
			<x path="Int"/>
			<haxe_doc>9</haxe_doc>
		</NINE>
		<COLON public="1" get="inline" set="null" line="124" static="1">
			<x path="Int"/>
			<haxe_doc>:</haxe_doc>
		</COLON>
		<SEMICOLON public="1" get="inline" set="null" line="125" static="1">
			<x path="Int"/>
			<haxe_doc>;</haxe_doc>
		</SEMICOLON>
		<LESS public="1" get="inline" set="null" line="126" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[<]]></haxe_doc>
		</LESS>
		<EQUAL public="1" get="inline" set="null" line="127" static="1">
			<x path="Int"/>
			<haxe_doc>=</haxe_doc>
		</EQUAL>
		<GREATER public="1" get="inline" set="null" line="128" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[>]]></haxe_doc>
		</GREATER>
		<QUESTION public="1" get="inline" set="null" line="129" static="1">
			<x path="Int"/>
			<haxe_doc>?</haxe_doc>
		</QUESTION>
		<AT public="1" get="inline" set="null" line="130" static="1">
			<x path="Int"/>
			<haxe_doc>@</haxe_doc>
		</AT>
		<A public="1" get="inline" set="null" line="132" static="1">
			<x path="Int"/>
			<haxe_doc>A</haxe_doc>
		</A>
		<B public="1" get="inline" set="null" line="133" static="1">
			<x path="Int"/>
			<haxe_doc>B</haxe_doc>
		</B>
		<C public="1" get="inline" set="null" line="134" static="1">
			<x path="Int"/>
			<haxe_doc>C</haxe_doc>
		</C>
		<D public="1" get="inline" set="null" line="135" static="1">
			<x path="Int"/>
			<haxe_doc>D</haxe_doc>
		</D>
		<E public="1" get="inline" set="null" line="136" static="1">
			<x path="Int"/>
			<haxe_doc>E</haxe_doc>
		</E>
		<F public="1" get="inline" set="null" line="137" static="1">
			<x path="Int"/>
			<haxe_doc>F</haxe_doc>
		</F>
		<G public="1" get="inline" set="null" line="138" static="1">
			<x path="Int"/>
			<haxe_doc>G</haxe_doc>
		</G>
		<H public="1" get="inline" set="null" line="139" static="1">
			<x path="Int"/>
			<haxe_doc>H</haxe_doc>
		</H>
		<I public="1" get="inline" set="null" line="140" static="1">
			<x path="Int"/>
			<haxe_doc>I</haxe_doc>
		</I>
		<J public="1" get="inline" set="null" line="141" static="1">
			<x path="Int"/>
			<haxe_doc>J</haxe_doc>
		</J>
		<K public="1" get="inline" set="null" line="142" static="1">
			<x path="Int"/>
			<haxe_doc>K</haxe_doc>
		</K>
		<L public="1" get="inline" set="null" line="143" static="1">
			<x path="Int"/>
			<haxe_doc>L</haxe_doc>
		</L>
		<M public="1" get="inline" set="null" line="144" static="1">
			<x path="Int"/>
			<haxe_doc>M</haxe_doc>
		</M>
		<N public="1" get="inline" set="null" line="145" static="1">
			<x path="Int"/>
			<haxe_doc>N</haxe_doc>
		</N>
		<O public="1" get="inline" set="null" line="146" static="1">
			<x path="Int"/>
			<haxe_doc>O</haxe_doc>
		</O>
		<P public="1" get="inline" set="null" line="147" static="1">
			<x path="Int"/>
			<haxe_doc>P</haxe_doc>
		</P>
		<Q public="1" get="inline" set="null" line="148" static="1">
			<x path="Int"/>
			<haxe_doc>Q</haxe_doc>
		</Q>
		<R public="1" get="inline" set="null" line="149" static="1">
			<x path="Int"/>
			<haxe_doc>R</haxe_doc>
		</R>
		<S public="1" get="inline" set="null" line="150" static="1">
			<x path="Int"/>
			<haxe_doc>S</haxe_doc>
		</S>
		<T public="1" get="inline" set="null" line="151" static="1">
			<x path="Int"/>
			<haxe_doc>T</haxe_doc>
		</T>
		<U public="1" get="inline" set="null" line="152" static="1">
			<x path="Int"/>
			<haxe_doc>U</haxe_doc>
		</U>
		<V public="1" get="inline" set="null" line="153" static="1">
			<x path="Int"/>
			<haxe_doc>V</haxe_doc>
		</V>
		<W public="1" get="inline" set="null" line="154" static="1">
			<x path="Int"/>
			<haxe_doc>W</haxe_doc>
		</W>
		<X public="1" get="inline" set="null" line="155" static="1">
			<x path="Int"/>
			<haxe_doc>X</haxe_doc>
		</X>
		<Y public="1" get="inline" set="null" line="156" static="1">
			<x path="Int"/>
			<haxe_doc>Y</haxe_doc>
		</Y>
		<Z public="1" get="inline" set="null" line="157" static="1">
			<x path="Int"/>
			<haxe_doc>Z</haxe_doc>
		</Z>
		<BRACKETLEFT public="1" get="inline" set="null" line="159" static="1">
			<x path="Int"/>
			<haxe_doc>[</haxe_doc>
		</BRACKETLEFT>
		<BACKSLASH public="1" get="inline" set="null" line="160" static="1">
			<x path="Int"/>
			<haxe_doc>\</haxe_doc>
		</BACKSLASH>
		<BRACKETRIGHT public="1" get="inline" set="null" line="161" static="1">
			<x path="Int"/>
			<haxe_doc>]</haxe_doc>
		</BRACKETRIGHT>
		<CIRCUM public="1" get="inline" set="null" line="162" static="1">
			<x path="Int"/>
			<haxe_doc>^</haxe_doc>
		</CIRCUM>
		<UNDERSCORE public="1" get="inline" set="null" line="163" static="1">
			<x path="Int"/>
			<haxe_doc>_</haxe_doc>
		</UNDERSCORE>
		<GRAVE public="1" get="inline" set="null" line="164" static="1">
			<x path="Int"/>
			<haxe_doc>`</haxe_doc>
		</GRAVE>
		<a public="1" get="inline" set="null" line="166" static="1">
			<x path="Int"/>
			<haxe_doc>a</haxe_doc>
		</a>
		<b public="1" get="inline" set="null" line="167" static="1">
			<x path="Int"/>
			<haxe_doc>b</haxe_doc>
		</b>
		<c public="1" get="inline" set="null" line="168" static="1">
			<x path="Int"/>
			<haxe_doc>c</haxe_doc>
		</c>
		<d public="1" get="inline" set="null" line="169" static="1">
			<x path="Int"/>
			<haxe_doc>d</haxe_doc>
		</d>
		<e public="1" get="inline" set="null" line="170" static="1">
			<x path="Int"/>
			<haxe_doc>e</haxe_doc>
		</e>
		<f public="1" get="inline" set="null" line="171" static="1">
			<x path="Int"/>
			<haxe_doc>f</haxe_doc>
		</f>
		<g public="1" get="inline" set="null" line="172" static="1">
			<x path="Int"/>
			<haxe_doc>g</haxe_doc>
		</g>
		<h public="1" get="inline" set="null" line="173" static="1">
			<x path="Int"/>
			<haxe_doc>h</haxe_doc>
		</h>
		<i public="1" get="inline" set="null" line="174" static="1">
			<x path="Int"/>
			<haxe_doc>i</haxe_doc>
		</i>
		<j public="1" get="inline" set="null" line="175" static="1">
			<x path="Int"/>
			<haxe_doc>j</haxe_doc>
		</j>
		<k public="1" get="inline" set="null" line="176" static="1">
			<x path="Int"/>
			<haxe_doc>k</haxe_doc>
		</k>
		<l public="1" get="inline" set="null" line="177" static="1">
			<x path="Int"/>
			<haxe_doc>l</haxe_doc>
		</l>
		<m public="1" get="inline" set="null" line="178" static="1">
			<x path="Int"/>
			<haxe_doc>m</haxe_doc>
		</m>
		<n public="1" get="inline" set="null" line="179" static="1">
			<x path="Int"/>
			<haxe_doc>n</haxe_doc>
		</n>
		<o public="1" get="inline" set="null" line="180" static="1">
			<x path="Int"/>
			<haxe_doc>o</haxe_doc>
		</o>
		<p public="1" get="inline" set="null" line="181" static="1">
			<x path="Int"/>
			<haxe_doc>p</haxe_doc>
		</p>
		<q public="1" get="inline" set="null" line="182" static="1">
			<x path="Int"/>
			<haxe_doc>q</haxe_doc>
		</q>
		<r public="1" get="inline" set="null" line="183" static="1">
			<x path="Int"/>
			<haxe_doc>r</haxe_doc>
		</r>
		<s public="1" get="inline" set="null" line="184" static="1">
			<x path="Int"/>
			<haxe_doc>s</haxe_doc>
		</s>
		<t public="1" get="inline" set="null" line="185" static="1">
			<x path="Int"/>
			<haxe_doc>t</haxe_doc>
		</t>
		<u public="1" get="inline" set="null" line="186" static="1">
			<x path="Int"/>
			<haxe_doc>u</haxe_doc>
		</u>
		<v public="1" get="inline" set="null" line="187" static="1">
			<x path="Int"/>
			<haxe_doc>v</haxe_doc>
		</v>
		<w public="1" get="inline" set="null" line="188" static="1">
			<x path="Int"/>
			<haxe_doc>w</haxe_doc>
		</w>
		<x public="1" get="inline" set="null" line="189" static="1">
			<x path="Int"/>
			<haxe_doc>x</haxe_doc>
		</x>
		<y public="1" get="inline" set="null" line="190" static="1">
			<x path="Int"/>
			<haxe_doc>y</haxe_doc>
		</y>
		<z public="1" get="inline" set="null" line="191" static="1">
			<x path="Int"/>
			<haxe_doc>z</haxe_doc>
		</z>
		<BRACELEFT public="1" get="inline" set="null" line="193" static="1">
			<x path="Int"/>
			<haxe_doc>{</haxe_doc>
		</BRACELEFT>
		<BAR public="1" get="inline" set="null" line="194" static="1">
			<x path="Int"/>
			<haxe_doc>|</haxe_doc>
		</BAR>
		<BRACERIGTH public="1" get="inline" set="null" line="195" static="1">
			<x path="Int"/>
			<haxe_doc>}</haxe_doc>
		</BRACERIGTH>
		<TILDE public="1" get="inline" set="null" line="196" static="1">
			<x path="Int"/>
			<haxe_doc>~</haxe_doc>
		</TILDE>
		<haxe_doc><![CDATA[* <p>US ASCII Character Set, ANSI X3.4-1986 (ISO 646 International Reference Version)<p>
 * <ul>
 * <li>Codes 0 through 31 and 127 are unprintable control characters.</li>
 * <li>Code 32 is a non-printing spacing character.</li>
 * <li>Codes 33 through 126 are printable graphic characters.</li>
 * <li>Unprintable control characters except newline are omitted.</li>
 * </ul>]]></haxe_doc>
	</class>
	<class path="haxe.ds.IntMap" params="T" file="/usr/lib/haxe/std/flash/_std/haxe/ds/IntMap.hx">
		<get public="1" set="method" line="36">
			<f a="key">
				<x path="Int"/>
				<t path="Null"><c path="haxe.ds.IntMap.T"/></t>
			</f>
			<haxe_doc>Get a value for the given key.</haxe_doc>
		</get>
		<set public="1" set="method" line="32">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set a value for the given key.</haxe_doc>
		</set>
		<h><c path="flash.utils.Dictionary"/></h>
		<new public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty hashtable.</haxe_doc>
		</new>
		<haxe_doc>Hashtable over a set of elements, using [Int] as keys.
	On Flash and Javascript, the underlying structure is an Object.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="flash.utils.Dictionary" params="" file="/usr/lib/haxe/std/flash/utils/Dictionary.hx" extern="1">
		<new public="1" set="method"><f a="?weakKeys">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="de.polygonal.core.fmt._Sprintf.FormatDataType" params="" file="libSrc/core/src/de/polygonal/core/fmt/Sprintf.hx" private="1" module="de.polygonal.core.fmt.Sprintf">
		<FmtString/>
		<FmtPointer/>
		<FmtNothing/>
		<FmtInteger a="integerType"><e path="de.polygonal.core.fmt._Sprintf.IntegerType"/></FmtInteger>
		<FmtFloat a="floatType"><e path="de.polygonal.core.fmt._Sprintf.FloatType"/></FmtFloat>
	</enum>
	<enum path="de.polygonal.core.fmt._Sprintf.IntegerType" params="" file="libSrc/core/src/de/polygonal/core/fmt/Sprintf.hx" private="1" module="de.polygonal.core.fmt.Sprintf">
		<IUnsignedDecimal/>
		<ISignedDecimal/>
		<IOctal/>
		<IHex/>
		<ICharacter/>
		<IBin/>
	</enum>
	<enum path="de.polygonal.core.fmt._Sprintf.FloatType" params="" file="libSrc/core/src/de/polygonal/core/fmt/Sprintf.hx" private="1" module="de.polygonal.core.fmt.Sprintf">
		<FScientific/>
		<FNormal/>
		<FNatural/>
	</enum>
	<class path="de.polygonal.core.fmt.Sprintf" params="" file="libSrc/core/src/de/polygonal/core/fmt/Sprintf.hx">
		<dataTypeHash line="108" static="1"><c path="haxe.ds.IntMap"><e path="de.polygonal.core.fmt._Sprintf.FormatDataType"/></c></dataTypeHash>
		<makeDataTypeHash set="method" line="110" static="1"><f a=""><c path="haxe.ds.IntMap"><e path="de.polygonal.core.fmt._Sprintf.FormatDataType"/></c></f></makeDataTypeHash>
		<_instance line="136" static="1"><c path="de.polygonal.core.fmt.Sprintf"/></_instance>
		<tokenize public="1" set="method" line="571" static="1"><f a="fmt">
	<c path="String"/>
	<c path="Array"><e path="de.polygonal.core.fmt._Sprintf.FormatToken"/></c>
</f></tokenize>
		<_full_runtime_format public="1" get="inline" set="null" line="763" static="1"><f a="fmt:args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
</f></_full_runtime_format>
		<padNumber get="inline" set="null" line="1135"><f a="x:n:flags:width">
	<c path="String"/>
	<x path="Float"/>
	<x path="haxe.EnumFlags"><e path="de.polygonal.core.fmt._Sprintf.FormatFlags"/></x>
	<x path="Int"/>
	<c path="String"/>
</f></padNumber>
		<formatCharacter public="1" get="inline" set="null" line="1120"><f a="x:args">
	<x path="Int"/>
	<t path="de.polygonal.core.fmt._Sprintf.FormatArgs"/>
	<c path="String"/>
</f></formatCharacter>
		<formatNormalFloat public="1" get="inline" set="null" line="1062"><f a="value:args">
	<x path="Float"/>
	<t path="de.polygonal.core.fmt._Sprintf.FormatArgs"/>
	<c path="String"/>
</f></formatNormalFloat>
		<formatString public="1" get="inline" set="null" line="1046"><f a="x:args">
	<c path="String"/>
	<t path="de.polygonal.core.fmt._Sprintf.FormatArgs"/>
	<c path="String"/>
</f></formatString>
		<formatSignedDecimal public="1" get="inline" set="null" line="1003"><f a="value:args">
	<x path="Int"/>
	<t path="de.polygonal.core.fmt._Sprintf.FormatArgs"/>
	<c path="String"/>
</f></formatSignedDecimal>
		<formatScientific public="1" get="inline" set="null" line="958"><f a="value:args">
	<x path="Float"/>
	<t path="de.polygonal.core.fmt._Sprintf.FormatArgs"/>
	<c path="String"/>
</f></formatScientific>
		<formatNaturalFloat public="1" get="inline" set="null" line="937"><f a="value:args">
	<x path="Float"/>
	<t path="de.polygonal.core.fmt._Sprintf.FormatArgs"/>
	<c path="String"/>
</f></formatNaturalFloat>
		<formatUnsignedDecimal public="1" get="inline" set="null" line="916"><f a="value:args">
	<x path="Int"/>
	<t path="de.polygonal.core.fmt._Sprintf.FormatArgs"/>
	<c path="String"/>
</f></formatUnsignedDecimal>
		<formatHex public="1" get="inline" set="null" line="886"><f a="value:args">
	<x path="Int"/>
	<t path="de.polygonal.core.fmt._Sprintf.FormatArgs"/>
	<c path="String"/>
</f></formatHex>
		<formatOctal public="1" get="inline" set="null" line="851"><f a="value:args">
	<x path="Int"/>
	<t path="de.polygonal.core.fmt._Sprintf.FormatArgs"/>
	<c path="String"/>
</f></formatOctal>
		<formatBin public="1" get="inline" set="null" line="814"><f a="value:args">
	<x path="Int"/>
	<t path="de.polygonal.core.fmt._Sprintf.FormatArgs"/>
	<c path="String"/>
</f></formatBin>
		<_format set="method" line="770"><f a="fmt:args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
</f></_format>
		<formatStringFuncHash><c path="haxe.ds.IntMap"><f a=":">
	<c path="String"/>
	<t path="de.polygonal.core.fmt._Sprintf.FormatArgs"/>
	<c path="String"/>
</f></c></formatStringFuncHash>
		<formatFloatFuncHash><c path="haxe.ds.IntMap"><f a=":">
	<x path="Float"/>
	<t path="de.polygonal.core.fmt._Sprintf.FormatArgs"/>
	<c path="String"/>
</f></c></formatFloatFuncHash>
		<formatIntFuncHash><c path="haxe.ds.IntMap"><f a=":">
	<x path="Int"/>
	<t path="de.polygonal.core.fmt._Sprintf.FormatArgs"/>
	<c path="String"/>
</f></c></formatIntFuncHash>
		<formatHash><c path="haxe.ds.IntMap"><d/></c></formatHash>
		<new set="method" line="168"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* <p>A C sprintf implementation.</p>
 * <p>See <a href="http://www.cplusplus.com/reference/clibrary/cstdio/printf/" target="_blank">http://www.cplusplus.com/reference/clibrary/cstdio/printf/</a> for a complete reference.</p>
 *
 * <h1><b>New Features</b></h1>
 * <h1>Variable Number of Arguments</h1>
 *
 * <p>If there is more than one argument (or if the only argument passed is not an array), Sprintf will use the arguments as is.</p>
 * <p><pre class="prettyprint">
 * Sprintf.format("This is %s", "acceptable");
 * Sprintf.format("This is also %s", ["acceptable"]);</pre></p>
 *
 * <h1>Numbered Parameters</h1>
 * <p>Arguments can now be accessed by number via the following format: `%[argnumber$][flags][width][.precision][length]specifier`</p>
 * <p><b>Note: The number 1 refers to the first argument, not 0</b></p>
 * <p><pre class="prettyprint">
 * Sprintf.format("%s is %d years old, and his name is %1$s", ["Joe", 32]);</pre></p>
 *
 * <h1>Named Parameters</h1>
 * <p>Arguments can now be specified as named properties of an object using the following format: `%(name)`. Named arguments will always refer to the first parameter.</p>
 * <p>Named Parameters can even be used in conjunction with other argument types:</p>
 * <p><pre class="prettyprint">
 * Sprintf.format("%(name) is %(age), and wants to be a %2$s", {name:"Joe", age:32}, "Programmer");</pre></p>
 * 
 * <h1>Compile-Time Checks</h1>
 * <p>If the format string is inline, several checks can be done at compile time, and they can issue an error or warning during the compile.</p>
 * <h1>Format String Verification</h1>
 * <p>An incorrect format string will throw an error:</p>
 * <p><pre class="prettyprint">
 * Sprintf.format("%m", 3); // Compile-time error: invalid format specifier</pre></p>
 *
 * <h1>Not Enough Arguments</h1>
 * <p>Compilation will fail if there are not enough arguments passed for the number of specifiers given</p>
 * <p><pre class="prettyprint">
 * Sprintf.format("%s %s %s", "bob", "joe"); // Compile-time error: Not enough arguments</pre></p>
 *
 * <h1>Width and Precision</h1>
 * <p>Widths and precisions are checked at compile time when possible</p>
 * <p><pre class="prettyprint">
 * Sprintf.format("Age/3 = %.*f", 10.1, 2); // Compile-time error: precision must be an integer
 * Sprintf.format("Age/3 = %*f", 10.1, 4); // Compile-time error: width must be an integer</pre></p>
 *
 * <h1>Number Types</h1>
 * <p>The value's type is checked whenever possible</p>
 * <p><pre class="prettyprint">
 * Sprintf.format("%f", "5"); // Compile-time error: the value must be a number
 * Sprintf.format("%d", 4.1); // Complile-time error: the value must be an integer</pre></p>
 *
 * <h1>Flag Mis-matches (Warning)</h1>
 * <p>A compiler warning will be issued for flag combinations that don't make sense</p>
 * <p><pre class="prettyprint">
 * Sprintf.format("% +f", 3.1);
 * // Compile-time warning: ` ' flag ignored with '+' flag in printf format</pre></p>
 *
 * <h1>Unused Arguments (Warning)</h1>
 * <p>If compiled with the verbose flag, a compiler warning will be issued for arguments that are left unused</p>
 * <p><pre class="prettyprint">
 * Sprintf.format("%s", "first", "second"); // Compile-time warning: Unused parameters</pre></p>]]></haxe_doc>
	</class>
	<typedef path="de.polygonal.core.fmt._Sprintf.FormatArgs" params="" file="libSrc/core/src/de/polygonal/core/fmt/Sprintf.hx" private="1" module="de.polygonal.core.fmt.Sprintf"><a>
	<width><t path="Null"><x path="Int"/></t></width>
	<precision><t path="Null"><x path="Int"/></t></precision>
	<pos><x path="Int"/></pos>
	<flags><x path="haxe.EnumFlags"><e path="de.polygonal.core.fmt._Sprintf.FormatFlags"/></x></flags>
</a></typedef>
	<enum path="de.polygonal.core.fmt._Sprintf.FormatFlags" params="" file="libSrc/core/src/de/polygonal/core/fmt/Sprintf.hx" private="1" module="de.polygonal.core.fmt.Sprintf">
		<Zero/>
		<UpperCase/>
		<Space/>
		<Sharp/>
		<Plus/>
		<Minus/>
		<Lengthl/>
		<LengthL/>
		<LengthH/>
	</enum>
	<enum path="de.polygonal.core.fmt._Sprintf.FormatToken" params="" file="libSrc/core/src/de/polygonal/core/fmt/Sprintf.hx" private="1" module="de.polygonal.core.fmt.Sprintf">
		<Unknown a="str:pos">
			<c path="String"/>
			<x path="Int"/>
		</Unknown>
		<Tag a="type:args">
			<e path="de.polygonal.core.fmt._Sprintf.FormatDataType"/>
			<t path="de.polygonal.core.fmt._Sprintf.FormatArgs"/>
		</Tag>
		<Property a="name"><c path="String"/></Property>
		<BareString a="str"><c path="String"/></BareString>
	</enum>
	<class path="de.polygonal.core.math.Limits" params="" file="libSrc/core/src/de/polygonal/core/math/Limits.hx">
		<INT8_MIN public="1" get="inline" set="null" line="40" static="1">
			<x path="Int"/>
			<haxe_doc>* Min value, signed byte.</haxe_doc>
		</INT8_MIN>
		<INT8_MAX public="1" get="inline" set="null" line="45" static="1">
			<x path="Int"/>
			<haxe_doc>* Max value, signed byte.</haxe_doc>
		</INT8_MAX>
		<UINT8_MAX public="1" get="inline" set="null" line="50" static="1">
			<x path="Int"/>
			<haxe_doc>* Max value, unsigned byte.</haxe_doc>
		</UINT8_MAX>
		<INT16_MIN public="1" get="inline" set="null" line="55" static="1">
			<x path="Int"/>
			<haxe_doc>* Min value, signed short.</haxe_doc>
		</INT16_MIN>
		<INT16_MAX public="1" get="inline" set="null" line="60" static="1">
			<x path="Int"/>
			<haxe_doc>* Max value, signed short.</haxe_doc>
		</INT16_MAX>
		<UINT16_MAX public="1" get="inline" set="null" line="65" static="1">
			<x path="Int"/>
			<haxe_doc>* Max value, unsigned short.</haxe_doc>
		</UINT16_MAX>
		<INT32_MIN public="1" get="inline" set="null" line="75" static="1">
			<x path="Int"/>
			<haxe_doc>* Min value, signed integer.</haxe_doc>
		</INT32_MIN>
		<INT32_MAX public="1" get="inline" set="null" line="81" static="1">
			<x path="Int"/>
			<haxe_doc>* Max value, signed integer.</haxe_doc>
		</INT32_MAX>
		<UINT32_MAX public="1" get="inline" set="null" line="86" static="1">
			<x path="Int"/>
			<haxe_doc>* Max value, unsigned integer.</haxe_doc>
		</UINT32_MAX>
		<INT_BITS public="1" get="inline" set="null" line="91" static="1">
			<x path="Int"/>
			<haxe_doc>* Number of bits using for representing integers.</haxe_doc>
		</INT_BITS>
		<FLOAT_MAX public="1" get="inline" set="null" line="96" static="1">
			<x path="Float"/>
			<haxe_doc>* The largest representable number (single-precision IEEE-754).</haxe_doc>
		</FLOAT_MAX>
		<FLOAT_MIN public="1" get="inline" set="null" line="101" static="1">
			<x path="Float"/>
			<haxe_doc>* The smallest representable number (single-precision IEEE-754).</haxe_doc>
		</FLOAT_MIN>
		<DOUBLE_MAX public="1" get="inline" set="null" line="106" static="1">
			<x path="Float"/>
			<haxe_doc>* The largest representable number (double-precision IEEE-754).</haxe_doc>
		</DOUBLE_MAX>
		<DOUBLE_MIN public="1" get="inline" set="null" line="111" static="1">
			<x path="Float"/>
			<haxe_doc>* The smallest representable number (double-precision IEEE-754).</haxe_doc>
		</DOUBLE_MIN>
		<haxe_doc><![CDATA[* <p>Limits for integer and float types.</p>]]></haxe_doc>
	</class>
	<typedef path="de.polygonal.core.math.M" params="" file="libSrc/core/src/de/polygonal/core/math/Mathematics.hx" module="de.polygonal.core.math.Mathematics"><c path="de.polygonal.core.math.Mathematics"/></typedef>
	<class path="de.polygonal.core.math.Mathematics" params="" file="libSrc/core/src/de/polygonal/core/math/Mathematics.hx">
		<NaN public="1" get="inline" set="null" line="45" static="1">
			<x path="Float"/>
			<haxe_doc>* IEEE 754 NAN.</haxe_doc>
		</NaN>
		<POSITIVE_INFINITY public="1" get="inline" set="null" line="53" static="1">
			<x path="Float"/>
			<haxe_doc>* IEEE 754 positive infinity.</haxe_doc>
		</POSITIVE_INFINITY>
		<NEGATIVE_INFINITY public="1" get="inline" set="null" line="61" static="1">
			<x path="Float"/>
			<haxe_doc>* IEEE 754 negative infinity.</haxe_doc>
		</NEGATIVE_INFINITY>
		<ZERO_TOLERANCE public="1" get="inline" set="null" line="67" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Value below <em>ZERO_TOLERANCE</em> is treated as zero.]]></haxe_doc>
		</ZERO_TOLERANCE>
		<RAD_DEG public="1" get="inline" set="null" line="72" static="1">
			<x path="Float"/>
			<haxe_doc>* Multiply value by this constant to convert from radians to degrees (180 / PI).</haxe_doc>
		</RAD_DEG>
		<DEG_RAD public="1" get="inline" set="null" line="77" static="1">
			<x path="Float"/>
			<haxe_doc>* Multiply value by this constant to convert from degrees to radians (PI / 180).</haxe_doc>
		</DEG_RAD>
		<LN2 public="1" get="inline" set="null" line="82" static="1">
			<x path="Float"/>
			<haxe_doc>* The natural logarithm of 2.</haxe_doc>
		</LN2>
		<LN10 public="1" get="inline" set="null" line="87" static="1">
			<x path="Float"/>
			<haxe_doc>* The natural logarithm of 10.</haxe_doc>
		</LN10>
		<PI_OVER_2 public="1" get="inline" set="null" line="92" static="1">
			<x path="Float"/>
			<haxe_doc>* PI / 2.</haxe_doc>
		</PI_OVER_2>
		<PI_OVER_4 public="1" get="inline" set="null" line="97" static="1">
			<x path="Float"/>
			<haxe_doc>* PI / 4.</haxe_doc>
		</PI_OVER_4>
		<PI public="1" get="inline" set="null" line="102" static="1">
			<x path="Float"/>
			<haxe_doc>* PI.</haxe_doc>
		</PI>
		<PI2 public="1" get="inline" set="null" line="107" static="1">
			<x path="Float"/>
			<haxe_doc>* 2 * PI.</haxe_doc>
		</PI2>
		<EPS public="1" get="inline" set="null" line="112" static="1">
			<x path="Float"/>
			<haxe_doc>* Default system epsilon.</haxe_doc>
		</EPS>
		<SQRT2 public="1" get="inline" set="null" line="117" static="1">
			<x path="Float"/>
			<haxe_doc>* The square root of 2.</haxe_doc>
		</SQRT2>
		<toRad public="1" get="inline" set="null" line="142" static="1">
			<f a="deg">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Converts <code>deg</code> to radians.]]></haxe_doc>
		</toRad>
		<toDeg public="1" get="inline" set="null" line="150" static="1"><f a="rad">
	<x path="Float"/>
	<x path="Float"/>
</f></toDeg>
		<min public="1" get="inline" set="null" line="158" static="1"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></min>
		<max public="1" get="inline" set="null" line="166" static="1"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></max>
		<abs public="1" get="inline" set="null" line="174" static="1"><f a="x">
	<x path="Int"/>
	<x path="Int"/>
</f></abs>
		<sgn public="1" get="inline" set="null" line="183" static="1"><f a="x">
	<x path="Int"/>
	<x path="Int"/>
</f></sgn>
		<clamp public="1" get="inline" set="null" line="191" static="1"><f a="x:min:max">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></clamp>
		<clampSym public="1" get="inline" set="null" line="199" static="1"><f a="x:i">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></clampSym>
		<wrap public="1" get="inline" set="null" line="207" static="1"><f a="x:min:max">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></wrap>
		<fmin public="1" get="inline" set="null" line="215" static="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></fmin>
		<fmax public="1" get="inline" set="null" line="223" static="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></fmax>
		<fabs public="1" get="inline" set="null" line="231" static="1"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></fabs>
		<fsgn public="1" get="inline" set="null" line="240" static="1"><f a="x">
	<x path="Float"/>
	<x path="Int"/>
</f></fsgn>
		<fclamp public="1" get="inline" set="null" line="248" static="1"><f a="x:min:max">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></fclamp>
		<fclampSym public="1" get="inline" set="null" line="256" static="1"><f a="x:i">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></fclampSym>
		<fwrap public="1" get="inline" set="null" line="264" static="1"><f a="value:lower:upper">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></fwrap>
		<eqSgn public="1" get="inline" set="null" line="276" static="1"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></eqSgn>
		<isEven public="1" get="inline" set="null" line="284" static="1"><f a="x">
	<x path="Int"/>
	<x path="Bool"/>
</f></isEven>
		<isPow2 public="1" get="inline" set="null" line="292" static="1"><f a="x">
	<x path="Int"/>
	<x path="Bool"/>
</f></isPow2>
		<lerp public="1" get="inline" set="null" line="300" static="1"><f a="a:b:t">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></lerp>
		<slerp public="1" get="inline" set="null" line="309" static="1"><f a="a:b:t">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></slerp>
		<nextPow2 public="1" get="inline" set="null" line="361" static="1"><f a="x">
	<x path="Int"/>
	<x path="Int"/>
</f></nextPow2>
		<exp public="1" get="inline" set="null" line="375" static="1"><f a="a:n">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></exp>
		<log10 public="1" get="inline" set="null" line="397" static="1"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></log10>
		<roundTo public="1" get="inline" set="null" line="405" static="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></roundTo>
		<round public="1" get="inline" set="null" line="428" static="1"><f a="x">
	<x path="Float"/>
	<x path="Int"/>
</f></round>
		<ceil public="1" get="inline" set="null" line="436" static="1"><f a="x">
	<x path="Float"/>
	<x path="Int"/>
</f></ceil>
		<floor public="1" get="inline" set="null" line="462" static="1"><f a="x">
	<x path="Float"/>
	<x path="Int"/>
</f></floor>
		<sqrt public="1" get="inline" set="null" line="477" static="1"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></sqrt>
		<invSqrt public="1" get="inline" set="null" line="494" static="1"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></invSqrt>
		<cmpAbs public="1" get="inline" set="null" line="511" static="1"><f a="x:y:eps">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></cmpAbs>
		<cmpZero public="1" get="inline" set="null" line="520" static="1"><f a="x:eps">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></cmpZero>
		<snap public="1" get="inline" set="null" line="528" static="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></snap>
		<inRange public="1" get="inline" set="null" line="536" static="1"><f a="x:min:max">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></inRange>
		<wrapToPI public="1" get="inline" set="null" line="544" static="1"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></wrapToPI>
		<wrapToPI2 public="1" get="inline" set="null" line="553" static="1"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></wrapToPI2>
		<gcd public="1" get="inline" set="null" line="562" static="1"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gcd>
		<maxPrecision public="1" get="inline" set="null" line="588" static="1"><f a="x:precision">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
</f></maxPrecision>
		<ofBool public="1" get="inline" set="null" line="597" static="1"><f a="x">
	<x path="Bool"/>
	<x path="Int"/>
</f></ofBool>
		<haxe_doc><![CDATA[* <p>Various math functions and constants.</p>]]></haxe_doc>
	</class>
	<class path="de.polygonal.core.math.random.Random" params="" file="libSrc/core/src/de/polygonal/core/math/random/Random.hx">
		<rand public="1" get="inline" set="null" line="43" static="1">
			<f a=""><x path="Int"/></f>
			<haxe_doc><![CDATA[* Returns a random integral number in the interval <arg>&#091;0, 0x7fffffff)</arg>.]]></haxe_doc>
		</rand>
		<randRange public="1" get="inline" set="null" line="51" static="1"><f a="min:max">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></randRange>
		<randSym public="1" get="inline" set="null" line="61" static="1"><f a="range">
	<x path="Int"/>
	<x path="Float"/>
</f></randSym>
		<randBool public="1" get="inline" set="null" line="69" static="1"><f a=""><x path="Bool"/></f></randBool>
		<frand public="1" get="inline" set="null" line="77" static="1"><f a=""><x path="Float"/></f></frand>
		<frandRange public="1" get="inline" set="null" line="85" static="1"><f a="min:max">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></frandRange>
		<frandSym public="1" get="inline" set="null" line="93" static="1"><f a="range">
	<x path="Float"/>
	<x path="Float"/>
</f></frandSym>
		<haxe_doc><![CDATA[* <p>Generates random numbers using the platform-specific <em>Math.random()</em> implementation.</p>]]></haxe_doc>
	</class>
	<typedef path="de.polygonal.core.util.D" params="" file="libSrc/core/src/de/polygonal/core/util/Assert.hx" module="de.polygonal.core.util.Assert"><c path="de.polygonal.core.util.Assert"/></typedef>
	<class path="de.polygonal.core.util.Assert" params="" file="libSrc/core/src/de/polygonal/core/util/Assert.hx"/>
	<class path="de.polygonal.core.util.AssertError" params="" file="libSrc/core/src/de/polygonal/core/util/AssertError.hx">
		<toString public="1" set="method" line="43"><f a=""><c path="String"/></f></toString>
		<message public="1"><c path="String"/></message>
		<new public="1" set="method" line="36"><f a="?message:?info">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="de.polygonal.ds._Array2.Array2Friend" params="T" file="libSrc/ds/de/polygonal/ds/Array2.hx" private="1" module="de.polygonal.ds.Array2"><a>
	<_w><x path="Int"/></_w>
	<_h><x path="Int"/></_h>
	<_a><c path="Array"><c path="de.polygonal.ds._Array2.Array2Friend.T"/></c></_a>
</a></typedef>
	<class path="de.polygonal.ds.Hashable" params="" file="libSrc/ds/de/polygonal/ds/Hashable.hx" interface="1">
		<key public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* A unique, unsigned 32-bit integer key.<br/>
	 * A hash table transforms this key into an index of an array element by using a hash function.<br/>
	 * <warn>This value should never be changed by the user.</warn>]]></haxe_doc>
		</key>
		<haxe_doc><![CDATA[* <p>An object that can be identified by an unique integer key.</p>]]></haxe_doc>
	</class>
	<class path="de.polygonal.ds.Collection" params="T" file="libSrc/ds/de/polygonal/ds/Collection.hx" interface="1">
		<extends path="de.polygonal.ds.Hashable"/>
		<clone public="1" set="method">
			<f a="?assign:?copier">
				<x path="Bool"/>
				<f a="">
					<c path="de.polygonal.ds.Collection.T"/>
					<c path="de.polygonal.ds.Collection.T"/>
				</f>
				<c path="de.polygonal.ds.Collection"><c path="de.polygonal.ds.Collection.T"/></c>
			</f>
			<haxe_doc><![CDATA[* Duplicates this collection. Supports shallow (structure only) and deep copies (structure & elements).<br/>
	 * Example:<br/>
	 * <pre class="prettyprint">
	 * class Foo implements de.polygonal.ds.Cloneable&lt;Foo&gt;
	 * {
	 *     public var value:Int;
	 *     
	 *     public function new(value:Int) {
	 *         this.value = value;
	 *     }
	 *     
	 *     public function clone():Foo {
	 *         return new Foo(value);
	 *     }
	 * }
	 * 
	 * class Main
	 * {
	 *     var c:Collection&lt;Foo&gt; = new *&lt;Foo&gt;(...);
	 * 
	 *     //shallow copy
	 *     var clone = c.clone(true);
	 * 
	 *     //deep copy
	 *     var clone = c.clone(false);
	 * 
	 *     //deep copy using a custom function to do the actual work
	 *     var clone = c.clone(false, function(existingValue:Foo) { return new Foo(existingValue.value); })
	 * }</pre>
	 * @param assign if true, the <code>copier</code> parameter is ignored and primitive elements are copied by value whereas objects are copied by reference.<br/>
	 * If false, the <em>clone()</em> method is called on each element. <warn>In this case all elements have to implement <em>Cloneable</em>.</warn>
	 * @param copier a custom function for copying elements. Replaces element.<em>clone()</em> if <code>assign</code> is false.]]></haxe_doc>
		</clone>
		<toVector public="1" set="method">
			<f a=""><c path="flash.Vector"><d/></c></f>
			<haxe_doc><![CDATA[* Returns a Vector.&lt;T&gt; object storing all elements in this collection.]]></haxe_doc>
		</toVector>
		<toArray public="1" set="method">
			<f a=""><c path="Array"><c path="de.polygonal.ds.Collection.T"/></c></f>
			<haxe_doc>* Returns an array storing all elements in this collection.</haxe_doc>
		</toArray>
		<size public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the total number of elements in this collection.</haxe_doc>
		</size>
		<isEmpty public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns true if this collection is empty.</haxe_doc>
		</isEmpty>
		<iterator public="1" set="method">
			<f a=""><c path="de.polygonal.ds.Itr"><c path="de.polygonal.ds.Collection.T"/></c></f>
			<haxe_doc><![CDATA[* Iterates over all elements in this collection.<br/>
	 * Example:<br/>
	 * <pre class="prettyprint">
	 * //Haxe
	 * var c:Collection&lt;String&gt; = new *&lt;String&gt;(...);
	 * for (element in c) {
	 *     trace(element);
	 * }
	 * 
	 * //ActionScript 3.0:
	 * var c:Collection = new *(...);
	 * var itr:Itr = c.iterator();
	 * while (itr.hasNext()) {
	 *     var element:* = itr.next();
	 *     trace(element);
	 * }</pre>
	 * @see <a href="http://haxe.org/ref/iterators" target="_blank">http://haxe.org/ref/iterators</a>]]></haxe_doc>
		</iterator>
		<clear public="1" set="method">
			<f a="?purge">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Removes all elements from this collection.<br/>
	 * For performance reasons, elements are not nullified upon removal.<br/>
	 * This means that elements won't be available for the garbage collector immediately unless <code>purge</code> is true.
	 * @param purge if true, elements are nullifies upon removal (slower).]]></haxe_doc>
		</clear>
		<remove public="1" set="method">
			<f a="x">
				<c path="de.polygonal.ds.Collection.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Removes all occurrences of the element <code>x</code>.
	 * @return true if at least one occurrence of <code>x</code> was removed.]]></haxe_doc>
		</remove>
		<contains public="1" set="method">
			<f a="x">
				<c path="de.polygonal.ds.Collection.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Returns true if this collection contains the element <code>x</code>.]]></haxe_doc>
		</contains>
		<free public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Deconstructs this collection by explicitly nullifying all internal references for GC'ing used resources.<br/>
	 * Improves GC efficiency/performance (optional).]]></haxe_doc>
		</free>
		<haxe_doc><![CDATA[* <p>A collection is an object that stores other objects (its elements).</p>]]></haxe_doc>
	</class>
	<class path="de.polygonal.ds.Array2" params="T" file="libSrc/ds/de/polygonal/ds/Array2.hx">
		<implements path="de.polygonal.ds.Collection"><c path="de.polygonal.ds.Array2.T"/></implements>
		<__set get="inline" set="null" line="1035"><f a="i:x">
	<x path="Int"/>
	<c path="de.polygonal.ds.Array2.T"/>
	<x path="Void"/>
</f></__set>
		<__get get="inline" set="null" line="1031"><f a="i">
	<x path="Int"/>
	<c path="de.polygonal.ds.Array2.T"/>
</f></__get>
		<clone public="1" set="method" line="1001"><f a="?assign:?copier">
	<x path="Bool"/>
	<f a="">
		<c path="de.polygonal.ds.Array2.T"/>
		<c path="de.polygonal.ds.Array2.T"/>
	</f>
	<c path="de.polygonal.ds.Collection"><c path="de.polygonal.ds.Array2.T"/></c>
</f></clone>
		<toVector public="1" set="method" line="986"><f a=""><c path="flash.Vector"><d/></c></f></toVector>
		<toArray public="1" set="method" line="973"><f a=""><c path="Array"><c path="de.polygonal.ds.Array2.T"/></c></f></toArray>
		<isEmpty public="1" set="method" line="964"><f a=""><x path="Bool"/></f></isEmpty>
		<size public="1" get="inline" set="null" line="955"><f a=""><x path="Int"/></f></size>
		<iterator public="1" set="method" line="936"><f a=""><c path="de.polygonal.ds.Itr"><c path="de.polygonal.ds.Array2.T"/></c></f></iterator>
		<clear public="1" set="method" line="926"><f a="?purge">
	<x path="Bool"/>
	<x path="Void"/>
</f></clear>
		<remove public="1" set="method" line="906"><f a="x">
	<c path="de.polygonal.ds.Array2.T"/>
	<x path="Bool"/>
</f></remove>
		<contains public="1" set="method" line="890"><f a="x">
	<c path="de.polygonal.ds.Array2.T"/>
	<x path="Bool"/>
</f></contains>
		<free public="1" set="method" line="879"><f a=""><x path="Void"/></f></free>
		<toString public="1" set="method" line="846"><f a=""><c path="String"/></f></toString>
		<shuffle public="1" set="method" line="799"><f a="?rval">
	<c path="de.polygonal.ds.DA"><x path="Float"/></c>
	<x path="Void"/>
</f></shuffle>
		<setNestedArray public="1" set="method" line="777"><f a="a">
	<c path="Array"><c path="Array"><c path="de.polygonal.ds.Array2.T"/></c></c>
	<x path="Void"/>
</f></setNestedArray>
		<getArray public="1" get="inline" set="null" line="768"><f a=""><c path="Array"><c path="de.polygonal.ds.Array2.T"/></c></f></getArray>
		<transpose public="1" set="method" line="742"><f a=""><x path="Void"/></f></transpose>
		<swapCol public="1" set="method" line="717"><f a="i:j">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swapCol>
		<copyCol public="1" set="method" line="695"><f a="i:j">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyCol>
		<swapRow public="1" set="method" line="668"><f a="i:j">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swapRow>
		<copyRow public="1" set="method" line="648"><f a="i:j">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyRow>
		<prependCol public="1" set="method" line="616"><f a="input">
	<c path="Array"><c path="de.polygonal.ds.Array2.T"/></c>
	<x path="Void"/>
</f></prependCol>
		<prependRow public="1" set="method" line="592"><f a="input">
	<c path="Array"><c path="de.polygonal.ds.Array2.T"/></c>
	<x path="Void"/>
</f></prependRow>
		<appendCol public="1" set="method" line="560"><f a="input">
	<c path="Array"><c path="de.polygonal.ds.Array2.T"/></c>
	<x path="Void"/>
</f></appendCol>
		<appendRow public="1" set="method" line="544"><f a="input">
	<c path="Array"><c path="de.polygonal.ds.Array2.T"/></c>
	<x path="Void"/>
</f></appendRow>
		<swap public="1" get="inline" set="null" line="522"><f a="x0:y0:x1:y1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swap>
		<shiftS public="1" set="method" line="502"><f a=""><x path="Void"/></f></shiftS>
		<shiftN public="1" set="method" line="483"><f a=""><x path="Void"/></f></shiftN>
		<shiftE public="1" set="method" line="464"><f a=""><x path="Void"/></f></shiftE>
		<shiftW public="1" set="method" line="446"><f a=""><x path="Void"/></f></shiftW>
		<resize public="1" set="method" line="416"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<walk public="1" set="method" line="397"><f a="process">
	<f a="::">
		<c path="de.polygonal.ds.Array2.T"/>
		<x path="Int"/>
		<x path="Int"/>
		<c path="de.polygonal.ds.Array2.T"/>
	</f>
	<x path="Void"/>
</f></walk>
		<fill public="1" set="method" line="387"><f a="x">
	<c path="de.polygonal.ds.Array2.T"/>
	<x path="Void"/>
</f></fill>
		<assign public="1" set="method" line="377"><f a="C:?args">
	<x path="Class"><c path="de.polygonal.ds.Array2.T"/></x>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></assign>
		<setCol public="1" set="method" line="359"><f a="x:input">
	<x path="Int"/>
	<c path="Array"><c path="de.polygonal.ds.Array2.T"/></c>
	<x path="Void"/>
</f></setCol>
		<getCol public="1" set="method" line="341"><f a="x:output">
	<x path="Int"/>
	<c path="Array"><c path="de.polygonal.ds.Array2.T"/></c>
	<c path="Array"><c path="de.polygonal.ds.Array2.T"/></c>
</f></getCol>
		<setRow public="1" set="method" line="321"><f a="y:input">
	<x path="Int"/>
	<c path="Array"><c path="de.polygonal.ds.Array2.T"/></c>
	<x path="Void"/>
</f></setRow>
		<getRow public="1" get="inline" set="null" line="303"><f a="y:output">
	<x path="Int"/>
	<c path="Array"><c path="de.polygonal.ds.Array2.T"/></c>
	<c path="Array"><c path="de.polygonal.ds.Array2.T"/></c>
</f></getRow>
		<cellToIndex public="1" get="inline" set="null" line="285"><f a="cell">
	<c path="de.polygonal.ds.Array2Cell"/>
	<x path="Int"/>
</f></cellToIndex>
		<indexToCell public="1" get="inline" set="null" line="267"><f a="i:cell">
	<x path="Int"/>
	<c path="de.polygonal.ds.Array2Cell"/>
	<c path="de.polygonal.ds.Array2Cell"/>
</f></indexToCell>
		<cellOf public="1" get="inline" set="null" line="246"><f a="x:cell">
	<c path="de.polygonal.ds.Array2.T"/>
	<c path="de.polygonal.ds.Array2Cell"/>
	<c path="de.polygonal.ds.Array2Cell"/>
</f></cellOf>
		<inRange public="1" get="inline" set="null" line="234"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></inRange>
		<indexOf public="1" get="inline" set="null" line="218"><f a="x">
	<c path="de.polygonal.ds.Array2.T"/>
	<x path="Int"/>
</f></indexOf>
		<getIndex public="1" get="inline" set="null" line="208"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getIndex>
		<setH public="1" get="inline" set="null" line="199"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></setH>
		<getH public="1" get="inline" set="null" line="188"><f a=""><x path="Int"/></f></getH>
		<setW public="1" get="inline" set="null" line="179"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></setW>
		<getW public="1" get="inline" set="null" line="168"><f a=""><x path="Int"/></f></getW>
		<setAtIndex public="1" get="inline" set="null" line="155"><f a="i:val">
	<x path="Int"/>
	<c path="de.polygonal.ds.Array2.T"/>
	<x path="Void"/>
</f></setAtIndex>
		<getAtIndex public="1" get="inline" set="null" line="141"><f a="i">
	<x path="Int"/>
	<c path="de.polygonal.ds.Array2.T"/>
</f></getAtIndex>
		<set public="1" get="inline" set="null" line="126"><f a="x:y:val">
	<x path="Int"/>
	<x path="Int"/>
	<c path="de.polygonal.ds.Array2.T"/>
	<x path="Void"/>
</f></set>
		<getAt public="1" get="inline" set="null" line="112"><f a="cell">
	<c path="de.polygonal.ds.Array2Cell"/>
	<c path="de.polygonal.ds.Array2.T"/>
</f></getAt>
		<get public="1" get="inline" set="null" line="96"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<c path="de.polygonal.ds.Array2.T"/>
</f></get>
		<_iterator><c path="de.polygonal.ds.Array2Iterator"><c path="de.polygonal.ds.Array2.T"/></c></_iterator>
		<_h><x path="Int"/></_h>
		<_w><x path="Int"/></_w>
		<_a><c path="Array"><c path="de.polygonal.ds.Array2.T"/></c></_a>
		<reuseIterator public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* If true, reuses the iterator object instead of allocating a new one when calling <code>iterator()</code>.<br/>
	 * The default is false.<br/>
	 * <warn>If true, nested iterations are likely to fail as only one iteration is allowed at a time.</warn>]]></haxe_doc>
		</reuseIterator>
		<key public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* A unique identifier for this object.<br/>
	 * A hash table transforms this key into an index of an array element by using a hash function.<br/>
	 * <warn>This value should never be changed by the user.</warn>]]></haxe_doc>
		</key>
		<new public="1" set="method" line="77">
			<f a="width:height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a two-dimensional array with dimensions <code>width</code> and <code>height</code>.<br/>
	 * The minimum size is 2x2.
	 * @throws de.polygonal.core.util.AssertError invalid <code>width</code> or <code>height</code> (debug only).]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* <p>A two-dimensional array based on a rectangular sequential array.</p>
 * <p><o>Worst-case running time in Big O notation</o></p>]]></haxe_doc>
	</class>
	<class path="de.polygonal.ds.Itr" params="T" file="libSrc/ds/de/polygonal/ds/Itr.hx" interface="1">
		<reset public="1" set="method">
			<f a=""><c path="de.polygonal.ds.Itr"><c path="de.polygonal.ds.Itr.T"/></c></f>
			<haxe_doc><![CDATA[* Resets this iteration so the iterator points to the first element in the collection.<br/>
	 * Improves performance if an iterator is frequently used.<br/>
	 * Example:<br/>
	 * <pre class="prettyprint">
	 * var c:Collection&lt;String&gt; = new *&lt;String&gt;(...);
	 * var itr = c.iterator();
	 * for (i in 0...100) {
	 *     itr.reset();
	 *     for (element in itr) {
	 *         trace(element);
	 *     }
	 * }
	 * </pre>]]></haxe_doc>
		</reset>
		<remove public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Removes the last element returned by the iterator from the collection.
	 * Example:<br/>
	 * <pre class="prettyprint">
	 * var c:Collection&lt;String&gt; = new *&lt;String&gt;(...);
	 * var itr = c.iterator();
	 * while (itr.hasNext()) {
	 *     var value = itr.next();
	 *     itr.remove(); //removes value
	 * }
	 * trace(c.isEmpty()); //true
	 * </pre>]]></haxe_doc>
		</remove>
		<next public="1" set="method">
			<f a=""><c path="de.polygonal.ds.Itr.T"/></f>
			<haxe_doc><![CDATA[* Returns the next element in this iteration.
	 * @see <a href="http://haxe.org/api/iterator" target="_blank">http://haxe.org/api/iterator</a>]]></haxe_doc>
		</next>
		<hasNext public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Returns true if this iteration has more elements.
	 * @see <a href="http://haxe.org/api/iterator" target="_blank">http://haxe.org/api/iterator</a>]]></haxe_doc>
		</hasNext>
		<haxe_doc><![CDATA[* <p>An iterator over a collection.</p>
 * Same as typedef <em>Iterator</em>&lt;T&gt; but augmented with a <em>reset()</em> method.]]></haxe_doc>
	</class>
	<class path="de.polygonal.ds.Array2Iterator" params="T" file="libSrc/ds/de/polygonal/ds/Array2.hx" module="de.polygonal.ds.Array2">
		<implements path="de.polygonal.ds.Itr"><c path="de.polygonal.ds.Array2Iterator.T"/></implements>
		<__size params="T" get="inline" set="null" line="1091"><f a="f">
	<t path="de.polygonal.ds._Array2.Array2Friend"><c path="__size.T"/></t>
	<x path="Int"/>
</f></__size>
		<__a params="T" get="inline" set="null" line="1087"><f a="f">
	<t path="de.polygonal.ds._Array2.Array2Friend"><c path="__a.T"/></t>
	<c path="Array"><c path="__a.T"/></c>
</f></__a>
		<remove public="1" get="inline" set="null" line="1078"><f a=""><x path="Void"/></f></remove>
		<next public="1" get="inline" set="null" line="1073"><f a=""><c path="de.polygonal.ds.Array2Iterator.T"/></f></next>
		<hasNext public="1" get="inline" set="null" line="1068"><f a=""><x path="Bool"/></f></hasNext>
		<reset public="1" get="inline" set="null" line="1060"><f a=""><c path="de.polygonal.ds.Itr"><c path="de.polygonal.ds.Array2Iterator.T"/></c></f></reset>
		<_s><x path="Int"/></_s>
		<_i><x path="Int"/></_i>
		<_a><c path="Array"><c path="de.polygonal.ds.Array2Iterator.T"/></c></_a>
		<_f><c path="de.polygonal.ds.Array2"><c path="de.polygonal.ds.Array2Iterator.T"/></c></_f>
		<new public="1" set="method" line="1054"><f a="f">
	<c path="de.polygonal.ds.Array2"><c path="de.polygonal.ds.Array2Iterator.T"/></c>
	<x path="Void"/>
</f></new>
	</class>
	<class path="de.polygonal.ds.Array2Cell" params="" file="libSrc/ds/de/polygonal/ds/Array2.hx" module="de.polygonal.ds.Array2">
		<y public="1">
			<x path="Int"/>
			<haxe_doc>* The row index.</haxe_doc>
		</y>
		<x public="1">
			<x path="Int"/>
			<haxe_doc>* The column index.</haxe_doc>
		</x>
		<new public="1" set="method" line="1112"><f a="?x:?y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* <p>Stores the x,y position of a two-dimensional cell.</p>]]></haxe_doc>
	</class>
	<typedef path="de.polygonal.ds._Array3.Array3Friend" params="T" file="libSrc/ds/de/polygonal/ds/Array3.hx" private="1" module="de.polygonal.ds.Array3"><a>
	<_w><x path="Int"/></_w>
	<_h><x path="Int"/></_h>
	<_d><x path="Int"/></_d>
	<_a><c path="Array"><c path="de.polygonal.ds._Array3.Array3Friend.T"/></c></_a>
</a></typedef>
	<class path="de.polygonal.ds.Array3" params="T" file="libSrc/ds/de/polygonal/ds/Array3.hx">
		<implements path="de.polygonal.ds.Collection"><c path="de.polygonal.ds.Array3.T"/></implements>
		<__set get="inline" set="null" line="760"><f a="i:x">
	<x path="Int"/>
	<c path="de.polygonal.ds.Array3.T"/>
	<x path="Void"/>
</f></__set>
		<__get get="inline" set="null" line="756"><f a="i">
	<x path="Int"/>
	<c path="de.polygonal.ds.Array3.T"/>
</f></__get>
		<clone public="1" set="method" line="727"><f a="?assign:?copier">
	<x path="Bool"/>
	<f a="">
		<c path="de.polygonal.ds.Array3.T"/>
		<c path="de.polygonal.ds.Array3.T"/>
	</f>
	<c path="de.polygonal.ds.Collection"><c path="de.polygonal.ds.Array3.T"/></c>
</f></clone>
		<toVector public="1" set="method" line="712"><f a=""><c path="flash.Vector"><d/></c></f></toVector>
		<toArray public="1" set="method" line="699"><f a=""><c path="Array"><c path="de.polygonal.ds.Array3.T"/></c></f></toArray>
		<isEmpty public="1" set="method" line="690"><f a=""><x path="Bool"/></f></isEmpty>
		<size public="1" get="inline" set="null" line="682"><f a=""><x path="Int"/></f></size>
		<iterator public="1" set="method" line="663"><f a=""><c path="de.polygonal.ds.Itr"><c path="de.polygonal.ds.Array3.T"/></c></f></iterator>
		<clear public="1" get="inline" set="null" line="653"><f a="?purge">
	<x path="Bool"/>
	<x path="Void"/>
</f></clear>
		<remove public="1" set="method" line="633"><f a="x">
	<c path="de.polygonal.ds.Array3.T"/>
	<x path="Bool"/>
</f></remove>
		<contains public="1" set="method" line="617"><f a="x">
	<c path="de.polygonal.ds.Array3.T"/>
	<x path="Bool"/>
</f></contains>
		<free public="1" set="method" line="606"><f a=""><x path="Void"/></f></free>
		<toString public="1" set="method" line="592"><f a=""><c path="String"/></f></toString>
		<shuffle public="1" set="method" line="557"><f a="?rval">
	<c path="de.polygonal.ds.DA"><x path="Float"/></c>
	<x path="Void"/>
</f></shuffle>
		<getArray public="1" get="inline" set="null" line="545"><f a=""><c path="Array"><c path="de.polygonal.ds.Array3.T"/></c></f></getArray>
		<swap public="1" get="inline" set="null" line="521"><f a="x0:y0:z0:x1:y1:z1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swap>
		<resize public="1" set="method" line="481"><f a="width:height:depth">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<walk public="1" set="method" line="458"><f a="process">
	<f a=":::">
		<c path="de.polygonal.ds.Array3.T"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<c path="de.polygonal.ds.Array3.T"/>
	</f>
	<x path="Void"/>
</f></walk>
		<fill public="1" set="method" line="448"><f a="x">
	<c path="de.polygonal.ds.Array3.T"/>
	<x path="Void"/>
</f></fill>
		<assign public="1" set="method" line="438"><f a="C:?args">
	<x path="Class"><c path="de.polygonal.ds.Array3.T"/></x>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></assign>
		<setPile public="1" set="method" line="417"><f a="x:y:input">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><c path="de.polygonal.ds.Array3.T"/></c>
	<x path="Void"/>
</f></setPile>
		<getPile public="1" get="inline" set="null" line="397"><f a="x:y:output">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><c path="de.polygonal.ds.Array3.T"/></c>
	<c path="Array"><c path="de.polygonal.ds.Array3.T"/></c>
</f></getPile>
		<setCol public="1" set="method" line="377"><f a="z:x:input">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><c path="de.polygonal.ds.Array3.T"/></c>
	<x path="Void"/>
</f></setCol>
		<getCol public="1" get="inline" set="null" line="358"><f a="z:x:output">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><c path="de.polygonal.ds.Array3.T"/></c>
	<c path="Array"><c path="de.polygonal.ds.Array3.T"/></c>
</f></getCol>
		<setRow public="1" set="method" line="338"><f a="z:y:input">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><c path="de.polygonal.ds.Array3.T"/></c>
	<x path="Void"/>
</f></setRow>
		<getRow public="1" set="method" line="319"><f a="z:y:output">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><c path="de.polygonal.ds.Array3.T"/></c>
	<c path="Array"><c path="de.polygonal.ds.Array3.T"/></c>
</f></getRow>
		<getLayer public="1" set="method" line="298"><f a="z:output">
	<x path="Int"/>
	<c path="de.polygonal.ds.Array2"><c path="de.polygonal.ds.Array3.T"/></c>
	<c path="de.polygonal.ds.Array2"><c path="de.polygonal.ds.Array3.T"/></c>
</f></getLayer>
		<cellToIndex public="1" get="inline" set="null" line="278"><f a="cell">
	<c path="de.polygonal.ds.Array3Cell"/>
	<x path="Int"/>
</f></cellToIndex>
		<indexToCell public="1" get="inline" set="null" line="258"><f a="i:cell">
	<x path="Int"/>
	<c path="de.polygonal.ds.Array3Cell"/>
	<c path="de.polygonal.ds.Array3Cell"/>
</f></indexToCell>
		<cellOf public="1" get="inline" set="null" line="237"><f a="x:cell">
	<c path="de.polygonal.ds.Array3.T"/>
	<c path="de.polygonal.ds.Array3Cell"/>
	<c path="de.polygonal.ds.Array3Cell"/>
</f></cellOf>
		<inRange public="1" get="inline" set="null" line="225"><f a="x:y:z">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></inRange>
		<indexOf public="1" get="inline" set="null" line="209"><f a="x">
	<c path="de.polygonal.ds.Array3.T"/>
	<x path="Int"/>
</f></indexOf>
		<getIndex public="1" get="inline" set="null" line="199"><f a="x:y:z">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getIndex>
		<setD public="1" get="inline" set="null" line="190"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></setD>
		<getD public="1" get="inline" set="null" line="179"><f a=""><x path="Int"/></f></getD>
		<setH public="1" get="inline" set="null" line="170"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></setH>
		<getH public="1" get="inline" set="null" line="159"><f a=""><x path="Int"/></f></getH>
		<setW public="1" get="inline" set="null" line="150"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></setW>
		<getW public="1" get="inline" set="null" line="139"><f a=""><x path="Int"/></f></getW>
		<set public="1" get="inline" set="null" line="124"><f a="x:y:z:val">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="de.polygonal.ds.Array3.T"/>
	<x path="Void"/>
</f></set>
		<getAt public="1" get="inline" set="null" line="114"><f a="cell">
	<c path="de.polygonal.ds.Array3Cell"/>
	<c path="de.polygonal.ds.Array3.T"/>
</f></getAt>
		<get public="1" get="inline" set="null" line="98"><f a="x:y:z">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="de.polygonal.ds.Array3.T"/>
</f></get>
		<_iterator><c path="de.polygonal.ds.Array3Iterator"><c path="de.polygonal.ds.Array3.T"/></c></_iterator>
		<_d><x path="Int"/></_d>
		<_h><x path="Int"/></_h>
		<_w><x path="Int"/></_w>
		<_a><c path="Array"><c path="de.polygonal.ds.Array3.T"/></c></_a>
		<reuseIterator public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* If true, reuses the iterator object instead of allocating a new one when calling <code>iterator()</code>.<br/>
	 * The default is false.<br/>
	 * <warn>If true, nested iterations are likely to fail as only one iteration is allowed at a time.</warn>]]></haxe_doc>
		</reuseIterator>
		<key public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* A unique identifier for this object.<br/>
	 * A hash table transforms this key into an index of an array element by using a hash function.<br/>
	 * <warn>This value should never be changed by the user.</warn>]]></haxe_doc>
		</key>
		<new public="1" set="method" line="78">
			<f a="width:height:depth">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a three-dimensional array with dimensions <code>width</code>, <code>height</code> and <code>depth</code>.<br/>
	 * The minimum size is 2x2x2.
	 * @throws de.polygonal.core.util.AssertError invalid <code>width</code>, <code>height</code> or <code>depth</code> (debug only).]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* <p>A three-dimensional array based on a rectangular sequential array.</p>
 * <p><o>Worst-case running time in Big O notation</o></p>]]></haxe_doc>
	</class>
	<class path="de.polygonal.ds.Array3Iterator" params="T" file="libSrc/ds/de/polygonal/ds/Array3.hx" module="de.polygonal.ds.Array3">
		<implements path="de.polygonal.ds.Itr"><c path="de.polygonal.ds.Array3Iterator.T"/></implements>
		<__size params="T" get="inline" set="null" line="818"><f a="f">
	<t path="de.polygonal.ds._Array3.Array3Friend"><c path="__size.T"/></t>
	<x path="Int"/>
</f></__size>
		<__a params="T" get="inline" set="null" line="814"><f a="f">
	<t path="de.polygonal.ds._Array3.Array3Friend"><c path="__a.T"/></t>
	<c path="Array"><c path="__a.T"/></c>
</f></__a>
		<remove public="1" get="inline" set="null" line="804"><f a=""><x path="Void"/></f></remove>
		<next public="1" get="inline" set="null" line="799"><f a=""><c path="de.polygonal.ds.Array3Iterator.T"/></f></next>
		<hasNext public="1" get="inline" set="null" line="794"><f a=""><x path="Bool"/></f></hasNext>
		<reset public="1" get="inline" set="null" line="786"><f a=""><c path="de.polygonal.ds.Itr"><c path="de.polygonal.ds.Array3Iterator.T"/></c></f></reset>
		<_s><x path="Int"/></_s>
		<_i><x path="Int"/></_i>
		<_a><c path="Array"><c path="de.polygonal.ds.Array3Iterator.T"/></c></_a>
		<_f><c path="de.polygonal.ds.Array3"><c path="de.polygonal.ds.Array3Iterator.T"/></c></_f>
		<new public="1" set="method" line="780"><f a="f">
	<c path="de.polygonal.ds.Array3"><c path="de.polygonal.ds.Array3Iterator.T"/></c>
	<x path="Void"/>
</f></new>
	</class>
	<class path="de.polygonal.ds.Array3Cell" params="" file="libSrc/ds/de/polygonal/ds/Array3.hx" module="de.polygonal.ds.Array3">
		<z public="1">
			<x path="Int"/>
			<haxe_doc>* The depth index.</haxe_doc>
		</z>
		<y public="1">
			<x path="Int"/>
			<haxe_doc>* The row index.</haxe_doc>
		</y>
		<x public="1">
			<x path="Int"/>
			<haxe_doc>* The column index.</haxe_doc>
		</x>
		<new public="1" set="method" line="844"><f a="?x:?y:?z">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* <p>Stores the x,y,z position of a three-dimensional cell.</p>]]></haxe_doc>
	</class>
	<class path="de.polygonal.ds.ArrayUtil" params="" file="libSrc/ds/de/polygonal/ds/ArrayUtil.hx">
		<alloc public="1" params="T" get="inline" set="null" line="44" static="1">
			<f a="x">
				<x path="Int"/>
				<c path="Array"><c path="alloc.T"/></c>
			</f>
			<haxe_doc><![CDATA[* Allocates an array with a length of <code>x</code>.
	 * @throws de.polygonal.core.util.AssertError <code>x</code> &lt; 0 (debug only).]]></haxe_doc>
		</alloc>
		<shrink public="1" params="T" get="inline" set="null" line="66" static="1"><f a="a:x">
	<c path="Array"><c path="shrink.T"/></c>
	<x path="Int"/>
	<c path="Array"><c path="shrink.T"/></c>
</f></shrink>
		<copy public="1" params="T" get="inline" set="null" line="88" static="1"><f a="src:dst:?min:?max">
	<c path="Array"><c path="copy.T"/></c>
	<c path="Array"><c path="copy.T"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><c path="copy.T"/></c>
</f></copy>
		<fill public="1" params="T" get="inline" set="null" line="110" static="1"><f a="dst:x:?k">
	<c path="Array"><c path="fill.T"/></c>
	<c path="fill.T"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fill>
		<assign public="1" params="T" get="inline" set="null" line="121" static="1"><f a="dst:C:?args:?k">
	<c path="Array"><c path="assign.T"/></c>
	<x path="Class"><c path="assign.T"/></x>
	<c path="Array"><d/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></assign>
		<memmove public="1" params="T" get="inline" set="null" line="134" static="1"><f a="a:destination:source:n">
	<c path="Array"><c path="memmove.T"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></memmove>
		<bsearchComparator public="1" params="T" set="method" line="177" static="1"><f a="a:x:min:max:comparator">
	<c path="Array"><c path="bsearchComparator.T"/></c>
	<c path="bsearchComparator.T"/>
	<x path="Int"/>
	<x path="Int"/>
	<f a=":">
		<c path="bsearchComparator.T"/>
		<c path="bsearchComparator.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
</f></bsearchComparator>
		<bsearchInt public="1" get="inline" set="null" line="209" static="1"><f a="a:x:min:max">
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bsearchInt>
		<bsearchFloat public="1" get="inline" set="null" line="240" static="1"><f a="a:x:min:max">
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bsearchFloat>
		<shuffle public="1" params="T" set="method" line="270" static="1"><f a="a:?rval">
	<c path="Array"><c path="shuffle.T"/></c>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></shuffle>
		<sortRange public="1" set="method" line="314" static="1"><f a="a:compare:useInsertionSort:first:count">
	<c path="Array"><x path="Float"/></c>
	<f a=":">
		<x path="Float"/>
		<x path="Float"/>
		<x path="Int"/>
	</f>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sortRange>
		<quickPerm public="1" set="method" line="336" static="1"><f a="n">
	<x path="Int"/>
	<c path="Array"><c path="Array"><x path="Int"/></c></c>
</f></quickPerm>
		<equals public="1" params="T" set="method" line="376" static="1"><f a="a:b">
	<c path="Array"><c path="equals.T"/></c>
	<c path="Array"><c path="equals.T"/></c>
	<x path="Bool"/>
</f></equals>
		<split public="1" params="T" set="method" line="389" static="1"><f a="a:n:k">
	<c path="Array"><c path="split.T"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><c path="Array"><c path="split.T"/></c></c>
</f></split>
		<_insertionSort set="method" line="406" static="1"><f a="a:first:k:cmp">
	<c path="Array"><x path="Float"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<f a=":">
		<x path="Float"/>
		<x path="Float"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></_insertionSort>
		<_quickSort set="method" line="428" static="1"><f a="a:first:k:cmp">
	<c path="Array"><x path="Float"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<f a=":">
		<x path="Float"/>
		<x path="Float"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></_quickSort>
		<haxe_doc><![CDATA[* <p>Various utility functions for working with arrays.</p>]]></haxe_doc>
	</class>
	<class path="de.polygonal.ds.Cloneable" params="T" file="libSrc/ds/de/polygonal/ds/Cloneable.hx" interface="1">
		<clone public="1" set="method">
			<f a=""><c path="de.polygonal.ds.Cloneable.T"/></f>
			<haxe_doc>* Returns a copy of this object.</haxe_doc>
		</clone>
		<haxe_doc><![CDATA[* <p>An object that can be cloned by calling object.<em>clone()</em>.</p>
 * <p>Example:</p>
 * <pre class="prettyprint">
 * class Foo implements de.polygonal.ds.Cloneable&lt;Foo&gt;
 * {
 *     public function new() {}
 * 
 *     public function clone():Foo {
 *         return new Foo();
 *     }
 * }</pre>]]></haxe_doc>
	</class>
	<class path="de.polygonal.ds.Comparable" params="T" file="libSrc/ds/de/polygonal/ds/Comparable.hx" interface="1">
		<compare public="1" set="method">
			<f a="other">
				<c path="de.polygonal.ds.Comparable.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Compares this object to <code>other</code>.<br/>
	 * The return value should be 1 if this object is "bigger" than <code>other</code>, -1 if this object is "smaller" than <code>other</code> and 0 if both are "equal".]]></haxe_doc>
		</compare>
		<haxe_doc><![CDATA[* <p>Specifies that the order of an element in a collection can be determined by calling object.<em>compare</em>(otherObject).</p>
 * <p>Example:</p>
 * <pre class="prettyprint">
 * class Foo implements de.polygonal.ds.Comparable&lt;Foo&gt;
 * {
 *     public var value:Int;
 *     
 *     public function new() {}
 *     
 *     public function compare(other:Foo):Int {
 *         return value - other.value;
 *     }
 * }</pre>]]></haxe_doc>
	</class>
	<typedef path="de.polygonal.ds._DA.DAFriend" params="T" file="libSrc/ds/de/polygonal/ds/DA.hx" private="1" module="de.polygonal.ds.DA"><a>
	<_size><x path="Int"/></_size>
	<_a><c path="Array"><c path="de.polygonal.ds._DA.DAFriend.T"/></c></_a>
</a></typedef>
	<class path="de.polygonal.ds.DA" params="T" file="libSrc/ds/de/polygonal/ds/DA.hx">
		<implements path="de.polygonal.ds.Collection"><c path="de.polygonal.ds.DA.T"/></implements>
		<__cpy get="inline" set="null" line="1190"><f a="i:j">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></__cpy>
		<__set get="inline" set="null" line="1185"><f a="i:x">
	<x path="Int"/>
	<c path="de.polygonal.ds.DA.T"/>
	<x path="Void"/>
</f></__set>
		<__get get="inline" set="null" line="1180"><f a="i">
	<x path="Int"/>
	<c path="de.polygonal.ds.DA.T"/>
</f></__get>
		<_insertionSortComparable set="method" line="1149"><f a="first:k">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></_insertionSortComparable>
		<_insertionSort set="method" line="1128"><f a="first:k:cmp">
	<x path="Int"/>
	<x path="Int"/>
	<f a=":">
		<c path="de.polygonal.ds.DA.T"/>
		<c path="de.polygonal.ds.DA.T"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></_insertionSort>
		<_quickSortComparable set="method" line="1061"><f a="first:k">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></_quickSortComparable>
		<_quickSort set="method" line="1012"><f a="first:k:cmp">
	<x path="Int"/>
	<x path="Int"/>
	<f a=":">
		<c path="de.polygonal.ds.DA.T"/>
		<c path="de.polygonal.ds.DA.T"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></_quickSort>
		<toString public="1" set="method" line="1001"><f a=""><c path="String"/></f></toString>
		<shuffle public="1" set="method" line="953"><f a="?rval">
	<c path="de.polygonal.ds.DA"><x path="Float"/></c>
	<x path="Void"/>
</f></shuffle>
		<clone public="1" set="method" line="914"><f a="?assign:?copier">
	<x path="Bool"/>
	<f a="">
		<c path="de.polygonal.ds.DA.T"/>
		<c path="de.polygonal.ds.DA.T"/>
	</f>
	<c path="de.polygonal.ds.Collection"><c path="de.polygonal.ds.DA.T"/></c>
</f></clone>
		<toVector public="1" set="method" line="899"><f a=""><c path="flash.Vector"><d/></c></f></toVector>
		<toArray public="1" set="method" line="887"><f a=""><c path="Array"><c path="de.polygonal.ds.DA.T"/></c></f></toArray>
		<isEmpty public="1" get="inline" set="null" line="878"><f a=""><x path="Bool"/></f></isEmpty>
		<size public="1" get="inline" set="null" line="869"><f a=""><x path="Int"/></f></size>
		<iterator public="1" set="method" line="851"><f a=""><c path="de.polygonal.ds.Itr"><c path="de.polygonal.ds.DA.T"/></c></f></iterator>
		<clear public="1" get="inline" set="null" line="838"><f a="?purge">
	<x path="Bool"/>
	<x path="Void"/>
</f></clear>
		<remove public="1" set="method" line="806"><f a="x">
	<c path="de.polygonal.ds.DA.T"/>
	<x path="Bool"/>
</f></remove>
		<contains public="1" get="inline" set="null" line="787"><f a="x">
	<c path="de.polygonal.ds.DA.T"/>
	<x path="Bool"/>
</f></contains>
		<free public="1" set="method" line="776"><f a=""><x path="Void"/></f></free>
		<getArray public="1" get="inline" set="null" line="762"><f a=""><c path="Array"><c path="de.polygonal.ds.DA.T"/></c></f></getArray>
		<inRange public="1" get="inline" set="null" line="751"><f a="i">
	<x path="Int"/>
	<x path="Bool"/>
</f></inRange>
		<sort public="1" set="method" line="712"><f a="compare:?useInsertionSort:?first:?count">
	<f a=":">
		<c path="de.polygonal.ds.DA.T"/>
		<c path="de.polygonal.ds.DA.T"/>
		<x path="Int"/>
	</f>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sort>
		<join public="1" set="method" line="686"><f a="x">
	<c path="String"/>
	<c path="String"/>
</f></join>
		<memmove public="1" get="inline" set="null" line="646"><f a="destination:source:n">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></memmove>
		<fill public="1" set="method" line="618"><f a="x:?n">
	<c path="de.polygonal.ds.DA.T"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fill>
		<assign public="1" set="method" line="592"><f a="C:?args:?n">
	<x path="Class"><c path="de.polygonal.ds.DA.T"/></x>
	<c path="Array"><d/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></assign>
		<reverse public="1" set="method" line="577"><f a=""><x path="Void"/></f></reverse>
		<lastIndexOf public="1" set="method" line="545"><f a="x:?from">
	<c path="de.polygonal.ds.DA.T"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lastIndexOf>
		<indexOf public="1" set="method" line="477"><f a="x:?from:?binarySearch:?comparator">
	<c path="de.polygonal.ds.DA.T"/>
	<x path="Int"/>
	<x path="Bool"/>
	<f a=":">
		<c path="de.polygonal.ds.DA.T"/>
		<c path="de.polygonal.ds.DA.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
</f></indexOf>
		<concat public="1" set="method" line="439"><f a="x:?copy">
	<c path="de.polygonal.ds.DA"><c path="de.polygonal.ds.DA.T"/></c>
	<x path="Bool"/>
	<c path="de.polygonal.ds.DA"><c path="de.polygonal.ds.DA.T"/></c>
</f></concat>
		<removeRange public="1" set="method" line="396"><f a="i:n:?output">
	<x path="Int"/>
	<x path="Int"/>
	<c path="de.polygonal.ds.DA"><c path="de.polygonal.ds.DA.T"/></c>
	<c path="de.polygonal.ds.DA"><c path="de.polygonal.ds.DA.T"/></c>
</f></removeRange>
		<swapPop public="1" get="inline" set="null" line="380"><f a="i">
	<x path="Int"/>
	<x path="Void"/>
</f></swapPop>
		<removeAt public="1" get="inline" set="null" line="354"><f a="i">
	<x path="Int"/>
	<c path="de.polygonal.ds.DA.T"/>
</f></removeAt>
		<insertAt public="1" get="inline" set="null" line="327"><f a="i:x">
	<x path="Int"/>
	<c path="de.polygonal.ds.DA.T"/>
	<x path="Void"/>
</f></insertAt>
		<pushFront public="1" get="inline" set="null" line="310"><f a="x">
	<c path="de.polygonal.ds.DA.T"/>
	<x path="Void"/>
</f></pushFront>
		<popFront public="1" get="inline" set="null" line="299"><f a=""><c path="de.polygonal.ds.DA.T"/></f></popFront>
		<pushBack public="1" get="inline" set="null" line="288"><f a="x">
	<c path="de.polygonal.ds.DA.T"/>
	<x path="Void"/>
</f></pushBack>
		<popBack public="1" get="inline" set="null" line="276"><f a=""><c path="de.polygonal.ds.DA.T"/></f></popBack>
		<back public="1" get="inline" set="null" line="266"><f a=""><c path="de.polygonal.ds.DA.T"/></f></back>
		<front public="1" get="inline" set="null" line="255"><f a=""><c path="de.polygonal.ds.DA.T"/></f></front>
		<cpy public="1" get="inline" set="null" line="240"><f a="i:j">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></cpy>
		<swp public="1" get="inline" set="null" line="224"><f a="i:j">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swp>
		<set public="1" get="inline" set="null" line="208"><f a="i:x">
	<x path="Int"/>
	<c path="de.polygonal.ds.DA.T"/>
	<x path="Void"/>
</f></set>
		<getPrev public="1" get="inline" set="null" line="194"><f a="i">
	<x path="Int"/>
	<c path="de.polygonal.ds.DA.T"/>
</f></getPrev>
		<getNext public="1" get="inline" set="null" line="179"><f a="i">
	<x path="Int"/>
	<c path="de.polygonal.ds.DA.T"/>
</f></getNext>
		<get public="1" get="inline" set="null" line="164"><f a="i">
	<x path="Int"/>
	<c path="de.polygonal.ds.DA.T"/>
</f></get>
		<trim public="1" get="inline" set="null" line="150"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></trim>
		<reserve public="1" set="method" line="129"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></reserve>
		<pack public="1" set="method" line="114"><f a=""><x path="Void"/></f></pack>
		<reuseIterator public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* If true, reuses the iterator object instead of allocating a new one when calling <code>iterator()</code>.<br/>
	 * The default is false.<br/>
	 * <warn>If true, nested iterations are likely to fail as only one iteration is allowed at a time.</warn>]]></haxe_doc>
		</reuseIterator>
		<maxSize public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The maximum allowed size of this dense array.<br/>
	 * Once the maximum size is reached, adding an element will fail with an error (debug only).<br/>
	 * A value of -1 indicates that the size is unbound.<br/>
	 * <warn>Always equals -1 in release mode.</warn>]]></haxe_doc>
		</maxSize>
		<_iterator><c path="de.polygonal.ds.DAIterator"><c path="de.polygonal.ds.DA.T"/></c></_iterator>
		<_size><x path="Int"/></_size>
		<_a><c path="Array"><c path="de.polygonal.ds.DA.T"/></c></_a>
		<key public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* A unique identifier for this object.<br/>
	 * A hash table transforms this key into an index of an array element by using a hash function.<br/>
	 * <warn>This value should never be changed by the user.</warn>]]></haxe_doc>
		</key>
		<new public="1" set="method" line="84">
			<f a="?reservedSize:?maxSize">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* @param reservedSize the initial capacity of the internal container. See <em>reserve()</em>.
	 * @param maxSize the maximum allowed size of this dense array.<br/>
	 * The default value of -1 indicates that there is no upper limit.
	 * @throws de.polygonal.core.util.AssertError reserved size is greater than allowed size (debug only).]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* <p>A dense, dynamic array.</p>
 * <p><o>Worst-case running time in Big O notation</o></p>]]></haxe_doc>
	</class>
	<class path="de.polygonal.ds.DAIterator" params="T" file="libSrc/ds/de/polygonal/ds/DA.hx" module="de.polygonal.ds.DA">
		<implements path="de.polygonal.ds.Itr"><c path="de.polygonal.ds.DAIterator.T"/></implements>
		<__size get="inline" set="null" line="1247"><f a="f">
	<t path="de.polygonal.ds._DA.DAFriend"><c path="de.polygonal.ds.DAIterator.T"/></t>
	<x path="Int"/>
</f></__size>
		<__a get="inline" set="null" line="1243"><f a="f">
	<t path="de.polygonal.ds._DA.DAFriend"><c path="de.polygonal.ds.DAIterator.T"/></t>
	<c path="Array"><c path="de.polygonal.ds.DAIterator.T"/></c>
</f></__a>
		<remove public="1" get="inline" set="null" line="1233"><f a=""><x path="Void"/></f></remove>
		<next public="1" get="inline" set="null" line="1228"><f a=""><c path="de.polygonal.ds.DAIterator.T"/></f></next>
		<hasNext public="1" get="inline" set="null" line="1223"><f a=""><x path="Bool"/></f></hasNext>
		<reset public="1" get="inline" set="null" line="1215"><f a=""><c path="de.polygonal.ds.Itr"><c path="de.polygonal.ds.DAIterator.T"/></c></f></reset>
		<_s><x path="Int"/></_s>
		<_i><x path="Int"/></_i>
		<_a><c path="Array"><c path="de.polygonal.ds.DAIterator.T"/></c></_a>
		<_f><c path="de.polygonal.ds.DA"><c path="de.polygonal.ds.DAIterator.T"/></c></_f>
		<new public="1" set="method" line="1209"><f a="f">
	<c path="de.polygonal.ds.DA"><c path="de.polygonal.ds.DAIterator.T"/></c>
	<x path="Void"/>
</f></new>
	</class>
	<class path="de.polygonal.ds.HashKey" params="" file="libSrc/ds/de/polygonal/ds/HashKey.hx">
		<_counter line="37" static="1"><x path="Int"/></_counter>
		<next public="1" get="inline" set="null" line="42" static="1">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the next integer in a list of unique, unsigned integer keys.</haxe_doc>
		</next>
		<haxe_doc><![CDATA[* <p>Generates unique, unsigned integer keys.</p>]]></haxe_doc>
	</class>
	<class path="flash.events.IEventDispatcher" params="" file="/usr/lib/haxe/std/flash/events/IEventDispatcher.hx" extern="1" interface="1">
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Void"/>
</f></removeEventListener>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addEventListener>
	</class>
	<class path="flash.events.EventDispatcher" params="" file="/usr/lib/haxe/std/flash/events/EventDispatcher.hx" extern="1">
		<implements path="flash.events.IEventDispatcher"/>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Void"/>
</f></removeEventListener>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addEventListener>
		<new public="1" set="method"><f a="?target">
	<c path="flash.events.IEventDispatcher"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.display.IBitmapDrawable" params="" file="/usr/lib/haxe/std/flash/display/IBitmapDrawable.hx" extern="1" interface="1"/>
	<class path="flash.display.DisplayObject" params="" file="/usr/lib/haxe/std/flash/display/DisplayObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.display.IBitmapDrawable"/>
		<localToGlobal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></localToGlobal>
		<local3DToGlobal public="1" set="method">
			<f a="point3d">
				<c path="flash.geom.Vector3D"/>
				<c path="flash.geom.Point"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</local3DToGlobal>
		<hitTestPoint public="1" set="method"><f a="x:y:?shapeFlag">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></hitTestPoint>
		<hitTestObject public="1" set="method"><f a="obj">
	<c path="flash.display.DisplayObject"/>
	<x path="Bool"/>
</f></hitTestObject>
		<globalToLocal3D public="1" set="method">
			<f a="point">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Vector3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</globalToLocal3D>
		<globalToLocal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></globalToLocal>
		<getRect public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getRect>
		<getBounds public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getBounds>
		<z public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</z>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<width public="1"><x path="Float"/></width>
		<visible public="1"><x path="Bool"/></visible>
		<transform public="1"><c path="flash.geom.Transform"/></transform>
		<stage public="1" set="null"><c path="flash.display.Stage"/></stage>
		<scrollRect public="1"><c path="flash.geom.Rectangle"/></scrollRect>
		<scaleZ public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</scaleZ>
		<scaleY public="1"><x path="Float"/></scaleY>
		<scaleX public="1"><x path="Float"/></scaleX>
		<scale9Grid public="1"><c path="flash.geom.Rectangle"/></scale9Grid>
		<rotationZ public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationZ>
		<rotationY public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationY>
		<rotationX public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationX>
		<rotation public="1"><x path="Float"/></rotation>
		<root public="1" set="null"><c path="flash.display.DisplayObject"/></root>
		<parent public="1" set="null"><c path="flash.display.DisplayObjectContainer"/></parent>
		<opaqueBackground public="1"><t path="Null"><x path="UInt"/></t></opaqueBackground>
		<name public="1"><c path="String"/></name>
		<mouseY public="1" set="null"><x path="Float"/></mouseY>
		<mouseX public="1" set="null"><x path="Float"/></mouseX>
		<mask public="1"><c path="flash.display.DisplayObject"/></mask>
		<loaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></loaderInfo>
		<height public="1"><x path="Float"/></height>
		<filters public="1"><c path="Array"><c path="flash.filters.BitmapFilter"/></c></filters>
		<cacheAsBitmap public="1"><x path="Bool"/></cacheAsBitmap>
		<blendShader public="1" get="null">
			<c path="flash.display.Shader"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</blendShader>
		<blendMode public="1"><e path="flash.display.BlendMode"/></blendMode>
		<alpha public="1"><x path="Float"/></alpha>
		<accessibilityProperties public="1"><c path="flash.accessibility.AccessibilityProperties"/></accessibilityProperties>
	</class>
	<class path="flash.display.InteractiveObject" params="" file="/usr/lib/haxe/std/flash/display/InteractiveObject.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<requestSoftKeyboard public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</requestSoftKeyboard>
		<tabIndex public="1"><x path="Int"/></tabIndex>
		<tabEnabled public="1"><x path="Bool"/></tabEnabled>
		<softKeyboardInputAreaOfInterest public="1">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</softKeyboardInputAreaOfInterest>
		<needsSoftKeyboard public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</needsSoftKeyboard>
		<mouseEnabled public="1"><x path="Bool"/></mouseEnabled>
		<focusRect public="1"><d/></focusRect>
		<doubleClickEnabled public="1"><x path="Bool"/></doubleClickEnabled>
		<contextMenu public="1"><c path="flash.ui.ContextMenu"/></contextMenu>
		<accessibilityImplementation public="1"><c path="flash.accessibility.AccessibilityImplementation"/></accessibilityImplementation>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.DisplayObjectContainer" params="" file="/usr/lib/haxe/std/flash/display/DisplayObjectContainer.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<swapChildrenAt public="1" set="method"><f a="index1:index2">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swapChildrenAt>
		<swapChildren public="1" set="method"><f a="child1:child2">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
	<x path="Void"/>
</f></swapChildren>
		<setChildIndex public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setChildIndex>
		<removeChildren public="1" set="method">
			<f a="?beginIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</removeChildren>
		<removeChildAt public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChildAt>
		<removeChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChild>
		<getObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="flash.display.DisplayObject"/></c>
</f></getObjectsUnderPoint>
		<getChildIndex public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
</f></getChildIndex>
		<getChildByName public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildByName>
		<getChildAt public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildAt>
		<contains public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<x path="Bool"/>
</f></contains>
		<areInaccessibleObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<addChildAt public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></addChildAt>
		<addChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></addChild>
		<textSnapshot public="1" set="null"><c path="flash.text.TextSnapshot"/></textSnapshot>
		<tabChildren public="1"><x path="Bool"/></tabChildren>
		<numChildren public="1" set="null"><x path="Int"/></numChildren>
		<mouseChildren public="1"><x path="Bool"/></mouseChildren>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.Sprite" params="" file="/usr/lib/haxe/std/flash/display/Sprite.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<stopTouchDrag public="1" set="method">
			<f a="touchPointID">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</stopTouchDrag>
		<stopDrag public="1" set="method"><f a=""><x path="Void"/></f></stopDrag>
		<startTouchDrag public="1" set="method">
			<f a="touchPointID:?lockCenter:?bounds">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</startTouchDrag>
		<startDrag public="1" set="method"><f a="?lockCenter:?bounds">
	<x path="Bool"/>
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></startDrag>
		<useHandCursor public="1"><x path="Bool"/></useHandCursor>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<hitArea public="1"><c path="flash.display.Sprite"/></hitArea>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<dropTarget public="1" set="null"><c path="flash.display.DisplayObject"/></dropTarget>
		<buttonMode public="1"><x path="Bool"/></buttonMode>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.MovieClip" params="" file="/usr/lib/haxe/std/flash/display/MovieClip.hx" extern="1">
		<extends path="flash.display.Sprite"/>
		<stop public="1" set="method"><f a=""><x path="Void"/></f></stop>
		<prevScene public="1" set="method"><f a=""><x path="Void"/></f></prevScene>
		<prevFrame public="1" set="method"><f a=""><x path="Void"/></f></prevFrame>
		<play public="1" set="method"><f a=""><x path="Void"/></f></play>
		<nextScene public="1" set="method"><f a=""><x path="Void"/></f></nextScene>
		<nextFrame public="1" set="method"><f a=""><x path="Void"/></f></nextFrame>
		<gotoAndStop public="1" set="method"><f a="frame:?scene">
	<t path="flash.utils.Object"/>
	<c path="String"/>
	<x path="Void"/>
</f></gotoAndStop>
		<gotoAndPlay public="1" set="method"><f a="frame:?scene">
	<t path="flash.utils.Object"/>
	<c path="String"/>
	<x path="Void"/>
</f></gotoAndPlay>
		<addFrameScript public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></addFrameScript>
		<trackAsMenu public="1"><x path="Bool"/></trackAsMenu>
		<totalFrames public="1" set="null"><x path="Int"/></totalFrames>
		<scenes public="1" set="null"><c path="Array"><c path="flash.display.Scene"/></c></scenes>
		<isPlaying public="1" set="null">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</isPlaying>
		<framesLoaded public="1" set="null"><x path="Int"/></framesLoaded>
		<enabled public="1"><x path="Bool"/></enabled>
		<currentScene public="1" set="null"><c path="flash.display.Scene"/></currentScene>
		<currentLabels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></currentLabels>
		<currentLabel public="1" set="null"><c path="String"/></currentLabel>
		<currentFrameLabel public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</currentFrameLabel>
		<currentFrame public="1" set="null"><x path="Int"/></currentFrame>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Boot" params="" file="/usr/lib/haxe/std/flash/Boot.hx">
		<extends path="flash.display.MovieClip"/>
		<tf static="1"><c path="flash.text.TextField"/></tf>
		<lines static="1"><c path="Array"><c path="String"/></c></lines>
		<lastError static="1"><c path="flash.errors.Error"/></lastError>
		<skip_constructor public="1" line="51" static="1"><x path="Bool"/></skip_constructor>
		<enum_to_string public="1" set="method" line="83" static="1"><f a="e">
	<a>
		<tag><c path="String"/></tag>
		<params><c path="Array"><d/></c></params>
	</a>
	<c path="String"/>
</f></enum_to_string>
		<__instanceof public="1" set="method" line="92" static="1"><f a="v:t">
	<d/>
	<d/>
	<x path="Bool"/>
</f></__instanceof>
		<__clear_trace public="1" set="method" line="102" static="1"><f a=""><x path="Void"/></f></__clear_trace>
		<__set_trace_color public="1" set="method" line="110" static="1"><f a="rgb">
	<x path="UInt"/>
	<x path="Void"/>
</f></__set_trace_color>
		<getTrace public="1" set="method" line="116" static="1"><f a=""><c path="flash.text.TextField"/></f></getTrace>
		<__trace public="1" set="method" line="144" static="1"><f a="v:pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></__trace>
		<__string_rec public="1" set="method" line="159" static="1"><f a="v:str">
	<d/>
	<c path="String"/>
	<c path="String"/>
</f></__string_rec>
		<__unprotect__ set="method" line="204" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></__unprotect__>
		<init set="method" line="79"><f a=""><x path="Void"/></f></init>
		<doInitDelay set="method" line="74"><f a="_">
	<unknown/>
	<x path="Void"/>
</f></doInitDelay>
		<start set="method" line="53"><f a=""><x path="Void"/></f></start>
		<new public="1" set="method" line="45"><f a=""><x path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="flash._Boot.RealBoot" params="" file="/usr/lib/haxe/std/flash/Boot.hx" private="1" module="flash.Boot">
		<extends path="flash.Boot"/>
		<new set="method" line="35"><f a=""><x path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Lib" params="" file="/usr/lib/haxe/std/flash/Lib.hx">
		<current public="1" static="1"><c path="flash.display.MovieClip"/></current>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="flash.Memory" params="" file="/usr/lib/haxe/std/flash/Memory.hx" extern="1">
		<select public="1" get="inline" set="null" line="26" static="1"><f a="b">
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></select>
		<setByte public="1" get="inline" set="null" line="30" static="1"><f a="addr:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setByte>
		<setI16 public="1" get="inline" set="null" line="34" static="1"><f a="addr:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setI16>
		<setI32 public="1" get="inline" set="null" line="38" static="1"><f a="addr:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setI32>
		<setFloat public="1" get="inline" set="null" line="42" static="1"><f a="addr:v">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat>
		<setDouble public="1" get="inline" set="null" line="46" static="1"><f a="addr:v">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setDouble>
		<getByte public="1" get="inline" set="null" line="50" static="1"><f a="addr">
	<x path="Int"/>
	<x path="Int"/>
</f></getByte>
		<getUI16 public="1" get="inline" set="null" line="54" static="1"><f a="addr">
	<x path="Int"/>
	<x path="Int"/>
</f></getUI16>
		<getI32 public="1" get="inline" set="null" line="58" static="1"><f a="addr">
	<x path="Int"/>
	<x path="Int"/>
</f></getI32>
		<getFloat public="1" get="inline" set="null" line="62" static="1"><f a="addr">
	<x path="Int"/>
	<x path="Float"/>
</f></getFloat>
		<getDouble public="1" get="inline" set="null" line="66" static="1"><f a="addr">
	<x path="Int"/>
	<x path="Float"/>
</f></getDouble>
		<signExtend1 public="1" get="inline" set="null" line="70" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></signExtend1>
		<signExtend8 public="1" get="inline" set="null" line="74" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></signExtend8>
		<signExtend16 public="1" get="inline" set="null" line="78" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></signExtend16>
	</class>
	<class path="flash.Vector" params="T" file="/usr/lib/haxe/std/flash/Vector.hx" extern="1">
		<ofArray public="1" params="T" get="inline" set="null" line="47" static="1"><f a="v">
	<c path="Array"><c path="ofArray.T"/></c>
	<c path="flash.Vector"><c path="ofArray.T"/></c>
</f></ofArray>
		<convert public="1" params="T:U" get="inline" set="null" line="51" static="1"><f a="v">
	<c path="flash.Vector"><c path="convert.T"/></c>
	<c path="flash.Vector"><c path="convert.U"/></c>
</f></convert>
		<lastIndexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lastIndexOf>
		<indexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
	<x path="Int"/>
</f></indexOf>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<splice public="1" set="method"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></splice>
		<sort public="1" set="method"><f a="f">
	<f a=":">
		<c path="flash.Vector.T"/>
		<c path="flash.Vector.T"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></sort>
		<slice public="1" set="method"><f a="pos:?end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></slice>
		<unshift public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<x path="Void"/>
</f></unshift>
		<shift public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></shift>
		<reverse public="1" set="method"><f a=""><x path="Void"/></f></reverse>
		<push public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
</f></push>
		<pop public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></pop>
		<join public="1" set="method"><f a="sep">
	<c path="String"/>
	<c path="String"/>
</f></join>
		<concat public="1" set="method"><f a="?a">
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></concat>
		<fixed public="1"><x path="Bool"/></fixed>
		<length public="1"><x path="Int"/></length>
		<new public="1" set="method"><f a="?length:?fixed">
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>The Vector class is very similar to Array but is only supported by the Flash Player 10+</haxe_doc>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.accessibility.AccessibilityImplementation" params="" file="/usr/lib/haxe/std/flash/accessibility/AccessibilityImplementation.hx" extern="1">
		<isLabeledBy public="1" set="method"><f a="labelBounds">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></isLabeledBy>
		<get_selectionAnchorIndex public="1" set="method"><f a=""><d/></f></get_selectionAnchorIndex>
		<get_selectionActiveIndex public="1" set="method"><f a=""><d/></f></get_selectionActiveIndex>
		<get_accValue public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<c path="String"/>
</f></get_accValue>
		<get_accState public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<x path="UInt"/>
</f></get_accState>
		<get_accSelection public="1" set="method"><f a=""><c path="Array"><d/></c></f></get_accSelection>
		<get_accRole public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<x path="UInt"/>
</f></get_accRole>
		<get_accName public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<c path="String"/>
</f></get_accName>
		<get_accFocus public="1" set="method"><f a=""><x path="UInt"/></f></get_accFocus>
		<get_accDefaultAction public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<c path="String"/>
</f></get_accDefaultAction>
		<getChildIDArray public="1" set="method"><f a=""><c path="Array"><d/></c></f></getChildIDArray>
		<accSelect public="1" set="method"><f a="operation:childID">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></accSelect>
		<accLocation public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<d/>
</f></accLocation>
		<accDoDefaultAction public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<x path="Void"/>
</f></accDoDefaultAction>
		<stub public="1"><x path="Bool"/></stub>
		<errno public="1"><x path="UInt"/></errno>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.accessibility.AccessibilityProperties" params="" file="/usr/lib/haxe/std/flash/accessibility/AccessibilityProperties.hx" extern="1">
		<silent public="1"><x path="Bool"/></silent>
		<shortcut public="1"><c path="String"/></shortcut>
		<noAutoLabeling public="1"><x path="Bool"/></noAutoLabeling>
		<name public="1"><c path="String"/></name>
		<forceSimple public="1"><x path="Bool"/></forceSimple>
		<description public="1"><c path="String"/></description>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="flash.display.ActionScriptVersion" params="" file="/usr/lib/haxe/std/flash/display/ActionScriptVersion.hx">
		<ACTIONSCRIPT3/>
		<ACTIONSCRIPT2/>
		<meta><m n=":fakeEnum"><e>UInt</e></m></meta>
	</enum>
	<class path="flash.display.Bitmap" params="" file="/usr/lib/haxe/std/flash/display/Bitmap.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<smoothing public="1"><x path="Bool"/></smoothing>
		<pixelSnapping public="1"><e path="flash.display.PixelSnapping"/></pixelSnapping>
		<bitmapData public="1"><c path="flash.display.BitmapData"/></bitmapData>
		<new public="1" set="method"><f a="?bitmapData:?pixelSnapping:?smoothing">
	<c path="flash.display.BitmapData"/>
	<e path="flash.display.PixelSnapping"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.display.BitmapData" params="" file="/usr/lib/haxe/std/flash/display/BitmapData.hx" extern="1">
		<implements path="flash.display.IBitmapDrawable"/>
		<unlock public="1" set="method"><f a="?changeRect">
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></unlock>
		<threshold public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="String"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="UInt"/>
</f></threshold>
		<setVector public="1" set="method">
			<f a="rect:inputVector">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><x path="UInt"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</setVector>
		<setPixels public="1" set="method"><f a="rect:inputByteArray">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></setPixels>
		<setPixel32 public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setPixel32>
		<setPixel public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setPixel>
		<scroll public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scroll>
		<pixelDissolve public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?randomSeed:?numPixels:?fillColor">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Int"/>
</f></pixelDissolve>
		<perlinNoise public="1" set="method"><f a="baseX:baseY:numOctaves:randomSeed:stitch:fractalNoise:?channelOptions:?grayScale:?offsets">
	<x path="Float"/>
	<x path="Float"/>
	<x path="UInt"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<c path="Array"><c path="flash.geom.Point"/></c>
	<x path="Void"/>
</f></perlinNoise>
		<paletteMap public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?redArray:?greenArray:?blueArray:?alphaArray">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></paletteMap>
		<noise public="1" set="method"><f a="randomSeed:?low:?high:?channelOptions:?grayScale">
	<x path="Int"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></noise>
		<merge public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></merge>
		<lock public="1" set="method"><f a=""><x path="Void"/></f></lock>
		<hitTest public="1" set="method"><f a="firstPoint:firstAlphaThreshold:secondObject:?secondBitmapDataPoint:?secondAlphaThreshold">
	<c path="flash.geom.Point"/>
	<x path="UInt"/>
	<t path="flash.utils.Object"/>
	<c path="flash.geom.Point"/>
	<x path="UInt"/>
	<x path="Bool"/>
</f></hitTest>
		<histogram public="1" set="method">
			<f a="?hRect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><c path="flash.Vector"><x path="Float"/></c></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</histogram>
		<getVector public="1" set="method">
			<f a="rect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><x path="UInt"/></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getVector>
		<getPixels public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
</f></getPixels>
		<getPixel32 public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
</f></getPixel32>
		<getPixel public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
</f></getPixel>
		<getColorBoundsRect public="1" set="method"><f a="mask:color:?findColor">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<c path="flash.geom.Rectangle"/>
</f></getColorBoundsRect>
		<generateFilterRect public="1" set="method"><f a="sourceRect:filter">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.filters.BitmapFilter"/>
	<c path="flash.geom.Rectangle"/>
</f></generateFilterRect>
		<floodFill public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></floodFill>
		<fillRect public="1" set="method"><f a="rect:color">
	<c path="flash.geom.Rectangle"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></fillRect>
		<encode public="1">
			<f a="rect:compressor:?byteArray">
				<c path="flash.geom.Rectangle"/>
				<t path="flash.utils.Object"/>
				<c path="flash.utils.ByteArray"/>
				<c path="flash.utils.ByteArray"/>
			</f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</encode>
		<drawWithQuality public="1">
			<f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing:?quality">
				<c path="flash.display.IBitmapDrawable"/>
				<c path="flash.geom.Matrix"/>
				<c path="flash.geom.ColorTransform"/>
				<e path="flash.display.BlendMode"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Bool"/>
				<e path="flash.display.StageQuality"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</drawWithQuality>
		<draw public="1" set="method"><f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing">
	<c path="flash.display.IBitmapDrawable"/>
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="flash.display.BlendMode"/>
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></draw>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<copyPixelsToByteArray public="1">
			<f a="rect:data">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.utils.ByteArray"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</copyPixelsToByteArray>
		<copyPixels public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></copyPixels>
		<copyChannel public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></copyChannel>
		<compare public="1" set="method"><f a="otherBitmapData">
	<c path="flash.display.BitmapData"/>
	<t path="flash.utils.Object"/>
</f></compare>
		<colorTransform public="1" set="method"><f a="rect:colorTransform">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.ColorTransform"/>
	<x path="Void"/>
</f></colorTransform>
		<clone public="1" set="method"><f a=""><c path="flash.display.BitmapData"/></f></clone>
		<applyFilter public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:filter">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.filters.BitmapFilter"/>
	<x path="Void"/>
</f></applyFilter>
		<width public="1" set="null"><x path="Int"/></width>
		<transparent public="1" set="null"><x path="Bool"/></transparent>
		<rect public="1" set="null"><c path="flash.geom.Rectangle"/></rect>
		<height public="1" set="null"><x path="Int"/></height>
		<new public="1" set="method"><f a="width:height:?transparent:?fillColor">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.BlendMode" params="" file="/usr/lib/haxe/std/flash/display/BlendMode.hx">
		<SUBTRACT/>
		<SHADER/>
		<SCREEN/>
		<OVERLAY/>
		<NORMAL/>
		<MULTIPLY/>
		<LIGHTEN/>
		<LAYER/>
		<INVERT/>
		<HARDLIGHT/>
		<ERASE/>
		<DIFFERENCE/>
		<DARKEN/>
		<ALPHA/>
		<ADD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.CapsStyle" params="" file="/usr/lib/haxe/std/flash/display/CapsStyle.hx">
		<SQUARE/>
		<ROUND/>
		<NONE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.ColorCorrection" params="" file="/usr/lib/haxe/std/flash/display/ColorCorrection.hx">
		<ON/>
		<OFF/>
		<DEFAULT/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<enum path="flash.display.ColorCorrectionSupport" params="" file="/usr/lib/haxe/std/flash/display/ColorCorrectionSupport.hx">
		<UNSUPPORTED/>
		<DEFAULT_ON/>
		<DEFAULT_OFF/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<class path="flash.display.FrameLabel" params="" file="/usr/lib/haxe/std/flash/display/FrameLabel.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<name public="1" set="null"><c path="String"/></name>
		<frame public="1" set="null"><x path="Int"/></frame>
		<new public="1" set="method"><f a="name:frame">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GradientType" params="" file="/usr/lib/haxe/std/flash/display/GradientType.hx">
		<RADIAL/>
		<LINEAR/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Graphics" params="" file="/usr/lib/haxe/std/flash/display/Graphics.hx" extern="1">
		<moveTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<lineTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<lineStyle public="1" set="method"><f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit">
	<x path="Float"/>
	<x path="UInt"/>
	<x path="Float"/>
	<x path="Bool"/>
	<e path="flash.display.LineScaleMode"/>
	<e path="flash.display.CapsStyle"/>
	<e path="flash.display.JointStyle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineStyle>
		<lineShaderStyle public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</lineShaderStyle>
		<lineGradientStyle public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><x path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineGradientStyle>
		<lineBitmapStyle public="1" set="method">
			<f a="bitmap:?matrix:?repeat:?smooth">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Matrix"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</lineBitmapStyle>
		<endFill public="1" set="method"><f a=""><x path="Void"/></f></endFill>
		<drawTriangles public="1" set="method">
			<f a="vertices:?indices:?uvtData:?culling">
				<c path="flash.Vector"><x path="Float"/></c>
				<c path="flash.Vector"><x path="Int"/></c>
				<c path="flash.Vector"><x path="Float"/></c>
				<e path="flash.display.TriangleCulling"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawTriangles>
		<drawRoundRectComplex public="1" set="method"><f a="x:y:width:height:topLeftRadius:topRightRadius:bottomLeftRadius:bottomRightRadius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRoundRectComplex>
		<drawRoundRect public="1" set="method"><f a="x:y:width:height:ellipseWidth:?ellipseHeight">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRoundRect>
		<drawRect public="1" set="method"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRect>
		<drawPath public="1" set="method">
			<f a="commands:data:?winding">
				<c path="flash.Vector"><x path="Int"/></c>
				<c path="flash.Vector"><x path="Float"/></c>
				<e path="flash.display.GraphicsPathWinding"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawPath>
		<drawGraphicsData public="1" set="method">
			<f a="graphicsData">
				<c path="flash.Vector"><c path="flash.display.IGraphicsData"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawGraphicsData>
		<drawEllipse public="1" set="method"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawEllipse>
		<drawCircle public="1" set="method"><f a="x:y:radius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawCircle>
		<curveTo public="1" set="method"><f a="controlX:controlY:anchorX:anchorY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></curveTo>
		<cubicCurveTo public="1" set="method">
			<f a="controlX1:controlY1:controlX2:controlY2:anchorX:anchorY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</cubicCurveTo>
		<copyFrom public="1" set="method">
			<f a="sourceGraphics">
				<c path="flash.display.Graphics"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</copyFrom>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<beginShaderFill public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</beginShaderFill>
		<beginGradientFill public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><x path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<x path="Float"/>
	<x path="Void"/>
</f></beginGradientFill>
		<beginFill public="1" set="method"><f a="color:?alpha">
	<x path="UInt"/>
	<x path="Float"/>
	<x path="Void"/>
</f></beginFill>
		<beginBitmapFill public="1" set="method"><f a="bitmap:?matrix:?repeat:?smooth">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Matrix"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></beginBitmapFill>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GraphicsPathWinding" params="" file="/usr/lib/haxe/std/flash/display/GraphicsPathWinding.hx">
		<NON_ZERO/>
		<EVEN_ODD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.IGraphicsData" params="" file="/usr/lib/haxe/std/flash/display/IGraphicsData.hx" extern="1" interface="1"/>
	<enum path="flash.display.InterpolationMethod" params="" file="/usr/lib/haxe/std/flash/display/InterpolationMethod.hx">
		<RGB/>
		<LINEAR_RGB/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.JointStyle" params="" file="/usr/lib/haxe/std/flash/display/JointStyle.hx">
		<ROUND/>
		<MITER/>
		<BEVEL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.LineScaleMode" params="" file="/usr/lib/haxe/std/flash/display/LineScaleMode.hx">
		<VERTICAL/>
		<NORMAL/>
		<NONE/>
		<HORIZONTAL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Loader" params="" file="/usr/lib/haxe/std/flash/display/Loader.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<unloadAndStop public="1" set="method">
			<f a="?gc">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</unloadAndStop>
		<unload public="1" set="method"><f a=""><x path="Void"/></f></unload>
		<loadBytes public="1" set="method"><f a="bytes:?context">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.system.LoaderContext"/>
	<x path="Void"/>
</f></loadBytes>
		<load public="1" set="method"><f a="request:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.system.LoaderContext"/>
	<x path="Void"/>
</f></load>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<uncaughtErrorEvents public="1" set="null">
			<c path="flash.events.UncaughtErrorEvents"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</uncaughtErrorEvents>
		<contentLoaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></contentLoaderInfo>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.LoaderInfo" params="" file="/usr/lib/haxe/std/flash/display/LoaderInfo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<getLoaderInfoByDefinition public="1" set="method" static="1"><f a="object">
	<d/>
	<c path="flash.display.LoaderInfo"/>
</f></getLoaderInfoByDefinition>
		<width public="1" set="null"><x path="Int"/></width>
		<url public="1" set="null"><c path="String"/></url>
		<uncaughtErrorEvents public="1" set="null">
			<c path="flash.events.UncaughtErrorEvents"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</uncaughtErrorEvents>
		<swfVersion public="1" set="null"><x path="UInt"/></swfVersion>
		<sharedEvents public="1" set="null"><c path="flash.events.EventDispatcher"/></sharedEvents>
		<sameDomain public="1" set="null"><x path="Bool"/></sameDomain>
		<parentSandboxBridge public="1">
			<d/>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</parentSandboxBridge>
		<parentAllowsChild public="1" set="null"><x path="Bool"/></parentAllowsChild>
		<parameters public="1" set="null"><d><c path="String"/></d></parameters>
		<loaderURL public="1" set="null"><c path="String"/></loaderURL>
		<loader public="1" set="null"><c path="flash.display.Loader"/></loader>
		<isURLInaccessible public="1" set="null">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isURLInaccessible>
		<height public="1" set="null"><x path="Int"/></height>
		<frameRate public="1" set="null"><x path="Float"/></frameRate>
		<contentType public="1" set="null"><c path="String"/></contentType>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<childSandboxBridge public="1">
			<d/>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</childSandboxBridge>
		<childAllowsParent public="1" set="null"><x path="Bool"/></childAllowsParent>
		<bytesTotal public="1" set="null"><x path="UInt"/></bytesTotal>
		<bytesLoaded public="1" set="null"><x path="UInt"/></bytesLoaded>
		<bytes public="1" set="null"><c path="flash.utils.ByteArray"/></bytes>
		<applicationDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<actionScriptVersion public="1" set="null"><e path="flash.display.ActionScriptVersion"/></actionScriptVersion>
	</class>
	<class path="flash.display.NativeMenu" params="" file="/usr/lib/haxe/std/flash/display/NativeMenu.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<enum path="flash.display.PixelSnapping" params="" file="/usr/lib/haxe/std/flash/display/PixelSnapping.hx">
		<NEVER/>
		<AUTO/>
		<ALWAYS/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Scene" params="" file="/usr/lib/haxe/std/flash/display/Scene.hx" extern="1">
		<numFrames public="1" set="null"><x path="Int"/></numFrames>
		<name public="1" set="null"><c path="String"/></name>
		<labels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></labels>
		<new public="1" set="method"><f a="name:labels:numFrames">
	<c path="String"/>
	<c path="Array"><c path="flash.display.FrameLabel"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display.Shader" params="" file="/usr/lib/haxe/std/flash/display/Shader.hx" extern="1">
		<precisionHint public="1"><e path="flash.display.ShaderPrecision"/></precisionHint>
		<data public="1"><c path="flash.display.ShaderData"/></data>
		<byteCode public="1" get="null"><c path="flash.utils.ByteArray"/></byteCode>
		<new public="1" set="method"><f a="?code">
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.display.ShaderData" params="" file="/usr/lib/haxe/std/flash/display/ShaderData.hx" extern="1">
		<new public="1" set="method"><f a="byteCode">
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.display.ShaderPrecision" params="" file="/usr/lib/haxe/std/flash/display/ShaderPrecision.hx">
		<FULL/>
		<FAST/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Shape" params="" file="/usr/lib/haxe/std/flash/display/Shape.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="flash.display.SpreadMethod" params="" file="/usr/lib/haxe/std/flash/display/SpreadMethod.hx">
		<REPEAT/>
		<REFLECT/>
		<PAD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Stage" params="" file="/usr/lib/haxe/std/flash/display/Stage.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<isFocusInaccessible public="1" set="method"><f a=""><x path="Bool"/></f></isFocusInaccessible>
		<invalidate public="1" set="method"><f a=""><x path="Void"/></f></invalidate>
		<wmodeGPU public="1" set="null">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</wmodeGPU>
		<stageWidth public="1"><x path="Int"/></stageWidth>
		<stageVideos public="1" set="null">
			<c path="flash.Vector"><c path="flash.media.StageVideo"/></c>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</stageVideos>
		<stageHeight public="1"><x path="Int"/></stageHeight>
		<stageFocusRect public="1"><x path="Bool"/></stageFocusRect>
		<stage3Ds public="1" set="null">
			<c path="flash.Vector"><c path="flash.display.Stage3D"/></c>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</stage3Ds>
		<softKeyboardRect public="1" set="null">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</softKeyboardRect>
		<showDefaultContextMenu public="1"><x path="Bool"/></showDefaultContextMenu>
		<scaleMode public="1"><e path="flash.display.StageScaleMode"/></scaleMode>
		<quality public="1"><e path="flash.display.StageQuality"/></quality>
		<mouseLock public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</mouseLock>
		<fullScreenWidth public="1" set="null"><x path="UInt"/></fullScreenWidth>
		<fullScreenSourceRect public="1"><c path="flash.geom.Rectangle"/></fullScreenSourceRect>
		<fullScreenHeight public="1" set="null"><x path="UInt"/></fullScreenHeight>
		<frameRate public="1"><x path="Float"/></frameRate>
		<focus public="1"><c path="flash.display.InteractiveObject"/></focus>
		<displayState public="1"><e path="flash.display.StageDisplayState"/></displayState>
		<displayContextInfo public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</displayContextInfo>
		<contentsScaleFactor public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</contentsScaleFactor>
		<colorCorrectionSupport public="1" set="null">
			<e path="flash.display.ColorCorrectionSupport"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</colorCorrectionSupport>
		<colorCorrection public="1">
			<e path="flash.display.ColorCorrection"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</colorCorrection>
		<color public="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</color>
		<allowsFullScreenInteractive public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</allowsFullScreenInteractive>
		<allowsFullScreen public="1" set="null">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</allowsFullScreen>
		<align public="1"><e path="flash.display.StageAlign"/></align>
	</class>
	<class path="flash.display.Stage3D" params="" file="/usr/lib/haxe/std/flash/display/Stage3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<requestContext3D public="1" set="method"><f a="?context3DRenderMode:?profile">
	<c path="String"/>
	<e path="flash.display3D.Context3DProfile"/>
	<x path="Void"/>
</f></requestContext3D>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<visible public="1"><x path="Bool"/></visible>
		<context3D public="1" set="null"><c path="flash.display3D.Context3D"/></context3D>
		<meta><m n=":require"><e>flash11</e></m></meta>
	</class>
	<enum path="flash.display.StageAlign" params="" file="/usr/lib/haxe/std/flash/display/StageAlign.hx">
		<TOP_RIGHT/>
		<TOP_LEFT/>
		<TOP/>
		<RIGHT/>
		<LEFT/>
		<BOTTOM_RIGHT/>
		<BOTTOM_LEFT/>
		<BOTTOM/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageDisplayState" params="" file="/usr/lib/haxe/std/flash/display/StageDisplayState.hx">
		<NORMAL/>
		<FULL_SCREEN_INTERACTIVE/>
		<FULL_SCREEN/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageQuality" params="" file="/usr/lib/haxe/std/flash/display/StageQuality.hx">
		<MEDIUM/>
		<LOW/>
		<HIGH_8X8_LINEAR/>
		<HIGH_8X8/>
		<HIGH_16X16_LINEAR/>
		<HIGH_16X16/>
		<HIGH/>
		<BEST/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageScaleMode" params="" file="/usr/lib/haxe/std/flash/display/StageScaleMode.hx">
		<SHOW_ALL/>
		<NO_SCALE/>
		<NO_BORDER/>
		<EXACT_FIT/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.TriangleCulling" params="" file="/usr/lib/haxe/std/flash/display/TriangleCulling.hx">
		<POSITIVE/>
		<NONE/>
		<NEGATIVE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display3D.Context3D" params="" file="/usr/lib/haxe/std/flash/display3D/Context3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<setVertexBufferAt public="1" set="method"><f a="index:buffer:?bufferOffset:?format">
	<x path="Int"/>
	<c path="flash.display3D.VertexBuffer3D"/>
	<x path="Int"/>
	<e path="flash.display3D.Context3DVertexBufferFormat"/>
	<x path="Void"/>
</f></setVertexBufferAt>
		<setTextureAt public="1" set="method"><f a="sampler:texture">
	<x path="Int"/>
	<c path="flash.display3D.textures.TextureBase"/>
	<x path="Void"/>
</f></setTextureAt>
		<setStencilReferenceValue public="1" set="method"><f a="referenceValue:?readMask:?writeMask">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setStencilReferenceValue>
		<setStencilActions public="1" set="method"><f a="?triangleFace:?compareMode:?actionOnBothPass:?actionOnDepthFail:?actionOnDepthPassStencilFail">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<x path="Void"/>
</f></setStencilActions>
		<setScissorRectangle public="1" set="method"><f a="rectangle">
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></setScissorRectangle>
		<setRenderToTexture public="1" set="method"><f a="texture:?enableDepthAndStencil:?antiAlias:?surfaceSelector:?colorOutputIndex">
	<c path="flash.display3D.textures.TextureBase"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setRenderToTexture>
		<setRenderToBackBuffer public="1" set="method"><f a=""><x path="Void"/></f></setRenderToBackBuffer>
		<setProgramConstantsFromVector public="1" set="method"><f a="programType:firstRegister:data:?numRegisters">
	<e path="flash.display3D.Context3DProgramType"/>
	<x path="Int"/>
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></setProgramConstantsFromVector>
		<setProgramConstantsFromMatrix public="1" set="method"><f a="programType:firstRegister:matrix:?transposedMatrix">
	<e path="flash.display3D.Context3DProgramType"/>
	<x path="Int"/>
	<c path="flash.geom.Matrix3D"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setProgramConstantsFromMatrix>
		<setProgramConstantsFromByteArray public="1" set="method">
			<f a="programType:firstRegister:numRegisters:data:byteArrayOffset">
				<e path="flash.display3D.Context3DProgramType"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</setProgramConstantsFromByteArray>
		<setProgram public="1" set="method"><f a="program">
	<c path="flash.display3D.Program3D"/>
	<x path="Void"/>
</f></setProgram>
		<setDepthTest public="1" set="method"><f a="depthMask:passCompareMode">
	<x path="Bool"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<x path="Void"/>
</f></setDepthTest>
		<setCulling public="1" set="method"><f a="triangleFaceToCull">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<x path="Void"/>
</f></setCulling>
		<setColorMask public="1" set="method"><f a="red:green:blue:alpha">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setColorMask>
		<setBlendFactors public="1" set="method"><f a="sourceFactor:destinationFactor">
	<e path="flash.display3D.Context3DBlendFactor"/>
	<e path="flash.display3D.Context3DBlendFactor"/>
	<x path="Void"/>
</f></setBlendFactors>
		<present public="1" set="method"><f a=""><x path="Void"/></f></present>
		<drawTriangles public="1" set="method"><f a="indexBuffer:?firstIndex:?numTriangles">
	<c path="flash.display3D.IndexBuffer3D"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawTriangles>
		<drawToBitmapData public="1" set="method"><f a="destination">
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></drawToBitmapData>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<createVertexBuffer public="1" set="method"><f a="numVertices:data32PerVertex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.display3D.VertexBuffer3D"/>
</f></createVertexBuffer>
		<createTexture public="1" set="method"><f a="width:height:format:optimizeForRenderToTexture:?streamingLevels">
	<x path="Int"/>
	<x path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<x path="Bool"/>
	<x path="Int"/>
	<c path="flash.display3D.textures.Texture"/>
</f></createTexture>
		<createRectangleTexture public="1">
			<f a="width:height:format:optimizeForRenderToTexture">
				<x path="Int"/>
				<x path="Int"/>
				<e path="flash.display3D.Context3DTextureFormat"/>
				<x path="Bool"/>
				<c path="flash.display3D.textures.RectangleTexture"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</createRectangleTexture>
		<createProgram public="1" set="method"><f a=""><c path="flash.display3D.Program3D"/></f></createProgram>
		<createIndexBuffer public="1" set="method"><f a="numIndices">
	<x path="Int"/>
	<c path="flash.display3D.IndexBuffer3D"/>
</f></createIndexBuffer>
		<createCubeTexture public="1" set="method"><f a="size:format:optimizeForRenderToTexture:?streamingLevels">
	<x path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<x path="Bool"/>
	<x path="Int"/>
	<c path="flash.display3D.textures.CubeTexture"/>
</f></createCubeTexture>
		<configureBackBuffer public="1" set="method"><f a="width:height:antiAlias:?enableDepthAndStencil:?wantsBestResolution">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></configureBackBuffer>
		<clear public="1" set="method"><f a="?red:?green:?blue:?alpha:?depth:?stencil:?mask">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></clear>
		<enableErrorChecking public="1"><x path="Bool"/></enableErrorChecking>
		<driverInfo public="1" set="null"><c path="String"/></driverInfo>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display3D.Context3DBlendFactor" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DBlendFactor.hx">
		<ZERO/>
		<SOURCE_COLOR/>
		<SOURCE_ALPHA/>
		<ONE_MINUS_SOURCE_COLOR/>
		<ONE_MINUS_SOURCE_ALPHA/>
		<ONE_MINUS_DESTINATION_COLOR/>
		<ONE_MINUS_DESTINATION_ALPHA/>
		<ONE/>
		<DESTINATION_COLOR/>
		<DESTINATION_ALPHA/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DCompareMode" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DCompareMode.hx">
		<NOT_EQUAL/>
		<NEVER/>
		<LESS_EQUAL/>
		<LESS/>
		<GREATER_EQUAL/>
		<GREATER/>
		<EQUAL/>
		<ALWAYS/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DProfile" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DProfile.hx">
		<BASELINE_EXTENDED/>
		<BASELINE_CONSTRAINED/>
		<BASELINE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DProgramType" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DProgramType.hx">
		<VERTEX/>
		<FRAGMENT/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DStencilAction" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DStencilAction.hx">
		<ZERO/>
		<SET/>
		<KEEP/>
		<INVERT/>
		<INCREMENT_WRAP/>
		<INCREMENT_SATURATE/>
		<DECREMENT_WRAP/>
		<DECREMENT_SATURATE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DTextureFormat" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DTextureFormat.hx">
		<COMPRESSED_ALPHA/>
		<COMPRESSED/>
		<BGRA/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DTriangleFace" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DTriangleFace.hx">
		<NONE/>
		<FRONT_AND_BACK/>
		<FRONT/>
		<BACK/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DVertexBufferFormat" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DVertexBufferFormat.hx">
		<FLOAT_4/>
		<FLOAT_3/>
		<FLOAT_2/>
		<FLOAT_1/>
		<BYTES_4/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display3D.IndexBuffer3D" params="" file="/usr/lib/haxe/std/flash/display3D/IndexBuffer3D.hx" extern="1">
		<uploadFromVector public="1" set="method"><f a="data:startOffset:count">
	<c path="flash.Vector"><x path="UInt"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromVector>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startOffset:count">
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.Program3D" params="" file="/usr/lib/haxe/std/flash/display3D/Program3D.hx" extern="1">
		<upload public="1" set="method"><f a="vertexProgram:fragmentProgram">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></upload>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.VertexBuffer3D" params="" file="/usr/lib/haxe/std/flash/display3D/VertexBuffer3D.hx" extern="1">
		<uploadFromVector public="1" set="method"><f a="data:startVertex:numVertices">
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromVector>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startVertex:numVertices">
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
	</class>
	<class path="flash.display3D.textures.TextureBase" params="" file="/usr/lib/haxe/std/flash/display3D/textures/TextureBase.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
	</class>
	<class path="flash.display3D.textures.CubeTexture" params="" file="/usr/lib/haxe/std/flash/display3D/textures/CubeTexture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:side:?miplevel">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source:side:?miplevel">
	<c path="flash.display.BitmapData"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></uploadFromBitmapData>
		<uploadCompressedTextureFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?async">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></uploadCompressedTextureFromByteArray>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.textures.RectangleTexture" params="" file="/usr/lib/haxe/std/flash/display3D/textures/RectangleTexture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source">
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></uploadFromBitmapData>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.textures.Texture" params="" file="/usr/lib/haxe/std/flash/display3D/textures/Texture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?miplevel">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source:?miplevel">
	<c path="flash.display.BitmapData"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></uploadFromBitmapData>
		<uploadCompressedTextureFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?async">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></uploadCompressedTextureFromByteArray>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.errors.Error" params="" file="/usr/lib/haxe/std/flash/errors/Error.hx" extern="1">
		<length public="1" static="1"><x path="Int"/></length>
		<getErrorMessage public="1" set="method" static="1"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></getErrorMessage>
		<throwError public="1" set="method" static="1"><f a="type:index:?p1:?p2:?p3:?p4:?p5">
	<x path="Class"><d/></x>
	<x path="UInt"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></throwError>
		<getStackTrace public="1" set="method"><f a=""><c path="String"/></f></getStackTrace>
		<name public="1"><d/></name>
		<message public="1"><d/></message>
		<errorID public="1" set="null"><x path="Int"/></errorID>
		<new public="1" set="method"><f a="?message:?id">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.events.Event" params="" file="/usr/lib/haxe/std/flash/events/Event.hx" extern="1">
		<ACTIVATE public="1" static="1"><c path="String"/></ACTIVATE>
		<ADDED public="1" static="1"><c path="String"/></ADDED>
		<ADDED_TO_STAGE public="1" static="1"><c path="String"/></ADDED_TO_STAGE>
		<CANCEL public="1" static="1"><c path="String"/></CANCEL>
		<CHANGE public="1" static="1"><c path="String"/></CHANGE>
		<CHANNEL_MESSAGE public="1" static="1"><c path="String"/></CHANNEL_MESSAGE>
		<CHANNEL_STATE public="1" static="1"><c path="String"/></CHANNEL_STATE>
		<CLEAR public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CLEAR>
		<CLOSE public="1" static="1"><c path="String"/></CLOSE>
		<COMPLETE public="1" static="1"><c path="String"/></COMPLETE>
		<CONNECT public="1" static="1"><c path="String"/></CONNECT>
		<CONTEXT3D_CREATE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</CONTEXT3D_CREATE>
		<COPY public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</COPY>
		<CUT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CUT>
		<DEACTIVATE public="1" static="1"><c path="String"/></DEACTIVATE>
		<ENTER_FRAME public="1" static="1"><c path="String"/></ENTER_FRAME>
		<EXIT_FRAME public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</EXIT_FRAME>
		<FRAME_CONSTRUCTED public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</FRAME_CONSTRUCTED>
		<FRAME_LABEL public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</FRAME_LABEL>
		<FULLSCREEN public="1" static="1"><c path="String"/></FULLSCREEN>
		<ID3 public="1" static="1"><c path="String"/></ID3>
		<INIT public="1" static="1"><c path="String"/></INIT>
		<MOUSE_LEAVE public="1" static="1"><c path="String"/></MOUSE_LEAVE>
		<OPEN public="1" static="1"><c path="String"/></OPEN>
		<PASTE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</PASTE>
		<REMOVED public="1" static="1"><c path="String"/></REMOVED>
		<REMOVED_FROM_STAGE public="1" static="1"><c path="String"/></REMOVED_FROM_STAGE>
		<RENDER public="1" static="1"><c path="String"/></RENDER>
		<RESIZE public="1" static="1"><c path="String"/></RESIZE>
		<SCROLL public="1" static="1"><c path="String"/></SCROLL>
		<SELECT public="1" static="1"><c path="String"/></SELECT>
		<SELECT_ALL public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</SELECT_ALL>
		<SOUND_COMPLETE public="1" static="1"><c path="String"/></SOUND_COMPLETE>
		<SUSPEND public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</SUSPEND>
		<TAB_CHILDREN_CHANGE public="1" static="1"><c path="String"/></TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE public="1" static="1"><c path="String"/></TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE public="1" static="1"><c path="String"/></TAB_INDEX_CHANGE>
		<TEXTURE_READY public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</TEXTURE_READY>
		<TEXT_INTERACTION_MODE_CHANGE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</TEXT_INTERACTION_MODE_CHANGE>
		<UNLOAD public="1" static="1"><c path="String"/></UNLOAD>
		<VIDEO_FRAME public="1" static="1"><c path="String"/></VIDEO_FRAME>
		<WORKER_STATE public="1" static="1"><c path="String"/></WORKER_STATE>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<stopPropagation public="1" set="method"><f a=""><x path="Void"/></f></stopPropagation>
		<stopImmediatePropagation public="1" set="method"><f a=""><x path="Void"/></f></stopImmediatePropagation>
		<preventDefault public="1" set="method"><f a=""><x path="Void"/></f></preventDefault>
		<isDefaultPrevented public="1" set="method"><f a=""><x path="Bool"/></f></isDefaultPrevented>
		<formatToString public="1" set="method"><f a="className:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="String"/>
</f></formatToString>
		<clone public="1" set="method"><f a=""><c path="flash.events.Event"/></f></clone>
		<type public="1" set="null"><c path="String"/></type>
		<target public="1" set="null"><d/></target>
		<eventPhase public="1" set="null"><e path="flash.events.EventPhase"/></eventPhase>
		<currentTarget public="1" set="null"><d/></currentTarget>
		<cancelable public="1" set="null"><x path="Bool"/></cancelable>
		<bubbles public="1" set="null"><x path="Bool"/></bubbles>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.TextEvent" params="" file="/usr/lib/haxe/std/flash/events/TextEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<LINK public="1" static="1"><c path="String"/></LINK>
		<TEXT_INPUT public="1" static="1"><c path="String"/></TEXT_INPUT>
		<text public="1"><c path="String"/></text>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.ErrorEvent" params="" file="/usr/lib/haxe/std/flash/events/ErrorEvent.hx" extern="1">
		<extends path="flash.events.TextEvent"/>
		<ERROR public="1" static="1"><c path="String"/></ERROR>
		<errorID public="1" set="null">
			<x path="Int"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</errorID>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text:?id">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="flash.events.EventPhase" params="" file="/usr/lib/haxe/std/flash/events/EventPhase.hx">
		<CAPTURING_PHASE/>
		<BUBBLING_PHASE/>
		<AT_TARGET/>
		<meta><m n=":fakeEnum"><e>UInt</e></m></meta>
	</enum>
	<class path="flash.events.IOErrorEvent" params="" file="/usr/lib/haxe/std/flash/events/IOErrorEvent.hx" extern="1">
		<extends path="flash.events.ErrorEvent"/>
		<DISK_ERROR public="1" static="1"><c path="String"/></DISK_ERROR>
		<IO_ERROR public="1" static="1"><c path="String"/></IO_ERROR>
		<NETWORK_ERROR public="1" static="1"><c path="String"/></NETWORK_ERROR>
		<VERIFY_ERROR public="1" static="1"><c path="String"/></VERIFY_ERROR>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text:?id">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.KeyboardEvent" params="" file="/usr/lib/haxe/std/flash/events/KeyboardEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<KEY_DOWN public="1" static="1"><c path="String"/></KEY_DOWN>
		<KEY_UP public="1" static="1"><c path="String"/></KEY_UP>
		<updateAfterEvent public="1" set="method"><f a=""><x path="Void"/></f></updateAfterEvent>
		<shiftKey public="1"><x path="Bool"/></shiftKey>
		<keyLocation public="1"><e path="flash.ui.KeyLocation"/></keyLocation>
		<keyCode public="1"><x path="UInt"/></keyCode>
		<ctrlKey public="1"><x path="Bool"/></ctrlKey>
		<charCode public="1"><x path="UInt"/></charCode>
		<altKey public="1"><x path="Bool"/></altKey>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?charCodeValue:?keyCodeValue:?keyLocationValue:?ctrlKeyValue:?altKeyValue:?shiftKeyValue">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<e path="flash.ui.KeyLocation"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.MouseEvent" params="" file="/usr/lib/haxe/std/flash/events/MouseEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<CLICK public="1" static="1"><c path="String"/></CLICK>
		<CONTEXT_MENU public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</CONTEXT_MENU>
		<DOUBLE_CLICK public="1" static="1"><c path="String"/></DOUBLE_CLICK>
		<MIDDLE_CLICK public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</MIDDLE_CLICK>
		<MIDDLE_MOUSE_DOWN public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</MIDDLE_MOUSE_DOWN>
		<MIDDLE_MOUSE_UP public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</MIDDLE_MOUSE_UP>
		<MOUSE_DOWN public="1" static="1"><c path="String"/></MOUSE_DOWN>
		<MOUSE_MOVE public="1" static="1"><c path="String"/></MOUSE_MOVE>
		<MOUSE_OUT public="1" static="1"><c path="String"/></MOUSE_OUT>
		<MOUSE_OVER public="1" static="1"><c path="String"/></MOUSE_OVER>
		<MOUSE_UP public="1" static="1"><c path="String"/></MOUSE_UP>
		<MOUSE_WHEEL public="1" static="1"><c path="String"/></MOUSE_WHEEL>
		<RELEASE_OUTSIDE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</RELEASE_OUTSIDE>
		<RIGHT_CLICK public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</RIGHT_CLICK>
		<RIGHT_MOUSE_DOWN public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</RIGHT_MOUSE_DOWN>
		<RIGHT_MOUSE_UP public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</RIGHT_MOUSE_UP>
		<ROLL_OUT public="1" static="1"><c path="String"/></ROLL_OUT>
		<ROLL_OVER public="1" static="1"><c path="String"/></ROLL_OVER>
		<updateAfterEvent public="1" set="method"><f a=""><x path="Void"/></f></updateAfterEvent>
		<stageY public="1" set="null"><x path="Float"/></stageY>
		<stageX public="1" set="null"><x path="Float"/></stageX>
		<shiftKey public="1"><x path="Bool"/></shiftKey>
		<relatedObject public="1"><c path="flash.display.InteractiveObject"/></relatedObject>
		<movementY public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</movementY>
		<movementX public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</movementX>
		<localY public="1"><x path="Float"/></localY>
		<localX public="1"><x path="Float"/></localX>
		<isRelatedObjectInaccessible public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</isRelatedObjectInaccessible>
		<delta public="1"><x path="Int"/></delta>
		<ctrlKey public="1"><x path="Bool"/></ctrlKey>
		<buttonDown public="1"><x path="Bool"/></buttonDown>
		<altKey public="1"><x path="Bool"/></altKey>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?localX:?localY:?relatedObject:?ctrlKey:?altKey:?shiftKey:?buttonDown:?delta">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="flash.display.InteractiveObject"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.ProgressEvent" params="" file="/usr/lib/haxe/std/flash/events/ProgressEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<PROGRESS public="1" static="1"><c path="String"/></PROGRESS>
		<SOCKET_DATA public="1" static="1"><c path="String"/></SOCKET_DATA>
		<bytesTotal public="1"><x path="Float"/></bytesTotal>
		<bytesLoaded public="1"><x path="Float"/></bytesLoaded>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?bytesLoaded:?bytesTotal">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.SecurityErrorEvent" params="" file="/usr/lib/haxe/std/flash/events/SecurityErrorEvent.hx" extern="1">
		<extends path="flash.events.ErrorEvent"/>
		<SECURITY_ERROR public="1" static="1"><c path="String"/></SECURITY_ERROR>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text:?id">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.UncaughtErrorEvents" params="" file="/usr/lib/haxe/std/flash/events/UncaughtErrorEvents.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.external.ExternalInterface" params="" file="/usr/lib/haxe/std/flash/external/ExternalInterface.hx" extern="1">
		<available public="1" set="null" static="1"><x path="Bool"/></available>
		<marshallExceptions public="1" static="1"><x path="Bool"/></marshallExceptions>
		<objectID public="1" set="null" static="1"><c path="String"/></objectID>
		<addCallback public="1" set="method" static="1"><f a="functionName:closure">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></addCallback>
		<call public="1" set="method" static="1"><f a="functionName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></call>
	</class>
	<class path="flash.filters.BitmapFilter" params="" file="/usr/lib/haxe/std/flash/filters/BitmapFilter.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.filters.GlowFilter" params="" file="/usr/lib/haxe/std/flash/filters/GlowFilter.hx" extern="1">
		<extends path="flash.filters.BitmapFilter"/>
		<strength public="1"><x path="Float"/></strength>
		<quality public="1"><x path="Int"/></quality>
		<knockout public="1"><x path="Bool"/></knockout>
		<inner public="1"><x path="Bool"/></inner>
		<color public="1"><x path="UInt"/></color>
		<blurY public="1"><x path="Float"/></blurY>
		<blurX public="1"><x path="Float"/></blurX>
		<alpha public="1"><x path="Float"/></alpha>
		<new public="1" set="method"><f a="?color:?alpha:?blurX:?blurY:?strength:?quality:?inner:?knockout">
	<x path="UInt"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.geom.ColorTransform" params="" file="/usr/lib/haxe/std/flash/geom/ColorTransform.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<concat public="1" set="method"><f a="second">
	<c path="flash.geom.ColorTransform"/>
	<x path="Void"/>
</f></concat>
		<redOffset public="1"><x path="Float"/></redOffset>
		<redMultiplier public="1"><x path="Float"/></redMultiplier>
		<greenOffset public="1"><x path="Float"/></greenOffset>
		<greenMultiplier public="1"><x path="Float"/></greenMultiplier>
		<color public="1"><x path="UInt"/></color>
		<blueOffset public="1"><x path="Float"/></blueOffset>
		<blueMultiplier public="1"><x path="Float"/></blueMultiplier>
		<alphaOffset public="1"><x path="Float"/></alphaOffset>
		<alphaMultiplier public="1"><x path="Float"/></alphaMultiplier>
		<new public="1" set="method"><f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix" params="" file="/usr/lib/haxe/std/flash/geom/Matrix.hx" extern="1">
		<translate public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<transformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></transformPoint>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<setTo public="1" set="method">
			<f a="aa:ba:ca:da:txa:tya">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<scale public="1" set="method"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<rotate public="1" set="method"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<invert public="1" set="method"><f a=""><x path="Void"/></f></invert>
		<identity public="1" set="method"><f a=""><x path="Void"/></f></identity>
		<deltaTransformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></deltaTransformPoint>
		<createGradientBox public="1" set="method"><f a="width:height:?rotation:?tx:?ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></createGradientBox>
		<createBox public="1" set="method"><f a="scaleX:scaleY:?rotation:?tx:?ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></createBox>
		<copyRowTo public="1" set="method">
			<f a="row:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowTo>
		<copyRowFrom public="1" set="method">
			<f a="row:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowFrom>
		<copyFrom public="1" set="method">
			<f a="sourceMatrix">
				<c path="flash.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<copyColumnTo public="1" set="method">
			<f a="column:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnTo>
		<copyColumnFrom public="1" set="method">
			<f a="column:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnFrom>
		<concat public="1" set="method"><f a="m">
	<c path="flash.geom.Matrix"/>
	<x path="Void"/>
</f></concat>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix"/></f></clone>
		<ty public="1"><x path="Float"/></ty>
		<tx public="1"><x path="Float"/></tx>
		<d public="1"><x path="Float"/></d>
		<c public="1"><x path="Float"/></c>
		<b public="1"><x path="Float"/></b>
		<a public="1"><x path="Float"/></a>
		<new public="1" set="method"><f a="?a:?b:?c:?d:?tx:?ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix3D" params="" file="/usr/lib/haxe/std/flash/geom/Matrix3D.hx" extern="1">
		<interpolate public="1" set="method" static="1"><f a="thisMat:toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="flash.geom.Matrix3D"/>
	<x path="Float"/>
	<c path="flash.geom.Matrix3D"/>
</f></interpolate>
		<transpose public="1" set="method"><f a=""><x path="Void"/></f></transpose>
		<transformVectors public="1" set="method"><f a="vin:vout">
	<c path="flash.Vector"><x path="Float"/></c>
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Void"/>
</f></transformVectors>
		<transformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></transformVector>
		<recompose public="1" set="method"><f a="components:?orientationStyle">
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
	<e path="flash.geom.Orientation3D"/>
	<x path="Bool"/>
</f></recompose>
		<prependTranslation public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependTranslation>
		<prependScale public="1" set="method"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependScale>
		<prependRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<x path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></prependRotation>
		<prepend public="1" set="method"><f a="rhs">
	<c path="flash.geom.Matrix3D"/>
	<x path="Void"/>
</f></prepend>
		<pointAt public="1" set="method"><f a="pos:?at:?up">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></pointAt>
		<invert public="1" set="method"><f a=""><x path="Bool"/></f></invert>
		<interpolateTo public="1" set="method"><f a="toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<x path="Float"/>
	<x path="Void"/>
</f></interpolateTo>
		<identity public="1" set="method"><f a=""><x path="Void"/></f></identity>
		<deltaTransformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></deltaTransformVector>
		<decompose public="1" set="method"><f a="?orientationStyle">
	<e path="flash.geom.Orientation3D"/>
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
</f></decompose>
		<copyToMatrix3D public="1" set="method">
			<f a="dest">
				<c path="flash.geom.Matrix3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyToMatrix3D>
		<copyRowTo public="1" set="method">
			<f a="row:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowTo>
		<copyRowFrom public="1" set="method">
			<f a="row:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowFrom>
		<copyRawDataTo public="1" set="method">
			<f a="vector:?index:?transpose">
				<c path="flash.Vector"><x path="Float"/></c>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRawDataTo>
		<copyRawDataFrom public="1" set="method">
			<f a="vector:?index:?transpose">
				<c path="flash.Vector"><x path="Float"/></c>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRawDataFrom>
		<copyFrom public="1" set="method">
			<f a="sourceMatrix3D">
				<c path="flash.geom.Matrix3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<copyColumnTo public="1" set="method">
			<f a="column:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnTo>
		<copyColumnFrom public="1" set="method">
			<f a="column:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnFrom>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></clone>
		<appendTranslation public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendTranslation>
		<appendScale public="1" set="method"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendScale>
		<appendRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<x path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></appendRotation>
		<append public="1" set="method"><f a="lhs">
	<c path="flash.geom.Matrix3D"/>
	<x path="Void"/>
</f></append>
		<rawData public="1"><c path="flash.Vector"><x path="Float"/></c></rawData>
		<position public="1"><c path="flash.geom.Vector3D"/></position>
		<determinant public="1" set="null"><x path="Float"/></determinant>
		<new public="1" set="method"><f a="?v">
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<enum path="flash.geom.Orientation3D" params="" file="/usr/lib/haxe/std/flash/geom/Orientation3D.hx">
		<QUATERNION/>
		<EULER_ANGLES/>
		<AXIS_ANGLE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.geom.PerspectiveProjection" params="" file="/usr/lib/haxe/std/flash/geom/PerspectiveProjection.hx" extern="1">
		<toMatrix3D public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></toMatrix3D>
		<projectionCenter public="1"><c path="flash.geom.Point"/></projectionCenter>
		<focalLength public="1"><x path="Float"/></focalLength>
		<fieldOfView public="1"><x path="Float"/></fieldOfView>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.geom.Point" params="" file="/usr/lib/haxe/std/flash/geom/Point.hx" extern="1">
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<x path="Float"/>
</f></distance>
		<interpolate public="1" set="method" static="1"><f a="pt1:pt2:f">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<x path="Float"/>
	<c path="flash.geom.Point"/>
</f></interpolate>
		<polar public="1" set="method" static="1"><f a="len:angle">
	<x path="Float"/>
	<x path="Float"/>
	<c path="flash.geom.Point"/>
</f></polar>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<subtract public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></subtract>
		<setTo public="1" set="method">
			<f a="xa:ya">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<offset public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<normalize public="1" set="method"><f a="thickness">
	<x path="Float"/>
	<x path="Void"/>
</f></normalize>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></equals>
		<copyFrom public="1" set="method">
			<f a="sourcePoint">
				<c path="flash.geom.Point"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Point"/></f></clone>
		<add public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></add>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<length public="1" set="null"><x path="Float"/></length>
		<new public="1" set="method"><f a="?x:?y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Rectangle" params="" file="/usr/lib/haxe/std/flash/geom/Rectangle.hx" extern="1">
		<union public="1" set="method"><f a="toUnion">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></union>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<setTo public="1" set="method">
			<f a="xa:ya:widtha:heighta">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<setEmpty public="1" set="method"><f a=""><x path="Void"/></f></setEmpty>
		<offsetPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Void"/>
</f></offsetPoint>
		<offset public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<isEmpty public="1" set="method"><f a=""><x path="Bool"/></f></isEmpty>
		<intersects public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></intersects>
		<intersection public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></intersection>
		<inflatePoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Void"/>
</f></inflatePoint>
		<inflate public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></inflate>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></equals>
		<copyFrom public="1" set="method">
			<f a="sourceRect">
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<containsRect public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></containsRect>
		<containsPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></containsPoint>
		<contains public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></contains>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Rectangle"/></f></clone>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<width public="1"><x path="Float"/></width>
		<topLeft public="1"><c path="flash.geom.Point"/></topLeft>
		<top public="1"><x path="Float"/></top>
		<size public="1"><c path="flash.geom.Point"/></size>
		<right public="1"><x path="Float"/></right>
		<left public="1"><x path="Float"/></left>
		<height public="1"><x path="Float"/></height>
		<bottomRight public="1"><c path="flash.geom.Point"/></bottomRight>
		<bottom public="1"><x path="Float"/></bottom>
		<new public="1" set="method"><f a="?x:?y:?width:?height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Transform" params="" file="/usr/lib/haxe/std/flash/geom/Transform.hx" extern="1">
		<getRelativeMatrix3D public="1" set="method">
			<f a="relativeTo">
				<c path="flash.display.DisplayObject"/>
				<c path="flash.geom.Matrix3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getRelativeMatrix3D>
		<pixelBounds public="1" set="null"><c path="flash.geom.Rectangle"/></pixelBounds>
		<perspectiveProjection public="1">
			<c path="flash.geom.PerspectiveProjection"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</perspectiveProjection>
		<matrix3D public="1">
			<c path="flash.geom.Matrix3D"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</matrix3D>
		<matrix public="1"><c path="flash.geom.Matrix"/></matrix>
		<concatenatedMatrix public="1" set="null"><c path="flash.geom.Matrix"/></concatenatedMatrix>
		<concatenatedColorTransform public="1" set="null"><c path="flash.geom.ColorTransform"/></concatenatedColorTransform>
		<colorTransform public="1"><c path="flash.geom.ColorTransform"/></colorTransform>
		<new public="1" set="method"><f a="displayObject">
	<c path="flash.display.DisplayObject"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Vector3D" params="" file="/usr/lib/haxe/std/flash/geom/Vector3D.hx" extern="1">
		<X_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></X_AXIS>
		<Y_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Y_AXIS>
		<Z_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Z_AXIS>
		<angleBetween public="1" set="method" static="1"><f a="a:b">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></angleBetween>
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></distance>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<subtract public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></subtract>
		<setTo public="1" set="method">
			<f a="xa:ya:za">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<scaleBy public="1" set="method"><f a="s">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleBy>
		<project public="1" set="method"><f a=""><x path="Void"/></f></project>
		<normalize public="1" set="method"><f a=""><x path="Float"/></f></normalize>
		<negate public="1" set="method"><f a=""><x path="Void"/></f></negate>
		<nearEquals public="1" set="method"><f a="toCompare:tolerance:?allFour">
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></nearEquals>
		<incrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></incrementBy>
		<equals public="1" set="method"><f a="toCompare:?allFour">
	<c path="flash.geom.Vector3D"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></equals>
		<dotProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></dotProduct>
		<decrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></decrementBy>
		<crossProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></crossProduct>
		<copyFrom public="1" set="method">
			<f a="sourceVector3D">
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Vector3D"/></f></clone>
		<add public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></add>
		<z public="1"><x path="Float"/></z>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<w public="1"><x path="Float"/></w>
		<lengthSquared public="1" set="null"><x path="Float"/></lengthSquared>
		<length public="1" set="null"><x path="Float"/></length>
		<new public="1" set="method"><f a="?x:?y:?z:?w">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.media.Camera" params="" file="/usr/lib/haxe/std/flash/media/Camera.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<_scanHardware public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</_scanHardware>
		<getCamera public="1" set="method" static="1"><f a="?name">
	<c path="String"/>
	<c path="flash.media.Camera"/>
</f></getCamera>
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setQuality>
		<setMotionLevel public="1" set="method"><f a="motionLevel:?timeout">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setMotionLevel>
		<setMode public="1" set="method"><f a="width:height:fps:?favorArea">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setMode>
		<setLoopback public="1" set="method"><f a="?compress">
	<x path="Bool"/>
	<x path="Void"/>
</f></setLoopback>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<x path="Int"/>
	<x path="Void"/>
</f></setKeyFrameInterval>
		<setCursor public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></setCursor>
		<drawToBitmapData public="1">
			<f a="destination">
				<c path="flash.display.BitmapData"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</drawToBitmapData>
		<copyToVector public="1">
			<f a="rect:destination">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><x path="UInt"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</copyToVector>
		<copyToByteArray public="1">
			<f a="rect:destination">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.utils.ByteArray"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</copyToByteArray>
		<width public="1" set="null"><x path="Int"/></width>
		<quality public="1" set="null"><x path="Int"/></quality>
		<position public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</position>
		<name public="1" set="null"><c path="String"/></name>
		<muted public="1" set="null"><x path="Bool"/></muted>
		<motionTimeout public="1" set="null"><x path="Int"/></motionTimeout>
		<motionLevel public="1" set="null"><x path="Int"/></motionLevel>
		<loopback public="1" set="null"><x path="Bool"/></loopback>
		<keyFrameInterval public="1" set="null"><x path="Int"/></keyFrameInterval>
		<index public="1" set="null"><x path="Int"/></index>
		<height public="1" set="null"><x path="Int"/></height>
		<fps public="1" set="null"><x path="Float"/></fps>
		<currentFPS public="1" set="null"><x path="Float"/></currentFPS>
		<bandwidth public="1" set="null"><x path="Int"/></bandwidth>
		<activityLevel public="1" set="null"><x path="Float"/></activityLevel>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.media.Microphone" params="" file="/usr/lib/haxe/std/flash/media/Microphone.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<getEnhancedMicrophone public="1" set="method" static="1">
			<f a="?index">
				<x path="Int"/>
				<c path="flash.media.Microphone"/>
			</f>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</getEnhancedMicrophone>
		<getMicrophone public="1" set="method" static="1"><f a="?index">
	<x path="Int"/>
	<c path="flash.media.Microphone"/>
</f></getMicrophone>
		<setUseEchoSuppression public="1" set="method"><f a="useEchoSuppression">
	<x path="Bool"/>
	<x path="Void"/>
</f></setUseEchoSuppression>
		<setSilenceLevel public="1" set="method"><f a="silenceLevel:?timeout">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setSilenceLevel>
		<setLoopBack public="1" set="method"><f a="?state">
	<x path="Bool"/>
	<x path="Void"/>
</f></setLoopBack>
		<useEchoSuppression public="1" set="null"><x path="Bool"/></useEchoSuppression>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<silenceTimeout public="1" set="null"><x path="Int"/></silenceTimeout>
		<silenceLevel public="1" set="null"><x path="Float"/></silenceLevel>
		<rate public="1"><x path="Int"/></rate>
		<noiseSuppressionLevel public="1">
			<x path="Int"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</noiseSuppressionLevel>
		<name public="1" set="null"><c path="String"/></name>
		<muted public="1" set="null"><x path="Bool"/></muted>
		<index public="1" set="null"><x path="Int"/></index>
		<gain public="1"><x path="Float"/></gain>
		<framesPerPacket public="1">
			<x path="Int"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</framesPerPacket>
		<enhancedOptions public="1">
			<c path="flash.media.MicrophoneEnhancedOptions"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</enhancedOptions>
		<encodeQuality public="1">
			<x path="Int"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</encodeQuality>
		<enableVAD public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</enableVAD>
		<codec public="1">
			<e path="flash.media.SoundCodec"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</codec>
		<activityLevel public="1" set="null"><x path="Float"/></activityLevel>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.media.MicrophoneEnhancedMode" params="" file="/usr/lib/haxe/std/flash/media/MicrophoneEnhancedMode.hx">
		<SPEAKER_MUTE/>
		<OFF/>
		<HEADSET/>
		<HALF_DUPLEX/>
		<FULL_DUPLEX/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</enum>
	<class path="flash.media.MicrophoneEnhancedOptions" params="" file="/usr/lib/haxe/std/flash/media/MicrophoneEnhancedOptions.hx" extern="1">
		<nonLinearProcessing public="1"><x path="Bool"/></nonLinearProcessing>
		<mode public="1"><e path="flash.media.MicrophoneEnhancedMode"/></mode>
		<isVoiceDetected public="1"><x path="Int"/></isVoiceDetected>
		<echoPath public="1"><x path="Int"/></echoPath>
		<autoGain public="1"><x path="Bool"/></autoGain>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</class>
	<enum path="flash.media.SoundCodec" params="" file="/usr/lib/haxe/std/flash/media/SoundCodec.hx">
		<SPEEX/>
		<PCMU/>
		<PCMA/>
		<NELLYMOSER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.media.SoundTransform" params="" file="/usr/lib/haxe/std/flash/media/SoundTransform.hx" extern="1">
		<volume public="1"><x path="Float"/></volume>
		<rightToRight public="1"><x path="Float"/></rightToRight>
		<rightToLeft public="1"><x path="Float"/></rightToLeft>
		<pan public="1"><x path="Float"/></pan>
		<leftToRight public="1"><x path="Float"/></leftToRight>
		<leftToLeft public="1"><x path="Float"/></leftToLeft>
		<new public="1" set="method"><f a="?vol:?panning">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.media.StageVideo" params="" file="/usr/lib/haxe/std/flash/media/StageVideo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<attachNetStream public="1" set="method"><f a="netStream">
	<c path="flash.net.NetStream"/>
	<x path="Void"/>
</f></attachNetStream>
		<attachCamera public="1">
			<f a="theCamera">
				<c path="flash.media.Camera"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</attachCamera>
		<zoom public="1"><c path="flash.geom.Point"/></zoom>
		<viewPort public="1"><c path="flash.geom.Rectangle"/></viewPort>
		<videoWidth public="1" set="null"><x path="Int"/></videoWidth>
		<videoHeight public="1" set="null"><x path="Int"/></videoHeight>
		<pan public="1"><c path="flash.geom.Point"/></pan>
		<depth public="1"><x path="Int"/></depth>
		<colorSpaces public="1" set="null"><c path="flash.Vector"><c path="String"/></c></colorSpaces>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_2</e></m></meta>
	</class>
	<class path="flash.media.VideoStreamSettings" params="" file="/usr/lib/haxe/std/flash/media/VideoStreamSettings.hx" extern="1">
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setQuality>
		<setMode public="1" set="method"><f a="width:height:fps">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setMode>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<x path="Int"/>
	<x path="Void"/>
</f></setKeyFrameInterval>
		<width public="1" set="null"><x path="Int"/></width>
		<quality public="1" set="null"><x path="Int"/></quality>
		<keyFrameInterval public="1" set="null"><x path="Int"/></keyFrameInterval>
		<height public="1" set="null"><x path="Int"/></height>
		<fps public="1" set="null"><x path="Float"/></fps>
		<codec public="1" set="null"><c path="String"/></codec>
		<bandwidth public="1" set="null"><x path="Int"/></bandwidth>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.net.NetConnection" params="" file="/usr/lib/haxe/std/flash/net/NetConnection.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" static="1"><x path="UInt"/></defaultObjectEncoding>
		<connect public="1" set="method"><f a="command:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></connect>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<call public="1" set="method"><f a="command:responder:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<c path="flash.net.Responder"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></call>
		<addHeader public="1" set="method"><f a="operation:?mustUnderstand:?param">
	<c path="String"/>
	<x path="Bool"/>
	<t path="flash.utils.Object"/>
	<x path="Void"/>
</f></addHeader>
		<usingTLS public="1" set="null"><x path="Bool"/></usingTLS>
		<uri public="1" set="null"><c path="String"/></uri>
		<unconnectedPeerStreams public="1" set="null">
			<c path="Array"><d/></c>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</unconnectedPeerStreams>
		<proxyType public="1"><c path="String"/></proxyType>
		<protocol public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</protocol>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<nearNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearNonce>
		<nearID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearID>
		<maxPeerConnections public="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</maxPeerConnections>
		<farNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farNonce>
		<farID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farID>
		<connectedProxyType public="1" set="null"><c path="String"/></connectedProxyType>
		<connected public="1" set="null"><x path="Bool"/></connected>
		<client public="1"><d/></client>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.net.NetStream" params="" file="/usr/lib/haxe/std/flash/net/NetStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<CONNECT_TO_FMS public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CONNECT_TO_FMS>
		<DIRECT_CONNECTIONS public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</DIRECT_CONNECTIONS>
		<togglePause public="1" set="method"><f a=""><x path="Void"/></f></togglePause>
		<step public="1" set="method">
			<f a="frames">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</step>
		<send public="1" set="method"><f a="handlerName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></send>
		<seek public="1" set="method"><f a="offset">
	<x path="Float"/>
	<x path="Void"/>
</f></seek>
		<resume public="1" set="method"><f a=""><x path="Void"/></f></resume>
		<receiveVideoFPS public="1" set="method"><f a="FPS">
	<x path="Float"/>
	<x path="Void"/>
</f></receiveVideoFPS>
		<receiveVideo public="1" set="method"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></receiveVideo>
		<receiveAudio public="1" set="method"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></receiveAudio>
		<publish public="1" set="method"><f a="?name:?type">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></publish>
		<play2 public="1" set="method">
			<f a="param">
				<c path="flash.net.NetStreamPlayOptions"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</play2>
		<play public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></play>
		<pause public="1" set="method"><f a=""><x path="Void"/></f></pause>
		<onPeerConnect public="1" set="method">
			<f a="subscriber">
				<c path="flash.net.NetStream"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</onPeerConnect>
		<dispose public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</dispose>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<attachCamera public="1" set="method"><f a="theCamera:?snapshotMilliseconds">
	<c path="flash.media.Camera"/>
	<x path="Int"/>
	<x path="Void"/>
</f></attachCamera>
		<attachAudio public="1" set="method"><f a="microphone">
	<c path="flash.media.Microphone"/>
	<x path="Void"/>
</f></attachAudio>
		<attach public="1" set="method">
			<f a="connection">
				<c path="flash.net.NetConnection"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</attach>
		<appendBytesAction public="1" set="method">
			<f a="netStreamAppendBytesAction">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</appendBytesAction>
		<appendBytes public="1" set="method">
			<f a="bytes">
				<c path="flash.utils.ByteArray"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</appendBytes>
		<videoStreamSettings public="1">
			<c path="flash.media.VideoStreamSettings"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</videoStreamSettings>
		<videoSampleAccess public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoSampleAccess>
		<videoReliable public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoReliable>
		<videoCodec public="1" set="null"><x path="UInt"/></videoCodec>
		<useJitterBuffer public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</useJitterBuffer>
		<useHardwareDecoder public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</useHardwareDecoder>
		<time public="1" set="null"><x path="Float"/></time>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<peerStreams public="1" set="null">
			<c path="Array"><d/></c>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</peerStreams>
		<objectEncoding public="1" set="null"><x path="UInt"/></objectEncoding>
		<nearNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearNonce>
		<multicastWindowDuration public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastWindowDuration>
		<multicastRelayMarginDuration public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastRelayMarginDuration>
		<multicastPushNeighborLimit public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastPushNeighborLimit>
		<multicastInfo public="1" set="null">
			<c path="flash.net.NetStreamMulticastInfo"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastInfo>
		<multicastFetchPeriod public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastFetchPeriod>
		<multicastAvailabilityUpdatePeriod public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastAvailabilityUpdatePeriod>
		<multicastAvailabilitySendToAll public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastAvailabilitySendToAll>
		<maxPauseBufferTime public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</maxPauseBufferTime>
		<liveDelay public="1" set="null"><x path="Float"/></liveDelay>
		<info public="1" set="null">
			<c path="flash.net.NetStreamInfo"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</info>
		<inBufferSeek public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</inBufferSeek>
		<farNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farNonce>
		<farID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farID>
		<decodedFrames public="1" set="null"><x path="UInt"/></decodedFrames>
		<dataReliable public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</dataReliable>
		<currentFPS public="1" set="null"><x path="Float"/></currentFPS>
		<client public="1"><d/></client>
		<checkPolicyFile public="1"><x path="Bool"/></checkPolicyFile>
		<bytesTotal public="1" set="null"><x path="UInt"/></bytesTotal>
		<bytesLoaded public="1" set="null"><x path="UInt"/></bytesLoaded>
		<bufferTimeMax public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</bufferTimeMax>
		<bufferTime public="1"><x path="Float"/></bufferTime>
		<bufferLength public="1" set="null"><x path="Float"/></bufferLength>
		<backBufferTime public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</backBufferTime>
		<backBufferLength public="1" set="null">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</backBufferLength>
		<audioSampleAccess public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</audioSampleAccess>
		<audioReliable public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</audioReliable>
		<audioCodec public="1" set="null"><x path="UInt"/></audioCodec>
		<new public="1" set="method"><f a="connection:?peerID">
	<c path="flash.net.NetConnection"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.net.NetStreamInfo" params="" file="/usr/lib/haxe/std/flash/net/NetStreamInfo.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<xmpData public="1" set="null"><d/></xmpData>
		<videoLossRate public="1" set="null">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoLossRate>
		<videoBytesPerSecond public="1" set="null"><x path="Float"/></videoBytesPerSecond>
		<videoByteCount public="1" set="null"><x path="Float"/></videoByteCount>
		<videoBufferLength public="1" set="null"><x path="Float"/></videoBufferLength>
		<videoBufferByteLength public="1" set="null"><x path="Float"/></videoBufferByteLength>
		<uri public="1" set="null"><c path="String"/></uri>
		<resourceName public="1" set="null"><c path="String"/></resourceName>
		<playbackBytesPerSecond public="1" set="null"><x path="Float"/></playbackBytesPerSecond>
		<metaData public="1" set="null"><d/></metaData>
		<maxBytesPerSecond public="1" set="null"><x path="Float"/></maxBytesPerSecond>
		<isLive public="1" set="null"><x path="Bool"/></isLive>
		<droppedFrames public="1" set="null"><x path="Float"/></droppedFrames>
		<dataBytesPerSecond public="1" set="null"><x path="Float"/></dataBytesPerSecond>
		<dataByteCount public="1" set="null"><x path="Float"/></dataByteCount>
		<dataBufferLength public="1" set="null"><x path="Float"/></dataBufferLength>
		<dataBufferByteLength public="1" set="null"><x path="Float"/></dataBufferByteLength>
		<currentBytesPerSecond public="1" set="null"><x path="Float"/></currentBytesPerSecond>
		<byteCount public="1" set="null"><x path="Float"/></byteCount>
		<audioLossRate public="1" set="null"><x path="Float"/></audioLossRate>
		<audioBytesPerSecond public="1" set="null"><x path="Float"/></audioBytesPerSecond>
		<audioByteCount public="1" set="null"><x path="Float"/></audioByteCount>
		<audioBufferLength public="1" set="null"><x path="Float"/></audioBufferLength>
		<audioBufferByteLength public="1" set="null"><x path="Float"/></audioBufferByteLength>
		<SRTT public="1" set="null"><x path="Float"/></SRTT>
		<new public="1" set="method"><f a="curBPS:byteCount:maxBPS:audioBPS:audioByteCount:videoBPS:videoByteCount:dataBPS:dataByteCount:playbackBPS:droppedFrames:audioBufferByteLength:videoBufferByteLength:dataBufferByteLength:audioBufferLength:videoBufferLength:dataBufferLength:srtt:audioLossRate:videoLossRate:?metaData:?xmpData:?uri:?resourceName:?isLive">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<d/>
	<d/>
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.NetStreamMulticastInfo" params="" file="/usr/lib/haxe/std/flash/net/NetStreamMulticastInfo.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<sendDataBytesPerSecond public="1" set="null"><x path="Float"/></sendDataBytesPerSecond>
		<sendControlBytesPerSecondToServer public="1" set="null"><x path="Float"/></sendControlBytesPerSecondToServer>
		<sendControlBytesPerSecond public="1" set="null"><x path="Float"/></sendControlBytesPerSecond>
		<receiveDataBytesPerSecondFromServer public="1" set="null"><x path="Float"/></receiveDataBytesPerSecondFromServer>
		<receiveDataBytesPerSecondFromIPMulticast public="1" set="null"><x path="Float"/></receiveDataBytesPerSecondFromIPMulticast>
		<receiveDataBytesPerSecond public="1" set="null"><x path="Float"/></receiveDataBytesPerSecond>
		<receiveControlBytesPerSecond public="1" set="null"><x path="Float"/></receiveControlBytesPerSecond>
		<fragmentsRequestedFromPeers public="1" set="null"><x path="Float"/></fragmentsRequestedFromPeers>
		<fragmentsRequestedByPeers public="1" set="null"><x path="Float"/></fragmentsRequestedByPeers>
		<fragmentsReceivedFromServer public="1" set="null"><x path="Float"/></fragmentsReceivedFromServer>
		<fragmentsReceivedFromIPMulticast public="1" set="null"><x path="Float"/></fragmentsReceivedFromIPMulticast>
		<fragmentsPushedToPeers public="1" set="null"><x path="Float"/></fragmentsPushedToPeers>
		<fragmentsPushedFromPeers public="1" set="null"><x path="Float"/></fragmentsPushedFromPeers>
		<bytesRequestedFromPeers public="1" set="null"><x path="Float"/></bytesRequestedFromPeers>
		<bytesRequestedByPeers public="1" set="null"><x path="Float"/></bytesRequestedByPeers>
		<bytesReceivedFromServer public="1" set="null"><x path="Float"/></bytesReceivedFromServer>
		<bytesReceivedFromIPMulticast public="1" set="null"><x path="Float"/></bytesReceivedFromIPMulticast>
		<bytesPushedToPeers public="1" set="null"><x path="Float"/></bytesPushedToPeers>
		<bytesPushedFromPeers public="1" set="null"><x path="Float"/></bytesPushedFromPeers>
		<new public="1" set="method"><f a="sendDataBytesPerSecond:sendControlBytesPerSecond:receiveDataBytesPerSecond:receiveControlBytesPerSecond:bytesPushedToPeers:fragmentsPushedToPeers:bytesRequestedByPeers:fragmentsRequestedByPeers:bytesPushedFromPeers:fragmentsPushedFromPeers:bytesRequestedFromPeers:fragmentsRequestedFromPeers:sendControlBytesPerSecondToServer:receiveDataBytesPerSecondFromServer:bytesReceivedFromServer:fragmentsReceivedFromServer:receiveDataBytesPerSecondFromIPMulticast:bytesReceivedFromIPMulticast:fragmentsReceivedFromIPMulticast">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</class>
	<class path="flash.net.NetStreamPlayOptions" params="" file="/usr/lib/haxe/std/flash/net/NetStreamPlayOptions.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<transition public="1"><c path="String"/></transition>
		<streamName public="1"><c path="String"/></streamName>
		<start public="1"><x path="Float"/></start>
		<oldStreamName public="1"><c path="String"/></oldStreamName>
		<offset public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</offset>
		<len public="1"><x path="Float"/></len>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.net.Responder" params="" file="/usr/lib/haxe/std/flash/net/Responder.hx" extern="1"><new public="1" set="method"><f a="result:?status">
	<d/>
	<d/>
	<x path="Void"/>
</f></new></class>
	<class path="flash.utils.IDataInput" params="" file="/usr/lib/haxe/std/flash/utils/IDataInput.hx" extern="1" interface="1">
		<readUnsignedShort public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedInt>
		<readUnsignedByte public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedByte>
		<readUTFBytes public="1" set="method"><f a="length">
	<x path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<x path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></readBytes>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<bytesAvailable public="1" set="null"><x path="UInt"/></bytesAvailable>
	</class>
	<class path="flash.utils.IDataOutput" params="" file="/usr/lib/haxe/std/flash/utils/IDataOutput.hx" extern="1" interface="1">
		<writeUnsignedInt public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Void"/>
</f></writeUnsignedInt>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeShort public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<x path="Void"/>
</f></writeObject>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeMultiByte>
		<writeInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeFloat public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></writeBytes>
		<writeByte public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBoolean public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
	</class>
	<class path="flash.net.Socket" params="" file="/usr/lib/haxe/std/flash/net/Socket.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.utils.IDataInput"/>
		<implements path="flash.utils.IDataOutput"/>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Void"/>
</f></writeUnsignedInt>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeShort public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<x path="Void"/>
</f></writeObject>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeMultiByte>
		<writeInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeFloat public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></writeBytes>
		<writeByte public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBoolean public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<readUnsignedShort public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedInt>
		<readUnsignedByte public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedByte>
		<readUTFBytes public="1" set="method"><f a="length">
	<x path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<x path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></readBytes>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<flush public="1" set="method"><f a=""><x path="Void"/></f></flush>
		<connect public="1" set="method"><f a="host:port">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></connect>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<timeout public="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</timeout>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<connected public="1" set="null"><x path="Bool"/></connected>
		<bytesPending public="1" set="null">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</bytesPending>
		<bytesAvailable public="1" set="null"><x path="UInt"/></bytesAvailable>
		<new public="1" set="method"><f a="?host:?port">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.net.URLRequest" params="" file="/usr/lib/haxe/std/flash/net/URLRequest.hx" extern="1">
		<url public="1"><c path="String"/></url>
		<requestHeaders public="1"><c path="Array"><c path="flash.net.URLRequestHeader"/></c></requestHeaders>
		<method public="1"><c path="String"/></method>
		<digest public="1"><c path="String"/></digest>
		<data public="1"><d/></data>
		<contentType public="1"><c path="String"/></contentType>
		<new public="1" set="method"><f a="?url">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.URLRequestHeader" params="" file="/usr/lib/haxe/std/flash/net/URLRequestHeader.hx" extern="1">
		<value public="1"><c path="String"/></value>
		<name public="1"><c path="String"/></name>
		<new public="1" set="method"><f a="?name:?value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.system.ApplicationDomain" params="" file="/usr/lib/haxe/std/flash/system/ApplicationDomain.hx" extern="1">
		<MIN_DOMAIN_MEMORY_LENGTH public="1" set="null" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</MIN_DOMAIN_MEMORY_LENGTH>
		<currentDomain public="1" set="null" static="1"><c path="flash.system.ApplicationDomain"/></currentDomain>
		<hasDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasDefinition>
		<getQualifiedDefinitionNames public="1">
			<f a=""><c path="flash.Vector"><c path="String"/></c></f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</getQualifiedDefinitionNames>
		<getDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<t path="flash.utils.Object"/>
</f></getDefinition>
		<parentDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></parentDomain>
		<domainMemory public="1">
			<c path="flash.utils.ByteArray"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</domainMemory>
		<new public="1" set="method"><f a="?parentDomain">
	<c path="flash.system.ApplicationDomain"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.system.ImageDecodingPolicy" params="" file="/usr/lib/haxe/std/flash/system/ImageDecodingPolicy.hx">
		<ON_LOAD/>
		<ON_DEMAND/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.system.LoaderContext" params="" file="/usr/lib/haxe/std/flash/system/LoaderContext.hx" extern="1">
		<securityDomain public="1"><c path="flash.system.SecurityDomain"/></securityDomain>
		<requestedContentParent public="1">
			<c path="flash.display.DisplayObjectContainer"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</requestedContentParent>
		<parameters public="1">
			<d/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</parameters>
		<imageDecodingPolicy public="1">
			<e path="flash.system.ImageDecodingPolicy"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</imageDecodingPolicy>
		<checkPolicyFile public="1"><x path="Bool"/></checkPolicyFile>
		<applicationDomain public="1"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<allowLoadBytesCodeExecution public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</allowLoadBytesCodeExecution>
		<allowCodeImport public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</allowCodeImport>
		<new public="1" set="method"><f a="?checkPolicyFile:?applicationDomain:?securityDomain">
	<x path="Bool"/>
	<c path="flash.system.ApplicationDomain"/>
	<c path="flash.system.SecurityDomain"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.system.SecurityDomain" params="" file="/usr/lib/haxe/std/flash/system/SecurityDomain.hx" extern="1">
		<currentDomain public="1" set="null" static="1"><c path="flash.system.SecurityDomain"/></currentDomain>
		<domainID public="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</domainID>
	</class>
	<enum path="flash.text.AntiAliasType" params="" file="/usr/lib/haxe/std/flash/text/AntiAliasType.hx">
		<NORMAL/>
		<ADVANCED/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.GridFitType" params="" file="/usr/lib/haxe/std/flash/text/GridFitType.hx">
		<SUBPIXEL/>
		<PIXEL/>
		<NONE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.StyleSheet" params="" file="/usr/lib/haxe/std/flash/text/StyleSheet.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<transform public="1" set="method"><f a="formatObject">
	<t path="flash.utils.Object"/>
	<c path="flash.text.TextFormat"/>
</f></transform>
		<setStyle public="1" set="method"><f a="styleName:styleObject">
	<c path="String"/>
	<t path="flash.utils.Object"/>
	<x path="Void"/>
</f></setStyle>
		<parseCSS public="1" set="method"><f a="CSSText">
	<c path="String"/>
	<x path="Void"/>
</f></parseCSS>
		<getStyle public="1" set="method"><f a="styleName">
	<c path="String"/>
	<t path="flash.utils.Object"/>
</f></getStyle>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<styleNames public="1" set="null"><c path="Array"><d/></c></styleNames>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.text.TextField" params="" file="/usr/lib/haxe/std/flash/text/TextField.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<isFontCompatible public="1" set="method" static="1">
			<f a="fontName:fontStyle">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</isFontCompatible>
		<setTextFormat public="1" set="method"><f a="format:?beginIndex:?endIndex">
	<c path="flash.text.TextFormat"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setTextFormat>
		<setSelection public="1" set="method"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setSelection>
		<replaceText public="1" set="method"><f a="beginIndex:endIndex:newText">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></replaceText>
		<replaceSelectedText public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></replaceSelectedText>
		<pasteRichText public="1" set="method"><f a="richText">
	<c path="String"/>
	<x path="Bool"/>
</f></pasteRichText>
		<insertXMLText public="1" set="method"><f a="beginIndex:endIndex:richText:?pasting">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></insertXMLText>
		<getXMLText public="1" set="method"><f a="?beginIndex:?endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></getXMLText>
		<getTextRuns public="1" set="method"><f a="?beginIndex:?endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRuns>
		<getTextFormat public="1" set="method"><f a="?beginIndex:?endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.text.TextFormat"/>
</f></getTextFormat>
		<getRawText public="1" set="method"><f a=""><c path="String"/></f></getRawText>
		<getParagraphLength public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getParagraphLength>
		<getLineText public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<c path="String"/>
</f></getLineText>
		<getLineOffset public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineOffset>
		<getLineMetrics public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<c path="flash.text.TextLineMetrics"/>
</f></getLineMetrics>
		<getLineLength public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineLength>
		<getLineIndexOfChar public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineIndexOfChar>
		<getLineIndexAtPoint public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></getLineIndexAtPoint>
		<getImageReference public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getImageReference>
		<getFirstCharInParagraph public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getFirstCharInParagraph>
		<getCharIndexAtPoint public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></getCharIndexAtPoint>
		<getCharBoundaries public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<c path="flash.geom.Rectangle"/>
</f></getCharBoundaries>
		<copyRichText public="1" set="method"><f a=""><c path="String"/></f></copyRichText>
		<appendText public="1" set="method"><f a="newText">
	<c path="String"/>
	<x path="Void"/>
</f></appendText>
		<wordWrap public="1"><x path="Bool"/></wordWrap>
		<useRichTextClipboard public="1"><x path="Bool"/></useRichTextClipboard>
		<type public="1"><e path="flash.text.TextFieldType"/></type>
		<thickness public="1"><x path="Float"/></thickness>
		<textWidth public="1" set="null"><x path="Float"/></textWidth>
		<textInteractionMode public="1" set="null">
			<e path="flash.text.TextInteractionMode"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</textInteractionMode>
		<textHeight public="1" set="null"><x path="Float"/></textHeight>
		<textColor public="1"><x path="UInt"/></textColor>
		<text public="1"><c path="String"/></text>
		<styleSheet public="1"><c path="flash.text.StyleSheet"/></styleSheet>
		<sharpness public="1"><x path="Float"/></sharpness>
		<selectionEndIndex public="1" set="null"><x path="Int"/></selectionEndIndex>
		<selectionBeginIndex public="1" set="null"><x path="Int"/></selectionBeginIndex>
		<selectedText public="1" set="null"><c path="String"/></selectedText>
		<selectable public="1"><x path="Bool"/></selectable>
		<scrollV public="1"><x path="Int"/></scrollV>
		<scrollH public="1"><x path="Int"/></scrollH>
		<restrict public="1"><c path="String"/></restrict>
		<numLines public="1" set="null"><x path="Int"/></numLines>
		<multiline public="1"><x path="Bool"/></multiline>
		<mouseWheelEnabled public="1"><x path="Bool"/></mouseWheelEnabled>
		<maxScrollV public="1" set="null"><x path="Int"/></maxScrollV>
		<maxScrollH public="1" set="null"><x path="Int"/></maxScrollH>
		<maxChars public="1"><x path="Int"/></maxChars>
		<length public="1" set="null"><x path="Int"/></length>
		<htmlText public="1"><c path="String"/></htmlText>
		<gridFitType public="1"><e path="flash.text.GridFitType"/></gridFitType>
		<embedFonts public="1"><x path="Bool"/></embedFonts>
		<displayAsPassword public="1"><x path="Bool"/></displayAsPassword>
		<defaultTextFormat public="1"><c path="flash.text.TextFormat"/></defaultTextFormat>
		<condenseWhite public="1"><x path="Bool"/></condenseWhite>
		<caretIndex public="1" set="null"><x path="Int"/></caretIndex>
		<bottomScrollV public="1" set="null"><x path="Int"/></bottomScrollV>
		<borderColor public="1"><x path="UInt"/></borderColor>
		<border public="1"><x path="Bool"/></border>
		<backgroundColor public="1"><x path="UInt"/></backgroundColor>
		<background public="1"><x path="Bool"/></background>
		<autoSize public="1"><e path="flash.text.TextFieldAutoSize"/></autoSize>
		<antiAliasType public="1"><e path="flash.text.AntiAliasType"/></antiAliasType>
		<alwaysShowSelection public="1"><x path="Bool"/></alwaysShowSelection>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="flash.text.TextFieldAutoSize" params="" file="/usr/lib/haxe/std/flash/text/TextFieldAutoSize.hx">
		<RIGHT/>
		<NONE/>
		<LEFT/>
		<CENTER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextFieldType" params="" file="/usr/lib/haxe/std/flash/text/TextFieldType.hx">
		<INPUT/>
		<DYNAMIC/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.TextFormat" params="" file="/usr/lib/haxe/std/flash/text/TextFormat.hx" extern="1">
		<url public="1"><c path="String"/></url>
		<underline public="1"><t path="Null"><x path="Bool"/></t></underline>
		<target public="1"><c path="String"/></target>
		<tabStops public="1"><c path="Array"><x path="UInt"/></c></tabStops>
		<size public="1"><t path="Null"><x path="Float"/></t></size>
		<rightMargin public="1"><t path="Null"><x path="Float"/></t></rightMargin>
		<letterSpacing public="1"><t path="Null"><x path="Float"/></t></letterSpacing>
		<leftMargin public="1"><t path="Null"><x path="Float"/></t></leftMargin>
		<leading public="1"><t path="Null"><x path="Float"/></t></leading>
		<kerning public="1"><t path="Null"><x path="Bool"/></t></kerning>
		<italic public="1"><t path="Null"><x path="Bool"/></t></italic>
		<indent public="1"><t path="Null"><x path="Float"/></t></indent>
		<font public="1"><c path="String"/></font>
		<display public="1"><e path="flash.text.TextFormatDisplay"/></display>
		<color public="1"><t path="Null"><x path="UInt"/></t></color>
		<bullet public="1"><t path="Null"><x path="Bool"/></t></bullet>
		<bold public="1"><t path="Null"><x path="Bool"/></t></bold>
		<blockIndent public="1"><t path="Null"><x path="Float"/></t></blockIndent>
		<align public="1"><e path="flash.text.TextFormatAlign"/></align>
		<new public="1" set="method"><f a="?font:?size:?color:?bold:?italic:?underline:?url:?target:?align:?leftMargin:?rightMargin:?indent:?leading">
	<c path="String"/>
	<x path="Float"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<c path="String"/>
	<e path="flash.text.TextFormatAlign"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="flash.text.TextFormatAlign" params="" file="/usr/lib/haxe/std/flash/text/TextFormatAlign.hx">
		<START/>
		<RIGHT/>
		<LEFT/>
		<JUSTIFY/>
		<END/>
		<CENTER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextFormatDisplay" params="" file="/usr/lib/haxe/std/flash/text/TextFormatDisplay.hx">
		<INLINE/>
		<BLOCK/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextInteractionMode" params="" file="/usr/lib/haxe/std/flash/text/TextInteractionMode.hx">
		<SELECTION/>
		<NORMAL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.TextLineMetrics" params="" file="/usr/lib/haxe/std/flash/text/TextLineMetrics.hx" extern="1">
		<x public="1"><x path="Float"/></x>
		<width public="1"><x path="Float"/></width>
		<leading public="1"><x path="Float"/></leading>
		<height public="1"><x path="Float"/></height>
		<descent public="1"><x path="Float"/></descent>
		<ascent public="1"><x path="Float"/></ascent>
		<new public="1" set="method"><f a="x:width:height:ascent:descent:leading">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.text.TextSnapshot" params="" file="/usr/lib/haxe/std/flash/text/TextSnapshot.hx" extern="1">
		<setSelected public="1" set="method"><f a="beginIndex:endIndex:select">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setSelected>
		<setSelectColor public="1" set="method"><f a="?hexColor">
	<x path="UInt"/>
	<x path="Void"/>
</f></setSelectColor>
		<hitTestTextNearPos public="1" set="method"><f a="x:y:?maxDistance">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></hitTestTextNearPos>
		<getTextRunInfo public="1" set="method"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRunInfo>
		<getText public="1" set="method"><f a="beginIndex:endIndex:?includeLineEndings">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="String"/>
</f></getText>
		<getSelectedText public="1" set="method"><f a="?includeLineEndings">
	<x path="Bool"/>
	<c path="String"/>
</f></getSelectedText>
		<getSelected public="1" set="method"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></getSelected>
		<findText public="1" set="method"><f a="beginIndex:textToFind:caseSensitive">
	<x path="Int"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></findText>
		<charCount public="1" set="null"><x path="Int"/></charCount>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenu" params="" file="/usr/lib/haxe/std/flash/ui/ContextMenu.hx" extern="1">
		<extends path="flash.display.NativeMenu"/>
		<isSupported public="1" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<hideBuiltInItems public="1" set="method"><f a=""><x path="Void"/></f></hideBuiltInItems>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenu"/></f></clone>
		<link public="1">
			<c path="flash.net.URLRequest"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</link>
		<customItems public="1"><c path="Array"><d/></c></customItems>
		<clipboardMenu public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clipboardMenu>
		<clipboardItems public="1">
			<c path="flash.ui.ContextMenuClipboardItems"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clipboardItems>
		<builtInItems public="1"><c path="flash.ui.ContextMenuBuiltInItems"/></builtInItems>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.ui.ContextMenuBuiltInItems" params="" file="/usr/lib/haxe/std/flash/ui/ContextMenuBuiltInItems.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuBuiltInItems"/></f></clone>
		<zoom public="1"><x path="Bool"/></zoom>
		<save public="1"><x path="Bool"/></save>
		<rewind public="1"><x path="Bool"/></rewind>
		<quality public="1"><x path="Bool"/></quality>
		<print public="1"><x path="Bool"/></print>
		<play public="1"><x path="Bool"/></play>
		<loop public="1"><x path="Bool"/></loop>
		<forwardAndBack public="1"><x path="Bool"/></forwardAndBack>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.ui.ContextMenuClipboardItems" params="" file="/usr/lib/haxe/std/flash/ui/ContextMenuClipboardItems.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuClipboardItems"/></f></clone>
		<selectAll public="1"><x path="Bool"/></selectAll>
		<paste public="1"><x path="Bool"/></paste>
		<cut public="1"><x path="Bool"/></cut>
		<copy public="1"><x path="Bool"/></copy>
		<clear public="1"><x path="Bool"/></clear>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.ui.KeyLocation" params="" file="/usr/lib/haxe/std/flash/ui/KeyLocation.hx">
		<STANDARD/>
		<RIGHT/>
		<NUM_PAD/>
		<LEFT/>
		<D_PAD/>
		<meta><m n=":fakeEnum"><e>UInt</e></m></meta>
	</enum>
	<class path="flash.ui.Keyboard" params="" file="/usr/lib/haxe/std/flash/ui/Keyboard.hx" extern="1">
		<A public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</A>
		<ALTERNATE public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</ALTERNATE>
		<AUDIO public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</AUDIO>
		<B public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</B>
		<BACK public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</BACK>
		<BACKQUOTE public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</BACKQUOTE>
		<BACKSLASH public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</BACKSLASH>
		<BACKSPACE public="1" static="1"><x path="UInt"/></BACKSPACE>
		<BLUE public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</BLUE>
		<C public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</C>
		<CAPS_LOCK public="1" static="1"><x path="UInt"/></CAPS_LOCK>
		<CHANNEL_DOWN public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</CHANNEL_DOWN>
		<CHANNEL_UP public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</CHANNEL_UP>
		<COMMA public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</COMMA>
		<COMMAND public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</COMMAND>
		<CONTROL public="1" static="1"><x path="UInt"/></CONTROL>
		<CharCodeStrings public="1" static="1">
			<c path="Array"><d/></c>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</CharCodeStrings>
		<D public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</D>
		<DELETE public="1" static="1"><x path="UInt"/></DELETE>
		<DOWN public="1" static="1"><x path="UInt"/></DOWN>
		<DVR public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</DVR>
		<E public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</E>
		<END public="1" static="1"><x path="UInt"/></END>
		<ENTER public="1" static="1"><x path="UInt"/></ENTER>
		<EQUAL public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</EQUAL>
		<ESCAPE public="1" static="1"><x path="UInt"/></ESCAPE>
		<EXIT public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</EXIT>
		<F public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</F>
		<F1 public="1" static="1"><x path="UInt"/></F1>
		<F10 public="1" static="1"><x path="UInt"/></F10>
		<F11 public="1" static="1"><x path="UInt"/></F11>
		<F12 public="1" static="1"><x path="UInt"/></F12>
		<F13 public="1" static="1"><x path="UInt"/></F13>
		<F14 public="1" static="1"><x path="UInt"/></F14>
		<F15 public="1" static="1"><x path="UInt"/></F15>
		<F2 public="1" static="1"><x path="UInt"/></F2>
		<F3 public="1" static="1"><x path="UInt"/></F3>
		<F4 public="1" static="1"><x path="UInt"/></F4>
		<F5 public="1" static="1"><x path="UInt"/></F5>
		<F6 public="1" static="1"><x path="UInt"/></F6>
		<F7 public="1" static="1"><x path="UInt"/></F7>
		<F8 public="1" static="1"><x path="UInt"/></F8>
		<F9 public="1" static="1"><x path="UInt"/></F9>
		<FAST_FORWARD public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</FAST_FORWARD>
		<G public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</G>
		<GREEN public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</GREEN>
		<GUIDE public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</GUIDE>
		<H public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</H>
		<HELP public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</HELP>
		<HOME public="1" static="1"><x path="UInt"/></HOME>
		<I public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</I>
		<INFO public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</INFO>
		<INPUT public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</INPUT>
		<INSERT public="1" static="1"><x path="UInt"/></INSERT>
		<J public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</J>
		<K public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</K>
		<KEYNAME_BEGIN public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_BEGIN>
		<KEYNAME_BREAK public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_BREAK>
		<KEYNAME_CLEARDISPLAY public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_CLEARDISPLAY>
		<KEYNAME_CLEARLINE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_CLEARLINE>
		<KEYNAME_DELETE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_DELETE>
		<KEYNAME_DELETECHAR public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_DELETECHAR>
		<KEYNAME_DELETELINE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_DELETELINE>
		<KEYNAME_DOWNARROW public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_DOWNARROW>
		<KEYNAME_END public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_END>
		<KEYNAME_EXECUTE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_EXECUTE>
		<KEYNAME_F1 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F1>
		<KEYNAME_F10 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F10>
		<KEYNAME_F11 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F11>
		<KEYNAME_F12 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F12>
		<KEYNAME_F13 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F13>
		<KEYNAME_F14 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F14>
		<KEYNAME_F15 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F15>
		<KEYNAME_F16 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F16>
		<KEYNAME_F17 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F17>
		<KEYNAME_F18 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F18>
		<KEYNAME_F19 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F19>
		<KEYNAME_F2 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F2>
		<KEYNAME_F20 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F20>
		<KEYNAME_F21 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F21>
		<KEYNAME_F22 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F22>
		<KEYNAME_F23 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F23>
		<KEYNAME_F24 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F24>
		<KEYNAME_F25 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F25>
		<KEYNAME_F26 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F26>
		<KEYNAME_F27 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F27>
		<KEYNAME_F28 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F28>
		<KEYNAME_F29 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F29>
		<KEYNAME_F3 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F3>
		<KEYNAME_F30 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F30>
		<KEYNAME_F31 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F31>
		<KEYNAME_F32 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F32>
		<KEYNAME_F33 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F33>
		<KEYNAME_F34 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F34>
		<KEYNAME_F35 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F35>
		<KEYNAME_F4 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F4>
		<KEYNAME_F5 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F5>
		<KEYNAME_F6 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F6>
		<KEYNAME_F7 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F7>
		<KEYNAME_F8 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F8>
		<KEYNAME_F9 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_F9>
		<KEYNAME_FIND public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_FIND>
		<KEYNAME_HELP public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_HELP>
		<KEYNAME_HOME public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_HOME>
		<KEYNAME_INSERT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_INSERT>
		<KEYNAME_INSERTCHAR public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_INSERTCHAR>
		<KEYNAME_INSERTLINE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_INSERTLINE>
		<KEYNAME_LEFTARROW public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_LEFTARROW>
		<KEYNAME_MENU public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_MENU>
		<KEYNAME_MODESWITCH public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_MODESWITCH>
		<KEYNAME_NEXT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_NEXT>
		<KEYNAME_PAGEDOWN public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_PAGEDOWN>
		<KEYNAME_PAGEUP public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_PAGEUP>
		<KEYNAME_PAUSE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_PAUSE>
		<KEYNAME_PREV public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_PREV>
		<KEYNAME_PRINT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_PRINT>
		<KEYNAME_PRINTSCREEN public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_PRINTSCREEN>
		<KEYNAME_REDO public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_REDO>
		<KEYNAME_RESET public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_RESET>
		<KEYNAME_RIGHTARROW public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_RIGHTARROW>
		<KEYNAME_SCROLLLOCK public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_SCROLLLOCK>
		<KEYNAME_SELECT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_SELECT>
		<KEYNAME_STOP public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_STOP>
		<KEYNAME_SYSREQ public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_SYSREQ>
		<KEYNAME_SYSTEM public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_SYSTEM>
		<KEYNAME_UNDO public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_UNDO>
		<KEYNAME_UPARROW public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_UPARROW>
		<KEYNAME_USER public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</KEYNAME_USER>
		<L public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</L>
		<LAST public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</LAST>
		<LEFT public="1" static="1"><x path="UInt"/></LEFT>
		<LEFTBRACKET public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</LEFTBRACKET>
		<LIVE public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</LIVE>
		<M public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</M>
		<MASTER_SHELL public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</MASTER_SHELL>
		<MENU public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</MENU>
		<MINUS public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</MINUS>
		<N public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</N>
		<NEXT public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</NEXT>
		<NUMBER_0 public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</NUMBER_0>
		<NUMBER_1 public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</NUMBER_1>
		<NUMBER_2 public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</NUMBER_2>
		<NUMBER_3 public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</NUMBER_3>
		<NUMBER_4 public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</NUMBER_4>
		<NUMBER_5 public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</NUMBER_5>
		<NUMBER_6 public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</NUMBER_6>
		<NUMBER_7 public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</NUMBER_7>
		<NUMBER_8 public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</NUMBER_8>
		<NUMBER_9 public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</NUMBER_9>
		<NUMPAD public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</NUMPAD>
		<NUMPAD_0 public="1" static="1"><x path="UInt"/></NUMPAD_0>
		<NUMPAD_1 public="1" static="1"><x path="UInt"/></NUMPAD_1>
		<NUMPAD_2 public="1" static="1"><x path="UInt"/></NUMPAD_2>
		<NUMPAD_3 public="1" static="1"><x path="UInt"/></NUMPAD_3>
		<NUMPAD_4 public="1" static="1"><x path="UInt"/></NUMPAD_4>
		<NUMPAD_5 public="1" static="1"><x path="UInt"/></NUMPAD_5>
		<NUMPAD_6 public="1" static="1"><x path="UInt"/></NUMPAD_6>
		<NUMPAD_7 public="1" static="1"><x path="UInt"/></NUMPAD_7>
		<NUMPAD_8 public="1" static="1"><x path="UInt"/></NUMPAD_8>
		<NUMPAD_9 public="1" static="1"><x path="UInt"/></NUMPAD_9>
		<NUMPAD_ADD public="1" static="1"><x path="UInt"/></NUMPAD_ADD>
		<NUMPAD_DECIMAL public="1" static="1"><x path="UInt"/></NUMPAD_DECIMAL>
		<NUMPAD_DIVIDE public="1" static="1"><x path="UInt"/></NUMPAD_DIVIDE>
		<NUMPAD_ENTER public="1" static="1"><x path="UInt"/></NUMPAD_ENTER>
		<NUMPAD_MULTIPLY public="1" static="1"><x path="UInt"/></NUMPAD_MULTIPLY>
		<NUMPAD_SUBTRACT public="1" static="1"><x path="UInt"/></NUMPAD_SUBTRACT>
		<O public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</O>
		<P public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</P>
		<PAGE_DOWN public="1" static="1"><x path="UInt"/></PAGE_DOWN>
		<PAGE_UP public="1" static="1"><x path="UInt"/></PAGE_UP>
		<PAUSE public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</PAUSE>
		<PERIOD public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</PERIOD>
		<PLAY public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</PLAY>
		<PREVIOUS public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</PREVIOUS>
		<Q public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</Q>
		<QUOTE public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</QUOTE>
		<R public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</R>
		<RECORD public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</RECORD>
		<RED public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</RED>
		<REWIND public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</REWIND>
		<RIGHT public="1" static="1"><x path="UInt"/></RIGHT>
		<RIGHTBRACKET public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</RIGHTBRACKET>
		<S public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</S>
		<SEARCH public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</SEARCH>
		<SEMICOLON public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</SEMICOLON>
		<SETUP public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</SETUP>
		<SHIFT public="1" static="1"><x path="UInt"/></SHIFT>
		<SKIP_BACKWARD public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</SKIP_BACKWARD>
		<SKIP_FORWARD public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</SKIP_FORWARD>
		<SLASH public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</SLASH>
		<SPACE public="1" static="1"><x path="UInt"/></SPACE>
		<STOP public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</STOP>
		<STRING_BEGIN public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_BEGIN>
		<STRING_BREAK public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_BREAK>
		<STRING_CLEARDISPLAY public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_CLEARDISPLAY>
		<STRING_CLEARLINE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_CLEARLINE>
		<STRING_DELETE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_DELETE>
		<STRING_DELETECHAR public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_DELETECHAR>
		<STRING_DELETELINE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_DELETELINE>
		<STRING_DOWNARROW public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_DOWNARROW>
		<STRING_END public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_END>
		<STRING_EXECUTE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_EXECUTE>
		<STRING_F1 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F1>
		<STRING_F10 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F10>
		<STRING_F11 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F11>
		<STRING_F12 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F12>
		<STRING_F13 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F13>
		<STRING_F14 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F14>
		<STRING_F15 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F15>
		<STRING_F16 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F16>
		<STRING_F17 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F17>
		<STRING_F18 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F18>
		<STRING_F19 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F19>
		<STRING_F2 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F2>
		<STRING_F20 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F20>
		<STRING_F21 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F21>
		<STRING_F22 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F22>
		<STRING_F23 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F23>
		<STRING_F24 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F24>
		<STRING_F25 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F25>
		<STRING_F26 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F26>
		<STRING_F27 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F27>
		<STRING_F28 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F28>
		<STRING_F29 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F29>
		<STRING_F3 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F3>
		<STRING_F30 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F30>
		<STRING_F31 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F31>
		<STRING_F32 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F32>
		<STRING_F33 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F33>
		<STRING_F34 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F34>
		<STRING_F35 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F35>
		<STRING_F4 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F4>
		<STRING_F5 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F5>
		<STRING_F6 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F6>
		<STRING_F7 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F7>
		<STRING_F8 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F8>
		<STRING_F9 public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_F9>
		<STRING_FIND public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_FIND>
		<STRING_HELP public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_HELP>
		<STRING_HOME public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_HOME>
		<STRING_INSERT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_INSERT>
		<STRING_INSERTCHAR public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_INSERTCHAR>
		<STRING_INSERTLINE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_INSERTLINE>
		<STRING_LEFTARROW public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_LEFTARROW>
		<STRING_MENU public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_MENU>
		<STRING_MODESWITCH public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_MODESWITCH>
		<STRING_NEXT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_NEXT>
		<STRING_PAGEDOWN public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_PAGEDOWN>
		<STRING_PAGEUP public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_PAGEUP>
		<STRING_PAUSE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_PAUSE>
		<STRING_PREV public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_PREV>
		<STRING_PRINT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_PRINT>
		<STRING_PRINTSCREEN public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_PRINTSCREEN>
		<STRING_REDO public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_REDO>
		<STRING_RESET public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_RESET>
		<STRING_RIGHTARROW public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_RIGHTARROW>
		<STRING_SCROLLLOCK public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_SCROLLLOCK>
		<STRING_SELECT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_SELECT>
		<STRING_STOP public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_STOP>
		<STRING_SYSREQ public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_SYSREQ>
		<STRING_SYSTEM public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_SYSTEM>
		<STRING_UNDO public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_UNDO>
		<STRING_UPARROW public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_UPARROW>
		<STRING_USER public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</STRING_USER>
		<SUBTITLE public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</SUBTITLE>
		<T public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</T>
		<TAB public="1" static="1"><x path="UInt"/></TAB>
		<U public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</U>
		<UP public="1" static="1"><x path="UInt"/></UP>
		<V public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</V>
		<VOD public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</VOD>
		<W public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</W>
		<X public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</X>
		<Y public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</Y>
		<YELLOW public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</YELLOW>
		<Z public="1" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</Z>
		<capsLock public="1" set="null" static="1"><x path="Bool"/></capsLock>
		<hasVirtualKeyboard public="1" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</hasVirtualKeyboard>
		<numLock public="1" set="null" static="1"><x path="Bool"/></numLock>
		<physicalKeyboardType public="1" set="null" static="1">
			<e path="flash.ui.KeyboardType"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</physicalKeyboardType>
		<isAccessible public="1" set="method" static="1"><f a=""><x path="Bool"/></f></isAccessible>
	</class>
	<enum path="flash.ui.KeyboardType" params="" file="/usr/lib/haxe/std/flash/ui/KeyboardType.hx">
		<NONE/>
		<KEYPAD/>
		<ALPHANUMERIC/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.utils.IDataInput2" params="" file="/usr/lib/haxe/std/flash/utils/IDataInput2.hx" extern="1" interface="1"><extends path="flash.utils.IDataInput"/></class>
	<class path="flash.utils.IDataOutput2" params="" file="/usr/lib/haxe/std/flash/utils/IDataOutput2.hx" extern="1" interface="1"><extends path="flash.utils.IDataOutput"/></class>
	<class path="flash.utils.ByteArray" params="" file="/usr/lib/haxe/std/flash/utils/ByteArray.hx" extern="1">
		<implements path="flash.utils.IDataInput2"/>
		<implements path="flash.utils.IDataOutput2"/>
		<defaultObjectEncoding public="1" static="1"><x path="UInt"/></defaultObjectEncoding>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Void"/>
</f></writeUnsignedInt>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeShort public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<x path="Void"/>
</f></writeObject>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeMultiByte>
		<writeInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeFloat public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></writeBytes>
		<writeByte public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBoolean public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<uncompress public="1" set="method"><f a="?algorithm">
	<e path="flash.utils.CompressionAlgorithm"/>
	<x path="Void"/>
</f></uncompress>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<readUnsignedShort public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedInt>
		<readUnsignedByte public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedByte>
		<readUTFBytes public="1" set="method"><f a="length">
	<x path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<x path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></readBytes>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<inflate public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</inflate>
		<deflate public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</deflate>
		<compress public="1" set="method"><f a="?algorithm">
	<e path="flash.utils.CompressionAlgorithm"/>
	<x path="Void"/>
</f></compress>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clear>
		<atomicCompareAndSwapLength public="1">
			<f a="expectedLength:newLength">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</atomicCompareAndSwapLength>
		<atomicCompareAndSwapIntAt public="1">
			<f a="byteIndex:expectedValue:newValue">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</atomicCompareAndSwapIntAt>
		<shareable public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</shareable>
		<position public="1"><x path="UInt"/></position>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<length public="1"><x path="UInt"/></length>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<bytesAvailable public="1" set="null"><x path="UInt"/></bytesAvailable>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="flash.utils.CompressionAlgorithm" params="" file="/usr/lib/haxe/std/flash/utils/CompressionAlgorithm.hx">
		<ZLIB/>
		<LZMA/>
		<DEFLATE/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash11</e></m>
		</meta>
	</enum>
	<enum path="flash.utils.Endian" params="" file="/usr/lib/haxe/std/flash/utils/Endian.hx">
		<LITTLE_ENDIAN/>
		<BIG_ENDIAN/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<typedef path="flash.utils.Function" params="" file="/usr/lib/haxe/std/flash/utils/Function.hx"><d/></typedef>
	<class path="flash.utils.Namespace" params="" file="/usr/lib/haxe/std/flash/utils/Namespace.hx" extern="1">
		<uri public="1" set="null"><c path="String"/></uri>
		<prefix public="1" set="null"><d/></prefix>
		<new public="1" set="method"><f a="?prefix:?uri">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<typedef path="flash.utils.Object" params="" file="/usr/lib/haxe/std/flash/utils/Object.hx"><d/></typedef>
	<class path="flash.xml.XML" params="" file="/usr/lib/haxe/std/flash/xml/XML.hx" extern="1">
		<ignoreComments public="1" static="1"><x path="Bool"/></ignoreComments>
		<ignoreProcessingInstructions public="1" static="1"><x path="Bool"/></ignoreProcessingInstructions>
		<ignoreWhitespace public="1" static="1"><x path="Bool"/></ignoreWhitespace>
		<prettyIndent public="1" static="1"><x path="Int"/></prettyIndent>
		<prettyPrinting public="1" static="1"><x path="Bool"/></prettyPrinting>
		<defaultSettings public="1" set="method" static="1"><f a=""><d/></f></defaultSettings>
		<setSettings public="1" set="method" static="1"><f a="?o">
	<d/>
	<x path="Void"/>
</f></setSettings>
		<settings public="1" set="method" static="1"><f a=""><d/></f></settings>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></valueOf>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toJSON public="1" set="method">
			<f a="k">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</toJSON>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<setNotification public="1" set="method"><f a="f">
	<t path="flash.utils.Function"/>
	<d/>
</f></setNotification>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<x path="Void"/>
</f></setNamespace>
		<setName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setName>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setLocalName>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<notification public="1" set="method"><f a=""><t path="flash.utils.Function"/></f></notification>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></normalize>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<name public="1" set="method"><f a=""><t path="flash.utils.Object"/></f></name>
		<localName public="1" set="method"><f a=""><t path="flash.utils.Object"/></f></localName>
		<length public="1" set="method"><f a=""><x path="Int"/></f></length>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<hasSimpleContent public="1" set="method"><f a=""><x path="Bool"/></f></hasSimpleContent>
		<hasComplexContent public="1" set="method"><f a=""><x path="Bool"/></f></hasComplexContent>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></copy>
		<contains public="1" set="method"><f a="value">
	<d/>
	<x path="Bool"/>
</f></contains>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<childIndex public="1" set="method"><f a=""><x path="Int"/></f></childIndex>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<new public="1" set="method"><f a="?value">
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
		<haxe_dynamic><c path="flash.xml.XMLList"/></haxe_dynamic>
	</class>
	<class path="flash.xml.XMLList" params="" file="/usr/lib/haxe/std/flash/xml/XMLList.hx" extern="1">
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></valueOf>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toJSON public="1" set="method">
			<f a="k">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</toJSON>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<x path="Void"/>
</f></setNamespace>
		<setName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setName>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setLocalName>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></normalize>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<name public="1" set="method"><f a=""><t path="flash.utils.Object"/></f></name>
		<localName public="1" set="method"><f a=""><t path="flash.utils.Object"/></f></localName>
		<length public="1" set="method"><f a=""><x path="Int"/></f></length>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<hasSimpleContent public="1" set="method"><f a=""><x path="Bool"/></f></hasSimpleContent>
		<hasComplexContent public="1" set="method"><f a=""><x path="Bool"/></f></hasComplexContent>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></copy>
		<contains public="1" set="method"><f a="value">
	<d/>
	<x path="Bool"/>
</f></contains>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<childIndex public="1" set="method"><f a=""><x path="Int"/></f></childIndex>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<new public="1" set="method"><f a="?value">
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="graphics.Assets" params="" file="src/graphics/Graphics.hx" module="graphics.Graphics">
		<extends path="flash.display.BitmapData"/>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
		<meta><m n=":bitmap"><e>"bin/Assets.png"</e></m></meta>
	</class>
	<class path="graphics.AssetsXml" params="" file="src/graphics/Graphics.hx" module="graphics.Graphics">
		<extends path="flash.utils.ByteArray"/>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<meta><m n=":file"><e>"bin/Assets.xml"</e></m></meta>
	</class>
	<class path="graphics.Graphics" params="" file="src/graphics/Graphics.hx">
		<getTexture public="1" set="method" line="23"><f a="id">
	<c path="String"/>
	<t path="Texture"/>
</f></getTexture>
		<textureAtlas><t path="TextureAtlas"/></textureAtlas>
		<xml><t path="XML"/></xml>
		<texture><t path="Texture"/></texture>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
	</class>
	<abstract path="haxe.EnumFlags" params="T" file="/usr/lib/haxe/std/haxe/EnumFlags.hx">
		<from><x path="Int"/></from>
		<to><x path="Int"/></to>
		<haxe_doc>A typed interface for bit flags. This is not a real object, only a typed
	interface for an actual Int. Each flag can be tested/set with the
	corresponding enum instance. Up to 32 flags can be stored that way.
	
	Enum constructor indices are preserved from haxe syntax, so the first
	declared is index 0, the next index 1 etc. The methods are optimized if the
	enum instance is passed directly, e.g. as has(EnumCtor). Otherwise
	Type.enumIndex() reflection is used.</haxe_doc>
	</abstract>
	<class path="haxe.EnumTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="41" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum [e], including its path.
		
		If [e] is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If [e] is a sub-type of a haxe module, that module is not part of the
		package structure.
			
		If [e] has no package, the enum name is returned.
		
		If [e] is null, the result is unspecified.
		
		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="54" static="1"><f a="e:constr:?params">
	<x path="Enum"><c path="createByName.T"/></x>
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="createByName.T"/>
</f></createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="70" static="1"><f a="e:index:?params">
	<x path="Enum"><c path="createByIndex.T"/></x>
	<x path="Int"/>
	<c path="Array"><d/></c>
	<c path="createByIndex.T"/>
</f></createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="87" static="1"><f a="e">
	<x path="Enum"><c path="createAll.T"/></x>
	<c path="Array"><c path="createAll.T"/></c>
</f></createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="99" static="1"><f a="e">
	<x path="Enum"><c path="getConstructors.T"/></x>
	<c path="Array"><c path="String"/></c>
</f></getConstructors>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="114" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances [a] and [b] by value.
		
		Unlike [a] == [b], this function performs a deep equality check on the
		arguments of the constructors, if exists.
		
		If [a] or [b] are null, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="125" static="1"><f a="e">
	<x path="EnumValue"/>
	<c path="String"/>
</f></getName>
		<getParameters public="1" get="inline" set="null" line="139" static="1"><f a="e">
	<x path="EnumValue"/>
	<c path="Array"><d/></c>
</f></getParameters>
		<getIndex public="1" get="inline" set="null" line="151" static="1"><f a="e">
	<x path="EnumValue"/>
	<x path="Int"/>
</f></getIndex>
	</class>
	<class path="haxe.Int64" params="" file="/usr/lib/haxe/std/haxe/Int64.hx">
		<sub public="1" set="method" line="95" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></sub>
		<divMod set="method" line="120" static="1"><f a="modulus:divisor">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<a>
		<quotient><c path="haxe.Int64"/></quotient>
		<modulus><c path="haxe.Int64"/></modulus>
	</a>
</f></divMod>
		<uicompare set="method" line="203" static="1"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></uicompare>
		<toString set="method" line="42"><f a=""><c path="String"/></f></toString>
		<low><x path="Int"/></low>
		<high><x path="Int"/></high>
		<new set="method" line="29"><f a="high:low">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/lib/haxe/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<c path="Array"><d/></c>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>PosInfos is a magic type which can be used to generate position information
	into the output for debugging use.
	
	If a function has a final optional argument of this type, i.e.
	(..., ?pos:haxe.PosInfos), each call to that function which does not assign
	a value to that argument has its position added as call argument.
	
	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<abstract path="haxe.ds.HashMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx"/>
	<class path="haxe.ds.ObjectMap" params="K:V" file="/usr/lib/haxe/std/flash/_std/haxe/ds/ObjectMap.hx">
		<extends path="flash.utils.Dictionary"/>
		<iterator public="1" set="method" line="28"><f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.V"/></t></f></iterator>
		<keys public="1" set="method" line="24"><f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f></keys>
		<remove public="1" set="method" line="18"><f a="key">
	<c path="haxe.ds.ObjectMap.K"/>
	<x path="Bool"/>
</f></remove>
		<new public="1" set="method" line="4"><f a="?weakKeys">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds.StringMap" params="T" file="/usr/lib/haxe/std/flash/_std/haxe/ds/StringMap.hx">
		<remove public="1" set="method" line="44">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a hashtable entry. Returns [true] if
		there was such entry.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="40">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.</haxe_doc>
		</exists>
		<get public="1" set="method" line="36">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="haxe.ds.StringMap.T"/></t>
			</f>
			<haxe_doc>Get a value for the given key.</haxe_doc>
		</get>
		<set public="1" set="method" line="32">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set a value for the given key.</haxe_doc>
		</set>
		<h><c path="flash.utils.Dictionary"/></h>
		<new public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty hashtable.</haxe_doc>
		</new>
		<haxe_doc>Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.io.Bytes" params="" file="/usr/lib/haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="250" static="1"><f a="length">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<b><t path="haxe.io.BytesData"/></b>
		<length public="1" set="null"><x path="Int"/></length>
		<new set="method" line="29"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="/usr/lib/haxe/std/haxe/io/BytesData.hx"><c path="flash.utils.ByteArray"/></typedef>
	<class path="haxe.io.Eof" params="" file="/usr/lib/haxe/std/haxe/io/Eof.hx">
		<toString set="method" line="30">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<haxe_doc>This exception is raised when reading while data is no longer available in the [Input].</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="motion.actuators.IGenericActuator" params="" file="libSrc/actuate/motion/actuators/GenericActuator.hx" module="motion.actuators.GenericActuator" interface="1">
		<snapping public="1" set="method">
			<f a="?value">
				<x path="Bool"/>
				<c path="motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Snapping causes tween values to be rounded automatically
	 * @param	value		Whether tween values should be rounded (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</snapping>
		<smartRotation public="1" set="method">
			<f a="?value">
				<x path="Bool"/>
				<c path="motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Enabling smartRotation can prevent undesired results when tweening rotation values
	 * @param	value		Whether smart rotation should be enabled (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</smartRotation>
		<reverse public="1" set="method">
			<f a="?value">
				<x path="Bool"/>
				<c path="motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Sets if the tween should be handled in reverse
	 * @param	value		Whether the tween should be reversed (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</reverse>
		<repeat public="1" set="method">
			<f a="?times">
				<x path="Int"/>
				<c path="motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Repeats the tween after it finishes
	 * @param	times		The number of times you would like the tween to repeat, or -1 if you would like to repeat the tween indefinitely (Default is -1)
	 * @return		The current actuator instance</haxe_doc>
		</repeat>
		<reflect public="1" set="method">
			<f a="?value">
				<x path="Bool"/>
				<c path="motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Automatically changes the reverse value when the tween repeats. Repeat must be enabled for this to have any effect
	 * @param	value		Whether reflect should be enabled (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</reflect>
		<onUpdate public="1" set="method">
			<f a="handler:?parameters">
				<d/>
				<c path="Array"><d/></c>
				<c path="motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Defines a function which will be called when the tween updates
	 * @param	handler		The function you would like to be called
	 * @param	parameters		Parameters you would like to pass to the handler function when it is called
	 * @return		The current actuator instance</haxe_doc>
		</onUpdate>
		<onRepeat public="1" set="method">
			<f a="handler:?parameters">
				<d/>
				<c path="Array"><d/></c>
				<c path="motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Defines a function which will be called when the tween repeats
	 * @param	handler		The function you would like to be called
	 * @param	parameters		Parameters you would like to pass to the handler function when it is called
	 * @return		The current actuator instance</haxe_doc>
		</onRepeat>
		<onComplete public="1" set="method">
			<f a="handler:?parameters">
				<d/>
				<c path="Array"><d/></c>
				<c path="motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Defines a function which will be called when the tween finishes
	 * @param	handler		The function you would like to be called
	 * @param	parameters		Parameters you would like to pass to the handler function when it is called
	 * @return		The current actuator instance</haxe_doc>
		</onComplete>
		<ease public="1" set="method">
			<f a="easing">
				<c path="motion.easing.IEasing"/>
				<c path="motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Sets the easing which is used when running the tween
	 * @param	easing		An easing equation, like Elastic.easeIn or Quad.easeOut
	 * @return		The current actuator instance</haxe_doc>
		</ease>
		<delay public="1" set="method">
			<f a="duration">
				<x path="Float"/>
				<c path="motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Increases the delay before a tween is executed
	 * @param	duration		The amount of seconds to delay
	 * @return		The current actuator instance</haxe_doc>
		</delay>
		<autoVisible public="1" set="method">
			<f a="?value">
				<x path="Bool"/>
				<c path="motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc>* Flash performs faster when objects are set to visible = false rather than only alpha = 0. autoVisible toggles automatically based on alpha values
	 * @param	value		Whether autoVisible should be enabled (Default is true)
	 * @return		The current actuator instance</haxe_doc>
		</autoVisible>
	</class>
	<class path="motion.actuators.GenericActuator" params="" file="libSrc/actuate/motion/actuators/GenericActuator.hx">
		<implements path="motion.actuators.IGenericActuator"/>
		<stop public="1" set="method" line="388"><f a="properties:complete:sendEvent">
	<d/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></stop>
		<snapping public="1" set="method" line="372"><f a="?value">
	<x path="Bool"/>
	<c path="motion.actuators.IGenericActuator"/>
</f></snapping>
		<smartRotation public="1" set="method" line="351"><f a="?value">
	<x path="Bool"/>
	<c path="motion.actuators.IGenericActuator"/>
</f></smartRotation>
		<reverse public="1" set="method" line="330"><f a="?value">
	<x path="Bool"/>
	<c path="motion.actuators.IGenericActuator"/>
</f></reverse>
		<resume public="1" set="method" line="318"><f a=""><x path="Void"/></f></resume>
		<repeat public="1" set="method" line="303"><f a="?times">
	<x path="Int"/>
	<c path="motion.actuators.IGenericActuator"/>
</f></repeat>
		<reflect public="1" set="method" line="282"><f a="?value">
	<x path="Bool"/>
	<c path="motion.actuators.IGenericActuator"/>
</f></reflect>
		<pause public="1" set="method" line="270"><f a=""><x path="Void"/></f></pause>
		<onUpdate public="1" set="method" line="251"><f a="handler:?parameters">
	<d/>
	<c path="Array"><d/></c>
	<c path="motion.actuators.IGenericActuator"/>
</f></onUpdate>
		<onRepeat public="1" set="method" line="226"><f a="handler:?parameters">
	<d/>
	<c path="Array"><d/></c>
	<c path="motion.actuators.IGenericActuator"/>
</f></onRepeat>
		<onComplete public="1" set="method" line="195"><f a="handler:?parameters">
	<d/>
	<c path="Array"><d/></c>
	<c path="motion.actuators.IGenericActuator"/>
</f></onComplete>
		<move public="1" set="method" line="182"><f a=""><x path="Void"/></f></move>
		<ease public="1" set="method" line="173"><f a="easing">
	<c path="motion.easing.IEasing"/>
	<c path="motion.actuators.IGenericActuator"/>
</f></ease>
		<delay public="1" set="method" line="159"><f a="duration">
	<x path="Float"/>
	<c path="motion.actuators.IGenericActuator"/>
</f></delay>
		<complete set="method" line="126"><f a="?sendEvent">
	<x path="Bool"/>
	<x path="Void"/>
</f></complete>
		<change set="method" line="106"><f a=""><x path="Void"/></f></change>
		<autoVisible public="1" set="method" line="91"><f a="?value">
	<x path="Bool"/>
	<c path="motion.actuators.IGenericActuator"/>
</f></autoVisible>
		<apply public="1" set="method" line="59"><f a=""><x path="Void"/></f></apply>
		<special><x path="Bool"/></special>
		<_snapping><x path="Bool"/></_snapping>
		<_smartRotation><x path="Bool"/></_smartRotation>
		<_reverse><x path="Bool"/></_reverse>
		<_repeat><x path="Int"/></_repeat>
		<_reflect><x path="Bool"/></_reflect>
		<_onUpdateParams><c path="Array"><d/></c></_onUpdateParams>
		<_onUpdate><d/></_onUpdate>
		<_onRepeatParams><c path="Array"><d/></c></_onRepeatParams>
		<_onRepeat><d/></_onRepeat>
		<_onCompleteParams><c path="Array"><d/></c></_onCompleteParams>
		<_onComplete><d/></_onComplete>
		<_ease><c path="motion.easing.IEasing"/></_ease>
		<_delay><x path="Float"/></_delay>
		<_autoVisible><x path="Bool"/></_autoVisible>
		<target public="1"><d/></target>
		<properties public="1"><d/></properties>
		<id public="1"><c path="String"/></id>
		<duration public="1"><x path="Float"/></duration>
		<new public="1" set="method" line="39"><f a="target:duration:properties">
	<d/>
	<x path="Float"/>
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* @author Joshua Granick
 * @version 1.2</haxe_doc>
	</class>
	<class path="motion.actuators.SimpleActuator" params="" file="libSrc/actuate/motion/actuators/SimpleActuator.hx">
		<extends path="motion.actuators.GenericActuator"/>
		<actuators line="28" static="1"><c path="Array"><c path="motion.actuators.SimpleActuator"/></c></actuators>
		<actuatorsLength line="29" static="1"><x path="Int"/></actuatorsLength>
		<addedEvent line="30" static="1"><x path="Bool"/></addedEvent>
		<stage_onEnterFrame set="method" line="463" static="1"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Void"/>
</f></stage_onEnterFrame>
		<update set="method" line="276"><f a="currentTime">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<stop public="1" set="method" line="233" override="1"><f a="properties:complete:sendEvent">
	<d/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></stop>
		<resume public="1" set="method" line="216" override="1"><f a=""><x path="Void"/></f></resume>
		<pause public="1" set="method" line="203" override="1"><f a=""><x path="Void"/></f></pause>
		<onUpdate public="1" set="method" line="192" override="1"><f a="handler:?parameters">
	<d/>
	<c path="Array"><d/></c>
	<c path="motion.actuators.IGenericActuator"/>
</f></onUpdate>
		<move public="1" set="method" line="166" override="1"><f a=""><x path="Void"/></f></move>
		<initialize set="method" line="127"><f a=""><x path="Void"/></f></initialize>
		<delay public="1" set="method" line="117" override="1"><f a="duration">
	<x path="Float"/>
	<c path="motion.actuators.IGenericActuator"/>
</f></delay>
		<autoVisible public="1" set="method" line="87" override="1"><f a="?value">
	<x path="Bool"/>
	<c path="motion.actuators.IGenericActuator"/>
</f></autoVisible>
		<toggleVisible><x path="Bool"/></toggleVisible>
		<startTime><x path="Float"/></startTime>
		<setVisible><x path="Bool"/></setVisible>
		<sendChange><x path="Bool"/></sendChange>
		<propertyDetails><c path="Array"><c path="motion.actuators.PropertyDetails"/></c></propertyDetails>
		<pauseTime><x path="Float"/></pauseTime>
		<paused><x path="Bool"/></paused>
		<initialized><x path="Bool"/></initialized>
		<detailsLength><x path="Int"/></detailsLength>
		<cacheVisible><x path="Bool"/></cacheVisible>
		<active><x path="Bool"/></active>
		<timeOffset><x path="Float"/></timeOffset>
		<new public="1" set="method" line="49"><f a="target:duration:properties">
	<d/>
	<x path="Float"/>
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* @author Joshua Granick
 * @version 1.2</haxe_doc>
	</class>
	<class path="motion.easing.Expo" params="" file="libSrc/actuate/motion/easing/Expo.hx">
		<easeIn public="1" get="get_easeIn" set="null" static="1"><c path="motion.easing.IEasing"/></easeIn>
		<easeInOut public="1" get="get_easeInOut" set="null" static="1"><c path="motion.easing.IEasing"/></easeInOut>
		<easeOut public="1" get="get_easeOut" set="null" static="1"><c path="motion.easing.IEasing"/></easeOut>
		<get_easeIn set="method" line="19" static="1"><f a=""><c path="motion.easing.IEasing"/></f></get_easeIn>
		<get_easeInOut set="method" line="26" static="1"><f a=""><c path="motion.easing.IEasing"/></f></get_easeInOut>
		<get_easeOut set="method" line="33" static="1"><f a=""><c path="motion.easing.IEasing"/></f></get_easeOut>
		<haxe_doc>* @author Joshua Granick
 * @author Robert Penner / http://www.robertpenner.com/easing_terms_of_use.html</haxe_doc>
	</class>
	<class path="motion.easing.IEasing" params="" file="libSrc/actuate/motion/easing/IEasing.hx" interface="1">
		<ease public="1" set="method"><f a="t:b:c:d">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></ease>
		<calculate public="1" set="method"><f a="k">
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<haxe_doc>* @author Joshua Granick
 * @author Philippe / http://philippe.elsass.me</haxe_doc>
	</class>
	<class path="motion.easing.ExpoEaseOut" params="" file="libSrc/actuate/motion/easing/Expo.hx" module="motion.easing.Expo">
		<implements path="motion.easing.IEasing"/>
		<ease public="1" set="method" line="128"><f a="t:b:c:d">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></ease>
		<calculate public="1" set="method" line="121"><f a="k">
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<new public="1" set="method" line="114"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="motion.Actuate" params="" file="libSrc/actuate/motion/Actuate.hx">
		<defaultActuator public="1" line="24" static="1"><x path="Class"><c path="motion.actuators.GenericActuator"/></x></defaultActuator>
		<defaultEase public="1" line="25" static="1"><c path="motion.easing.IEasing"/></defaultEase>
		<targetLibraries line="26" static="1"><t path="motion.ObjectHash"><c path="Array"><c path="motion.actuators.GenericActuator"/></c></t></targetLibraries>
		<apply public="1" set="method" line="37" static="1">
			<f a="target:properties:?customActuator">
				<d/>
				<d/>
				<x path="Class"><c path="motion.actuators.GenericActuator"/></x>
				<c path="motion.actuators.IGenericActuator"/>
			</f>
			<haxe_doc><![CDATA[* Copies properties from one object to another. Conflicting tweens are stopped automatically
	 * @example		<code>Actuate.apply (MyClip, { alpha: 1 } );</code>
	 * @param	target		The object to copy to
	 * @param	properties		The object to copy from
	 * @param	customActuator		A custom actuator to use instead of the default (Optional)
	 * @return		The current actuator instance, which can be used to apply properties like onComplete or onUpdate handlers]]></haxe_doc>
		</apply>
		<effects public="1" set="method" line="64" static="1"><f a="target:duration:?overwrite">
	<c path="flash.display.DisplayObject"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="motion._Actuate.EffectsOptions"/>
</f></effects>
		<getLibrary set="method" line="73" static="1"><f a="target">
	<d/>
	<c path="Array"><c path="motion.actuators.GenericActuator"/></c>
</f></getLibrary>
		<motionPath public="1" set="method" line="94" static="1"><f a="target:duration:properties:?overwrite">
	<d/>
	<x path="Float"/>
	<d/>
	<x path="Bool"/>
	<c path="motion.actuators.IGenericActuator"/>
</f></motionPath>
		<pause public="1" set="method" line="106" static="1"><f a="target">
	<d/>
	<x path="Void"/>
</f></pause>
		<pauseAll public="1" set="method" line="127" static="1"><f a=""><x path="Void"/></f></pauseAll>
		<reset public="1" set="method" line="145" static="1"><f a=""><x path="Void"/></f></reset>
		<resume public="1" set="method" line="166" static="1"><f a="target">
	<d/>
	<x path="Void"/>
</f></resume>
		<resumeAll public="1" set="method" line="187" static="1"><f a=""><x path="Void"/></f></resumeAll>
		<stop public="1" set="method" line="209" static="1"><f a="target:?properties:?complete:?sendEvent">
	<d/>
	<d/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></stop>
		<timer public="1" set="method" line="261" static="1"><f a="duration:?customActuator">
	<x path="Float"/>
	<x path="Class"><c path="motion.actuators.GenericActuator"/></x>
	<c path="motion.actuators.IGenericActuator"/>
</f></timer>
		<transform public="1" set="method" line="278" static="1"><f a="target:?duration:?overwrite">
	<d/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="motion._Actuate.TransformOptions"/>
</f></transform>
		<tween public="1" set="method" line="297" static="1"><f a="target:duration:properties:?overwrite:?customActuator">
	<d/>
	<x path="Float"/>
	<d/>
	<x path="Bool"/>
	<x path="Class"><c path="motion.actuators.GenericActuator"/></x>
	<c path="motion.actuators.IGenericActuator"/>
</f></tween>
		<unload public="1" set="method" line="354" static="1"><f a="actuator">
	<c path="motion.actuators.GenericActuator"/>
	<x path="Void"/>
</f></unload>
		<update public="1" set="method" line="383" static="1"><f a="target:duration:?start:?end:?overwrite">
	<d/>
	<x path="Float"/>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<x path="Bool"/>
	<c path="motion.actuators.IGenericActuator"/>
</f></update>
		<haxe_doc>* @author Joshua Granick</haxe_doc>
	</class>
	<class path="motion._Actuate.EffectsOptions" params="" file="libSrc/actuate/motion/Actuate.hx" private="1" module="motion.Actuate">
		<filter public="1" set="method" line="432"><f a="reference:properties">
	<d/>
	<d/>
	<c path="motion.actuators.IGenericActuator"/>
</f></filter>
		<target><c path="flash.display.DisplayObject"/></target>
		<overwrite><x path="Bool"/></overwrite>
		<duration><x path="Float"/></duration>
		<new public="1" set="method" line="417"><f a="target:duration:overwrite">
	<c path="flash.display.DisplayObject"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="motion._Actuate.TransformOptions" params="" file="libSrc/actuate/motion/Actuate.hx" private="1" module="motion.Actuate">
		<sound public="1" set="method" line="489"><f a="?volume:?pan">
	<x path="Float"/>
	<x path="Float"/>
	<c path="motion.actuators.IGenericActuator"/>
</f></sound>
		<color public="1" set="method" line="468"><f a="?value:?strength:?alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="motion.actuators.IGenericActuator"/>
</f></color>
		<target><d/></target>
		<overwrite><x path="Bool"/></overwrite>
		<duration><x path="Float"/></duration>
		<new public="1" set="method" line="452"><f a="target:duration:overwrite">
	<d/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="motion._Actuate.TweenTimer" params="" file="libSrc/actuate/motion/Actuate.hx" private="1" module="motion.Actuate">
		<progress public="1"><x path="Float"/></progress>
		<new public="1" set="method" line="521"><f a="progress">
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="motion.ObjectHash" params="T" file="libSrc/actuate/motion/Actuate.hx" module="motion.Actuate"><c path="haxe.ds.ObjectMap">
	<d/>
	<c path="motion.ObjectHash.T"/>
</c></typedef>
	<class path="motion.MotionPath" params="" file="libSrc/actuate/motion/MotionPath.hx">
		<get_y set="method" line="75"><f a=""><c path="motion.IComponentPath"/></f></get_y>
		<get_x set="method" line="68"><f a=""><c path="motion.IComponentPath"/></f></get_x>
		<line public="1" set="method" line="51"><f a="x:y:?strength">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="motion.MotionPath"/>
</f></line>
		<bezier public="1" set="method" line="34"><f a="x:y:controlX:controlY:?strength">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="motion.MotionPath"/>
</f></bezier>
		<_y><c path="motion.ComponentPath"/></_y>
		<_x><c path="motion.ComponentPath"/></_x>
		<y public="1" get="get_y" set="null"><c path="motion.IComponentPath"/></y>
		<x public="1" get="get_x" set="null"><c path="motion.IComponentPath"/></x>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* @author Joshua Granick</haxe_doc>
	</class>
	<class path="motion.IComponentPath" params="" file="libSrc/actuate/motion/MotionPath.hx" module="motion.MotionPath" interface="1">
		<calculate public="1" set="method"><f a="k">
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<start public="1"><x path="Float"/></start>
		<end public="1" get="null" set="null"><x path="Float"/></end>
	</class>
	<class path="motion.ComponentPath" params="" file="libSrc/actuate/motion/MotionPath.hx" module="motion.MotionPath">
		<implements path="motion.IComponentPath"/>
		<get_end set="method" line="151"><f a=""><x path="Float"/></f></get_end>
		<calculate public="1" set="method" line="112"><f a="k">
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<addPath public="1" set="method" line="104"><f a="path">
	<c path="motion.BezierPath"/>
	<x path="Void"/>
</f></addPath>
		<totalStrength><x path="Float"/></totalStrength>
		<paths><c path="Array"><c path="motion.BezierPath"/></c></paths>
		<end public="1" get="get_end" set="null"><x path="Float"/></end>
		<start public="1"><x path="Float"/></start>
		<new public="1" set="method" line="95"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="motion.BezierPath" params="" file="libSrc/actuate/motion/MotionPath.hx" module="motion.MotionPath">
		<calculate public="1" set="method" line="201"><f a="start:k">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<strength public="1"><x path="Float"/></strength>
		<end public="1"><x path="Float"/></end>
		<control public="1"><x path="Float"/></control>
		<new public="1" set="method" line="192"><f a="end:control:strength">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="motion.LinearPath" params="" file="libSrc/actuate/motion/MotionPath.hx" module="motion.MotionPath">
		<extends path="motion.BezierPath"/>
		<calculate public="1" set="method" line="221" override="1"><f a="start:k">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<new public="1" set="method" line="214"><f a="end:strength">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="motion.actuators.FilterActuator" params="" file="libSrc/actuate/motion/actuators/FilterActuator.hx">
		<extends path="motion.actuators.SimpleActuator"/>
		<update set="method" line="93" override="1"><f a="currentTime">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<initialize set="method" line="70" override="1"><f a=""><x path="Void"/></f></initialize>
		<apply public="1" set="method" line="51" override="1"><f a=""><x path="Void"/></f></apply>
		<filterIndex><x path="Int"/></filterIndex>
		<filterClass><x path="Class"><c path="flash.filters.BitmapFilter"/></x></filterClass>
		<filter><c path="flash.filters.BitmapFilter"/></filter>
		<new public="1" set="method" line="21"><f a="target:duration:properties">
	<d/>
	<x path="Float"/>
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* @author Joshua Granick
 * @version 1.2</haxe_doc>
	</class>
	<class path="motion.actuators.MethodActuator" params="" file="libSrc/actuate/motion/actuators/MethodActuator.hx">
		<extends path="motion.actuators.SimpleActuator"/>
		<update set="method" line="109" override="1"><f a="currentTime">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<initialize set="method" line="81" override="1"><f a=""><x path="Void"/></f></initialize>
		<complete set="method" line="58" override="1"><f a="?sendEvent">
	<x path="Bool"/>
	<x path="Void"/>
</f></complete>
		<apply public="1" set="method" line="43" override="1"><f a=""><x path="Void"/></f></apply>
		<tweenProperties><d/></tweenProperties>
		<currentParameters><c path="Array"><d/></c></currentParameters>
		<new public="1" set="method" line="15"><f a="target:duration:properties">
	<d/>
	<x path="Float"/>
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* @author Joshua Granick
 * @version 1.2</haxe_doc>
	</class>
	<class path="motion.actuators.MotionPathActuator" params="" file="libSrc/actuate/motion/actuators/MotionPathActuator.hx">
		<extends path="motion.actuators.SimpleActuator"/>
		<update set="method" line="92" override="1"><f a="currentTime">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<initialize set="method" line="47" override="1"><f a=""><x path="Void"/></f></initialize>
		<apply public="1" set="method" line="20" override="1"><f a=""><x path="Void"/></f></apply>
		<new public="1" set="method" line="13"><f a="target:duration:properties">
	<d/>
	<x path="Float"/>
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* @author Joshua Granick</haxe_doc>
	</class>
	<class path="motion.actuators.PropertyDetails" params="" file="libSrc/actuate/motion/actuators/PropertyDetails.hx">
		<target public="1"><d/></target>
		<start public="1"><x path="Float"/></start>
		<propertyName public="1"><c path="String"/></propertyName>
		<isField public="1"><x path="Bool"/></isField>
		<change public="1"><x path="Float"/></change>
		<new public="1" set="method" line="19"><f a="target:propertyName:start:change:?isField">
	<d/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* @author Joshua Granick</haxe_doc>
	</class>
	<class path="motion.actuators.PropertyPathDetails" params="" file="libSrc/actuate/motion/actuators/MotionPathActuator.hx" module="motion.actuators.MotionPathActuator">
		<extends path="motion.actuators.PropertyDetails"/>
		<path public="1"><c path="motion.IComponentPath"/></path>
		<new public="1" set="method" line="245"><f a="target:propertyName:path:?isField">
	<d/>
	<c path="String"/>
	<c path="motion.IComponentPath"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="motion.actuators.TransformActuator" params="" file="libSrc/actuate/motion/actuators/TransformActuator.hx">
		<extends path="motion.actuators.SimpleActuator"/>
		<update set="method" line="175" override="1"><f a="currentTime">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<initializeSound set="method" line="146"><f a=""><x path="Void"/></f></initializeSound>
		<initializeColor set="method" line="70"><f a=""><x path="Void"/></f></initializeColor>
		<initialize set="method" line="50" override="1"><f a=""><x path="Void"/></f></initialize>
		<apply public="1" set="method" line="31" override="1"><f a=""><x path="Void"/></f></apply>
		<tweenSoundTransform><c path="flash.media.SoundTransform"/></tweenSoundTransform>
		<tweenColorTransform><c path="flash.geom.ColorTransform"/></tweenColorTransform>
		<endSoundTransform><c path="flash.media.SoundTransform"/></endSoundTransform>
		<endColorTransform><c path="flash.geom.ColorTransform"/></endColorTransform>
		<new public="1" set="method" line="24"><f a="target:duration:properties">
	<d/>
	<x path="Float"/>
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* @author Joshua Granick
 * @version 1.2</haxe_doc>
	</class>
	<class path="motion.easing.ExpoEaseIn" params="" file="libSrc/actuate/motion/easing/Expo.hx" module="motion.easing.Expo">
		<implements path="motion.easing.IEasing"/>
		<ease public="1" set="method" line="60"><f a="t:b:c:d">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></ease>
		<calculate public="1" set="method" line="53"><f a="k">
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<new public="1" set="method" line="46"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="motion.easing.ExpoEaseInOut" params="" file="libSrc/actuate/motion/easing/Expo.hx" module="motion.easing.Expo">
		<implements path="motion.easing.IEasing"/>
		<ease public="1" set="method" line="92"><f a="t:b:c:d">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></ease>
		<calculate public="1" set="method" line="80"><f a="k">
	<x path="Float"/>
	<x path="Float"/>
</f></calculate>
		<new public="1" set="method" line="73"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="nape.Config" params="" file="libSrc/napeLib/nape/Config.hx">
		<epsilon public="1" line="15" static="1"><x path="Float"/></epsilon>
		<fluidAngularDragFriction public="1" line="27" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Parameter used in computing shape fluid angular drag coeffecient.
     * <br/><br/>
     * Defines the contribution to the drag coeffecient due to Material dynamicFriction
     * <br/><br/>
     * This global value must be set as the very first thing to ensure all Shapes
     * use your intended value.
     * <br/><br/>
     * This parameter has units kg/px
     * @default 2.5 kg/px]]></haxe_doc>
		</fluidAngularDragFriction>
		<fluidAngularDrag public="1" line="40" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Parameter used in computing shape fluid angular drag coeffecient.
     * <br/><br/>
     * Defines the contribution to the drag coeffecient due to shape's surface
     * area rotating into a fluid.
     * <br/><br/>
     * This global value must be set as the very first thing to ensure all Shapes
     * use your intended value.
     * <br/><br/>
     * This parameter has units kg/px
     * @default 100kg/px]]></haxe_doc>
		</fluidAngularDrag>
		<fluidVacuumDrag public="1" line="53" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Parameter used in computing fluid drags.
     * <br/><br/>
     * Defines an added weight for scaling the contribution of forward drag due
     * to leaving a vaccuum behind the shape pulling it back.
     * <br/><br/>
     * This global value must be set as the very first thing to ensure all Shapes
     * use your intended value.
     * <br/><br/>
     * This parameter has no units.
     * @default 0.5]]></haxe_doc>
		</fluidVacuumDrag>
		<fluidLinearDrag public="1" line="62" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Parameter used in computing shapes linear drag in fluid.
     * <br/><br/>
     * Used in determining the amount of linear drag for the shape based on forward profile.
     * <br/><br/>
     * This parameter has units kg/px
     * @default 0.5kg/px]]></haxe_doc>
		</fluidLinearDrag>
		<collisionSlop public="1" line="69" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Amount of overlap permitted between Shapes for collisions.
     * <br/><br/>
     * This parameter has units of pixels.
     * @default 0.2px]]></haxe_doc>
		</collisionSlop>
		<collisionSlopCCD public="1" line="77" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Amount of overlap permitted between Shapes before CCD kicks in.
     * <br/><br/>
     * This parameter has units of pixels, and should always be larger
     * than collisionSlop parameter.
     * @default 0.5px]]></haxe_doc>
		</collisionSlopCCD>
		<distanceThresholdCCD public="1" line="88" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Biased distance treshold for CCD collisions.
     * <br/><br/>
     * In CCD collision routines, two Shapes will be considered intersecting
     * when the distance between them + collisionSlopCCD falls below this
     * value.
     * <br/><br/>
     * This parameter has units of pixels, and should always be > 0
     * @default 0.05px]]></haxe_doc>
		</distanceThresholdCCD>
		<staticCCDLinearThreshold public="1" line="104" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Linear sweep threshold-ratio for static CCD collisions
     * <br/><br/>
     * In deciding what non-bullet objects should be collided continuously against
     * static/kinematic objects, the linear speed of the body is considered.
     * <code>
     * ccdCollide if: bodyLinearSpeed * deltaTime > threshold * bodyRadius
     * </code>
     * Intuitively, a value of 0.5 would mean that a body, in the worst case scenario
     * will be permitted to move half of its width in a single time step, before CCD
     * is enabled for this reason.
     * <br/><br/>
     * This parameter has no units.
     * @default 0.05]]></haxe_doc>
		</staticCCDLinearThreshold>
		<staticCCDAngularThreshold public="1" line="121" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Angular sweep threshold for static CCD collisions
     * <br><br/>
     * In deciding what non-bullet objects should be collided continuously against
     * static/kinematic objects, the angular speed of the body is considered.
     * <code>
     * ccdCollide if: bodyAngularSpeed * deltaTime > threshold
     * </code>
     * Intuitively, a value of 0.5 would mean that a body would have to rotate more than
     * 0.5 radians in a single time step, before CCD is enabled for this reason. Noting that
     * at 60fps physics, the body would need an angularVel greater than 30rad/s for this
     * limit of 0.5 to be reached; the default is far smaller.
     * <br/><br/>
     * This parameter has units of rad.
     * @default 0.005rad]]></haxe_doc>
		</staticCCDAngularThreshold>
		<bulletCCDLinearThreshold public="1" line="136" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Linear sweep threshold-ratio for bullet CCD collisions
     * <br/><br/>
     * A dynamic body marked as a bullet, will not necessarigly always be collided
     * with continuously.
     * <br/><br/>
     * Should a body be moving, or rotating fast enough to pass the tests determined
     * by staticCCD#Threshold parameters, and is marked as a bullet, it must then
     * have its velocities checked against the equivalent bullet thresholds to actually
     * be collided continuously against other dynamic bodies too.
     * <br/><br/>
     * This parameter has no units.
     * @default 0.125]]></haxe_doc>
		</bulletCCDLinearThreshold>
		<bulletCCDAngularThreshold public="1" line="145" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Angular sweep threshold for bullet CCD collisions.
     * <br/><br/>
     * See description of bulletCCDLinearThreshold.
     * <br/><br/>
     * This parameter has units of rad.
     * @default 0.0125rad]]></haxe_doc>
		</bulletCCDAngularThreshold>
		<dynamicSweepLinearThreshold public="1" line="157" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Relative linear threshold for dynamic-dynamic sweeps.
     * <br/><br/>
     * When performing dynamic-dynamic sweep of Body shapes during CCD collision phase,
     * should the relative velocity of the bodies fall beneath this magnitude, they
     * may be considered (based on angular velocities also) to be moving together, and
     * this specific CCD test will be skipped.
     * <br/><br/>
     * This parameter has units of px/s
     * @default 17px/s]]></haxe_doc>
		</dynamicSweepLinearThreshold>
		<dynamicSweepAngularThreshold public="1" line="174" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Relative angular bias threshold for dynamic-dynamic sweeps.
     * <br/><br/>
     * When performing dynamic-dynamic sweep of Body shapes during CCD collision phase,
     * should the relative angular velocity (weighted by the shape bias values) fall
     * beneath this magnitude, they may be considered (based on linear velocities also) to
     * be moving together, and this specific CCD test will be skipped.
     * <br/><br/>
     * The shape bias, is an internal value which indicates the 'amount of radius' of
     * a shape about the centre of rotation that can be considered to change under rotations.
     * eg: A circle at origin has a bias of 0 (Its rotation has no effect on sweeps)
     * whilst A circle far from the origin may have a large bias.
     * <br/><br/>
     * This parameter has units of px.rad/s
     * @default 0.6px.rad/s]]></haxe_doc>
		</dynamicSweepAngularThreshold>
		<angularCCDSlipScale public="1" line="188" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Angular velocity scaling during CCD slips.
     * <br/><br/>
     * In rare cases, a Body can be moving in such a way that we fail to compute a perfect
     * time of impact; generally when a thin box-like object is rotating very quickly. The
     * time of impact solver in Nape attempts to avoid impacts which are seperating; so that
     * we can catch true impact times; but in a 'slip' case we are unable to achieve this and
     * to avoid a possible tunneling from the other side during later operations we will in
     * these rare cases scale down the angular velocity of a Body by this parameter.
     * <br/><br/>
     * This parameter has no units.
     * @default 0.75]]></haxe_doc>
		</angularCCDSlipScale>
		<arbiterExpirationDelay public="1" line="200" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Expiration delay length for collision arbiter destruction.
     * <br/><br/>
     * In unstable physics conditions, two colliding shapes may jitter such as to constantly
     * seperate, and then come back together again. This parameter controls the number of time
     * steps during which we will delay this destruction so that cached impulse values may
     * persist and improve stability of strenuous simulations.
     * <br/><br/>
     * This parameter has units of 'steps' I suppose.
     * @default 6steps]]></haxe_doc>
		</arbiterExpirationDelay>
		<staticFrictionThreshold public="1" line="210" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Contact velocity threshold for static-dynamic friction
     * <br/><br/>
     * This is the threshold on projected contact velocities at which Nape will use
     * dynamic friction Mateiral values, in place of static friction Material values.
     * <br/><br/>
     * This parameter has units of px/s
     * @default 2px/s]]></haxe_doc>
		</staticFrictionThreshold>
		<elasticThreshold public="1" line="222" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Contact velocity threshold for elastic collisions
     * <br/><br/>
     * This is the threshold on weighted projected normal-contact velocities at which Nape will
     * decide to stop using elastic collisions. Nape will take the normal velocities at contact
     * and scale by the combined elasticity coeffecient for the Arbiter, if this value falls
     * below the threshold, then elasticity is ignored for stability in stacking.
     * <br/><br/>
     * This parameter has units of px/s
     * @default 20px/s]]></haxe_doc>
		</elasticThreshold>
		<sleepDelay public="1" line="234" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Sleep delay for stationary bodies.
     * <br/><br/>
     * By default, Nape considers a body to be stationary even if it has a very small linear
     * or angular velocity. This parameter controls how many steps such a Body will continue
     * to be simulated for, before being put to sleep (Assuming everything else in the island
     * is also stationary for a sufficiently long time).
     * <br/><br/>
     * This parameter has units of 'steps' I suppose.
     * @default 60steps]]></haxe_doc>
		</sleepDelay>
		<linearSleepThreshold public="1" line="244" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Linear speed threshold for sleeping of Bodies.
     * <br/><br/>
     * A body in Nape will be considered stationary only if its linear velocity has magnitude
     * under this threshold.
     * <br/><br/>
     * This parameter has units of px/s
     * @default 0.2px/s]]></haxe_doc>
		</linearSleepThreshold>
		<angularSleepThreshold public="1" line="258" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Angular speed threshold for sleeping of Bodies.
     * <br/><br/>
     * A body in Nape will be considered stationary only if its angular velocity, multiplied
     * by the body radius (never under-estimated) about the origin, falls below this threshold.
     * <br/><br/>
     * The body radius scaling, ensures that a very large body needs to be rotating more slowly
     * to be considered stationary than a very small body. Intuitively we're designating this
     * a threshold on the maximum tangentenial velocity of the body due to rotation.
     * <br/><br/>
     * This parameter has units of px.rad/s
     * @default 0.4px.rad/s]]></haxe_doc>
		</angularSleepThreshold>
		<contactBiasCoef public="1" line="269" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Fraction of contact slop resolved per-step for dynamic-dynamic discrete collisions.
     * <br/><br/>
     * This value determines, in the case of two non-continuously colliding dynamic objects
     * the fraction of the contact overlap that will attempt to be resolved during positional
     * iterations.
     * <br/><br/>
     * This parameter has units of 1/'step' I suppose.
     * @default 0.3/step]]></haxe_doc>
		</contactBiasCoef>
		<contactStaticBiasCoef public="1" line="279" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Fraction of contact slop resolved per-step for static/kinematic discrete collisions.
     * <br/><br/>
     * See description of contactBiasCoef; this is the coeffecient for non-continuous collisions
     * between a dynamic, and a static or kinematic object.
     * <br/><br/>
     * This parameter has units of 1/'step' I suppose.
     * @default 0.6/step]]></haxe_doc>
		</contactStaticBiasCoef>
		<contactContinuousBiasCoef public="1" line="289" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Fraction of contact slop resolved per-step for dynamic-dynamic continuous collisions.
     * <br/><br/>
     * See description of contactBiasCoef; this is the coeffecient for continuous collisions
     * between two dynamic bodies.
     * <br/><br/>
     * This parameter has units of 1/'step' I suppose.
     * @default 0.4/step]]></haxe_doc>
		</contactContinuousBiasCoef>
		<contactContinuousStaticBiasCoef public="1" line="299" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Fraction of contact slop resolved per-step for static/kinematic continuous collisions.
     * <br/><br/>
     * See description of contactBiasCoef; this is the coeffecient for continuous collisions
     * between a dynamic, and a static or kinematic object.
     * <br/><br/>
     * This parameter has units of 1/'step' I suppose.
     * @default 0.5/step]]></haxe_doc>
		</contactContinuousStaticBiasCoef>
		<constraintLinearSlop public="1" line="309" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Amount of linear slop permitted in constraints.
     * <br/><br/>
     * A constraint will be considered to be 'relaxed' during positional iterations
     * only if the linear error falls below this threshold.
     * <br/><br/>
     * Assuming a 'sensible' constraint, this has units of px
     * @default 0.1px]]></haxe_doc>
		</constraintLinearSlop>
		<constraintAngularSlop public="1" line="319" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Amount of angular slop permitted in constraints.
     * <br/><br/>
     * A constraint will be considered to be 'relaxed' during positional iterations
     * only if the angular error falls below this threshold.
     * <br/><br/>
     * Assuming a 'sensible' constraint, this has units of rad
     * @default 1e-3rad]]></haxe_doc>
		</constraintAngularSlop>
		<illConditionedThreshold public="1" line="332" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Ill-conditioned threshold for 2-contact collision constraints.
     * <br/><br/>
     * This is a threshold on the measure of ill-conditioning of the effective-mass-matrix
     * in a 2-contact collision at which the contact manifold will be forced into a 1-contact
     * constraint. This can occur quite readily when two contact points are almost exactly equal
     * or in certain other conditions where the mathematics quite simply breaks down when using
     * a block solver.
     * <br/><br/>
     * This parameter has no units.
     * @default 2e+8]]></haxe_doc>
		</illConditionedThreshold>
		<new set="method" line="9">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Configuration parameters for Nape</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<typedef path="nape.TArray" params="T" file="libSrc/napeLib/nape/TArray.hx">
		<c path="flash.Vector"><c path="nape.TArray.T"/></c>
		<haxe_doc><![CDATA[* Platform specific Array type.
 * <br/><br/>
 * For flash10+ This is <code>flash.Vector&lt;T&gt;</code>, and otherwise
 * <code>Array&lt;T&gt;</code>.
 * <pre>
 * #if flash10
 *     typedef TArray&lt;T&gt; = flash.Vector&lt;T&gt;;
 * #else
 *     typedef TArray&lt;T&gt; = Array&lt;T&gt;;
 * #end
 * </pre>]]></haxe_doc>
	</typedef>
	<class path="nape.callbacks.Callback" params="" file="libSrc/napeLib/nape/callbacks/Callback.hx">
		<toString public="1" set="method" line="214">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<get_listener get="inline" set="null" line="198"><f a=""><c path="nape.callbacks.Listener"/></f></get_listener>
		<listener public="1" get="get_listener" set="null"><c path="nape.callbacks.Listener"/></listener>
		<get_event get="inline" set="null" line="190"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_event>
		<event public="1" get="get_event" set="null">
			<c path="nape.callbacks.CbEvent"/>
			<haxe_doc>* CbEvent type this callback was generated for.</haxe_doc>
		</event>
		<zpp_inner public="1">
			<c path="zpp_nape.callbacks.ZPP_Callback"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="204"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* Base type for Callback event objects.
 * <br/><br/>
 * Callback objects are automatically reused and you should not keep references
 * to them.]]></haxe_doc>
	</class>
	<class path="nape.callbacks.BodyCallback" params="" file="libSrc/napeLib/nape/callbacks/BodyCallback.hx">
		<extends path="nape.callbacks.Callback"/>
		<toString public="1" set="method" line="198" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<get_body get="inline" set="null" line="192"><f a=""><c path="nape.phys.Body"/></f></get_body>
		<body public="1" get="get_body" set="null"><c path="nape.phys.Body"/></body>
		<new public="1" set="method" line="184">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Callback object for Body type events.
 * <br/><br/>
 * This, like all other callback objects are automatically reused
 * and you should not keep any reference to them.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.Listener" params="" file="libSrc/napeLib/nape/callbacks/Listener.hx">
		<toString public="1" set="method" line="276">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<set_space get="inline" set="null" line="257"><f a="space">
	<t path="Null"><c path="nape.space.Space"/></t>
	<t path="Null"><c path="nape.space.Space"/></t>
</f></set_space>
		<get_space get="inline" set="null" line="254"><f a=""><t path="Null"><c path="nape.space.Space"/></t></f></get_space>
		<space public="1" get="get_space" set="set_space"><t path="Null"><c path="nape.space.Space"/></t></space>
		<set_precedence get="inline" set="null" line="225"><f a="precedence">
	<x path="Int"/>
	<x path="Int"/>
</f></set_precedence>
		<get_precedence get="inline" set="null" line="222"><f a=""><x path="Int"/></f></get_precedence>
		<precedence public="1" get="get_precedence" set="set_precedence"><x path="Int"/></precedence>
		<set_event get="inline" set="null" line="198"><f a="event">
	<c path="nape.callbacks.CbEvent"/>
	<c path="nape.callbacks.CbEvent"/>
</f></set_event>
		<get_event get="inline" set="null" line="195"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_event>
		<event public="1" get="get_event" set="set_event"><c path="nape.callbacks.CbEvent"/></event>
		<get_type get="inline" set="null" line="187"><f a=""><c path="nape.callbacks.ListenerType"/></f></get_type>
		<type public="1" get="get_type" set="null">
			<c path="nape.callbacks.ListenerType"/>
			<haxe_doc>* The sub-type of this listener.</haxe_doc>
		</type>
		<zpp_inner public="1">
			<c path="zpp_nape.callbacks.ZPP_Listener"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="237"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Base type for all Nape callback listeners.</haxe_doc>
	</class>
	<class path="nape.callbacks.BodyListener" params="" file="libSrc/napeLib/nape/callbacks/BodyListener.hx">
		<extends path="nape.callbacks.Listener"/>
		<set_handler get="inline" set="null" line="211"><f a="handler">
	<f a="">
		<c path="nape.callbacks.BodyCallback"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="nape.callbacks.BodyCallback"/>
		<x path="Void"/>
	</f>
</f></set_handler>
		<get_handler get="inline" set="null" line="208"><f a=""><f a="">
	<c path="nape.callbacks.BodyCallback"/>
	<x path="Void"/>
</f></f></get_handler>
		<handler public="1" get="get_handler" set="set_handler"><f a="">
	<c path="nape.callbacks.BodyCallback"/>
	<x path="Void"/>
</f></handler>
		<set_options get="inline" set="null" line="197"><f a="options">
	<c path="nape.callbacks.OptionType"/>
	<c path="nape.callbacks.OptionType"/>
</f></set_options>
		<get_options get="inline" set="null" line="194"><f a=""><c path="nape.callbacks.OptionType"/></f></get_options>
		<options public="1" get="get_options" set="set_options">
			<c path="nape.callbacks.OptionType"/>
			<haxe_doc><![CDATA[* The OptionType used to match against Bodies.
     * <br/><br/>
     * When added to the same Space, any Body who's CbType list matches
     * against this OptionType will be issued a callback when the relevant
     * event occurs.]]></haxe_doc>
		</options>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="248"><f a="event:options:handler:?precedence">
	<c path="nape.callbacks.CbEvent"/>
	<t path="Null"><d/></t>
	<f a="">
		<c path="nape.callbacks.BodyCallback"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* Event listener for Body type events.
 * <br/><br/>
 * The events that can be caught are WAKE and SLEEP type events.
 * Theses listeners will only operate on Bodys, not Interactors in general.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.CbEvent" params="" file="libSrc/napeLib/nape/callbacks/CbEvent.hx">
		<BEGIN public="1" get="get_BEGIN" set="null" static="1"><c path="nape.callbacks.CbEvent"/></BEGIN>
		<get_BEGIN get="inline" set="null" line="206" static="1"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_BEGIN>
		<ONGOING public="1" get="get_ONGOING" set="null" static="1"><c path="nape.callbacks.CbEvent"/></ONGOING>
		<get_ONGOING get="inline" set="null" line="220" static="1"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_ONGOING>
		<END public="1" get="get_END" set="null" static="1"><c path="nape.callbacks.CbEvent"/></END>
		<get_END get="inline" set="null" line="233" static="1"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_END>
		<WAKE public="1" get="get_WAKE" set="null" static="1"><c path="nape.callbacks.CbEvent"/></WAKE>
		<get_WAKE get="inline" set="null" line="246" static="1"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_WAKE>
		<SLEEP public="1" get="get_SLEEP" set="null" static="1"><c path="nape.callbacks.CbEvent"/></SLEEP>
		<get_SLEEP get="inline" set="null" line="259" static="1"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_SLEEP>
		<BREAK public="1" get="get_BREAK" set="null" static="1"><c path="nape.callbacks.CbEvent"/></BREAK>
		<get_BREAK get="inline" set="null" line="272" static="1"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_BREAK>
		<PRE public="1" get="get_PRE" set="null" static="1"><c path="nape.callbacks.CbEvent"/></PRE>
		<get_PRE get="inline" set="null" line="286" static="1"><f a=""><c path="nape.callbacks.CbEvent"/></f></get_PRE>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of possible callback event types.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.CbType" params="" file="libSrc/napeLib/nape/callbacks/CbType.hx">
		<ANY_BODY public="1" get="get_ANY_BODY" set="null" static="1"><c path="nape.callbacks.CbType"/></ANY_BODY>
		<get_ANY_BODY get="inline" set="null" line="212" static="1"><f a=""><c path="nape.callbacks.CbType"/></f></get_ANY_BODY>
		<ANY_CONSTRAINT public="1" get="get_ANY_CONSTRAINT" set="null" static="1"><c path="nape.callbacks.CbType"/></ANY_CONSTRAINT>
		<get_ANY_CONSTRAINT get="inline" set="null" line="225" static="1"><f a=""><c path="nape.callbacks.CbType"/></f></get_ANY_CONSTRAINT>
		<ANY_SHAPE public="1" get="get_ANY_SHAPE" set="null" static="1"><c path="nape.callbacks.CbType"/></ANY_SHAPE>
		<get_ANY_SHAPE get="inline" set="null" line="238" static="1"><f a=""><c path="nape.callbacks.CbType"/></f></get_ANY_SHAPE>
		<ANY_COMPOUND public="1" get="get_ANY_COMPOUND" set="null" static="1"><c path="nape.callbacks.CbType"/></ANY_COMPOUND>
		<get_ANY_COMPOUND get="inline" set="null" line="251" static="1"><f a=""><c path="nape.callbacks.CbType"/></f></get_ANY_COMPOUND>
		<toString public="1" set="method" line="338">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<get_constraints get="inline" set="null" line="329"><f a=""><c path="nape.constraint.ConstraintList"/></f></get_constraints>
		<constraints public="1" get="get_constraints" set="null"><c path="nape.constraint.ConstraintList"/></constraints>
		<get_interactors get="inline" set="null" line="314"><f a=""><c path="nape.phys.InteractorList"/></f></get_interactors>
		<interactors public="1" get="get_interactors" set="null"><c path="nape.phys.InteractorList"/></interactors>
		<get_userData get="inline" set="null" line="299"><f a=""><d><d/></d></f></get_userData>
		<userData public="1" get="get_userData" set="null"><d><d/></d></userData>
		<excluding public="1" set="method" line="283"><f a="excludes">
	<d/>
	<c path="nape.callbacks.OptionType"/>
</f></excluding>
		<including public="1" set="method" line="267"><f a="includes">
	<d/>
	<c path="nape.callbacks.OptionType"/>
</f></including>
		<get_id get="inline" set="null" line="189"><f a=""><x path="Int"/></f></get_id>
		<id public="1" get="get_id" set="null">
			<x path="Int"/>
			<haxe_doc>* Unique identifier for this CbType.</haxe_doc>
		</id>
		<zpp_inner public="1">
			<c path="zpp_nape.callbacks.ZPP_CbType"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="197"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* Callback Type applied to Interactors and Constraints.
 * <br/><br/>
 * Callback types are ranged over by listeners.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.CbTypeIterator" params="" file="libSrc/napeLib/nape/callbacks/CbTypeIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.callbacks.CbTypeIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1"><f a="list">
	<c path="nape.callbacks.CbTypeList"/>
	<c path="nape.callbacks.CbTypeIterator"/>
</f></get>
		<next public="1" get="inline" set="null" line="264"><f a=""><c path="nape.callbacks.CbType"/></f></next>
		<hasNext public="1" get="inline" set="null" line="240"><f a=""><x path="Bool"/></f></hasNext>
		<zpp_next public="1">
			<c path="nape.callbacks.CbTypeIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.callbacks.CbTypeList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.CbTypeList" params="" file="libSrc/napeLib/nape/callbacks/CbTypeList.hx">
		<fromArray public="1" set="method" line="304" static="1"><f a="array">
	<c path="Array"><c path="nape.callbacks.CbType"/></c>
	<c path="nape.callbacks.CbTypeList"/>
</f></fromArray>
		<fromVector public="1" set="method" line="328" static="1"><f a="vector">
	<c path="flash.Vector"><c path="nape.callbacks.CbType"/></c>
	<c path="nape.callbacks.CbTypeList"/>
</f></fromVector>
		<filter public="1" set="method" line="779"><f a="lambda">
	<f a="">
		<c path="nape.callbacks.CbType"/>
		<x path="Bool"/>
	</f>
	<c path="nape.callbacks.CbTypeList"/>
</f></filter>
		<foreach public="1" get="inline" set="null" line="732"><f a="lambda">
	<f a="">
		<c path="nape.callbacks.CbType"/>
		<x path="Void"/>
	</f>
	<c path="nape.callbacks.CbTypeList"/>
</f></foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<merge public="1" set="method" line="684"><f a="xs">
	<c path="nape.callbacks.CbTypeList"/>
	<x path="Void"/>
</f></merge>
		<copy public="1" set="method" line="662"><f a="?deep">
	<x path="Bool"/>
	<c path="nape.callbacks.CbTypeList"/>
</f></copy>
		<iterator public="1" get="inline" set="null" line="647"><f a=""><c path="nape.callbacks.CbTypeIterator"/></f></iterator>
		<empty public="1" get="inline" set="null" line="631"><f a=""><x path="Bool"/></f></empty>
		<clear public="1" set="method" line="614"><f a=""><x path="Void"/></f></clear>
		<remove public="1" set="method" line="576"><f a="obj">
	<c path="nape.callbacks.CbType"/>
	<x path="Bool"/>
</f></remove>
		<add public="1" get="inline" set="null" line="563"><f a="obj">
	<c path="nape.callbacks.CbType"/>
	<x path="Bool"/>
</f></add>
		<shift public="1" set="method" line="519"><f a=""><c path="nape.callbacks.CbType"/></f></shift>
		<pop public="1" set="method" line="478"><f a=""><c path="nape.callbacks.CbType"/></f></pop>
		<unshift public="1" set="method" line="447"><f a="obj">
	<c path="nape.callbacks.CbType"/>
	<x path="Bool"/>
</f></unshift>
		<push public="1" set="method" line="416"><f a="obj">
	<c path="nape.callbacks.CbType"/>
	<x path="Bool"/>
</f></push>
		<at public="1" set="method" line="363"><f a="index">
	<x path="Int"/>
	<c path="nape.callbacks.CbType"/>
</f></at>
		<has public="1" set="method" line="346"><f a="obj">
	<c path="nape.callbacks.CbType"/>
	<x path="Bool"/>
</f></has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="get_length" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_CbTypeList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* Nape list of CbType type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:CbType = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:CbType = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:CbType = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.ConstraintCallback" params="" file="libSrc/napeLib/nape/callbacks/ConstraintCallback.hx">
		<extends path="nape.callbacks.Callback"/>
		<toString public="1" set="method" line="198" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<get_constraint get="inline" set="null" line="192"><f a=""><c path="nape.constraint.Constraint"/></f></get_constraint>
		<constraint public="1" get="get_constraint" set="null"><c path="nape.constraint.Constraint"/></constraint>
		<new public="1" set="method" line="184">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Callback object for Constraint type events.
 * <br/><br/>
 * This, like all other callback objects are automatically reused
 * and you should not keep any reference to them.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.ConstraintListener" params="" file="libSrc/napeLib/nape/callbacks/ConstraintListener.hx">
		<extends path="nape.callbacks.Listener"/>
		<set_handler get="inline" set="null" line="211"><f a="handler">
	<f a="">
		<c path="nape.callbacks.ConstraintCallback"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="nape.callbacks.ConstraintCallback"/>
		<x path="Void"/>
	</f>
</f></set_handler>
		<get_handler get="inline" set="null" line="208"><f a=""><f a="">
	<c path="nape.callbacks.ConstraintCallback"/>
	<x path="Void"/>
</f></f></get_handler>
		<handler public="1" get="get_handler" set="set_handler"><f a="">
	<c path="nape.callbacks.ConstraintCallback"/>
	<x path="Void"/>
</f></handler>
		<set_options get="inline" set="null" line="197"><f a="options">
	<c path="nape.callbacks.OptionType"/>
	<c path="nape.callbacks.OptionType"/>
</f></set_options>
		<get_options get="inline" set="null" line="194"><f a=""><c path="nape.callbacks.OptionType"/></f></get_options>
		<options public="1" get="get_options" set="set_options">
			<c path="nape.callbacks.OptionType"/>
			<haxe_doc><![CDATA[* The OptionType used to match against Constraints.
     * <br/><br/>
     * When added to the same Space, any Constraint who's CbType list matches
     * against this OptionType will be issued a callback when the relevant
     * event occurs.]]></haxe_doc>
		</options>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="248"><f a="event:options:handler:?precedence">
	<c path="nape.callbacks.CbEvent"/>
	<t path="Null"><d/></t>
	<f a="">
		<c path="nape.callbacks.ConstraintCallback"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* Event listener for Constraint type events.
 * <br/><br/>
 * The events that can be caught are WAKE, SLEEP and BREAK type events.
 * Theses listeners will only operate on Constraints.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.InteractionCallback" params="" file="libSrc/napeLib/nape/callbacks/InteractionCallback.hx">
		<extends path="nape.callbacks.Callback"/>
		<toString public="1" set="method" line="223" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<get_arbiters get="inline" set="null" line="217"><f a=""><c path="nape.dynamics.ArbiterList"/></f></get_arbiters>
		<arbiters public="1" get="get_arbiters" set="null"><c path="nape.dynamics.ArbiterList"/></arbiters>
		<get_int2 get="inline" set="null" line="206"><f a=""><c path="nape.phys.Interactor"/></f></get_int2>
		<int2 public="1" get="get_int2" set="null"><c path="nape.phys.Interactor"/></int2>
		<get_int1 get="inline" set="null" line="195"><f a=""><c path="nape.phys.Interactor"/></f></get_int1>
		<int1 public="1" get="get_int1" set="null"><c path="nape.phys.Interactor"/></int1>
		<new public="1" set="method" line="184">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Callback object for Interaction type events.
 * <br/><br/>
 * This, like all other callback objects are automatically reused
 * and you should not keep any reference to them.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.InteractionListener" params="" file="libSrc/napeLib/nape/callbacks/InteractionListener.hx">
		<extends path="nape.callbacks.Listener"/>
		<set_allowSleepingCallbacks get="inline" set="null" line="303"><f a="allowSleepingCallbacks">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_allowSleepingCallbacks>
		<get_allowSleepingCallbacks get="inline" set="null" line="300"><f a=""><x path="Bool"/></f></get_allowSleepingCallbacks>
		<allowSleepingCallbacks public="1" get="get_allowSleepingCallbacks" set="set_allowSleepingCallbacks"><x path="Bool"/></allowSleepingCallbacks>
		<set_handler get="inline" set="null" line="279"><f a="handler">
	<f a="">
		<c path="nape.callbacks.InteractionCallback"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="nape.callbacks.InteractionCallback"/>
		<x path="Void"/>
	</f>
</f></set_handler>
		<get_handler get="inline" set="null" line="276"><f a=""><f a="">
	<c path="nape.callbacks.InteractionCallback"/>
	<x path="Void"/>
</f></f></get_handler>
		<handler public="1" get="get_handler" set="set_handler"><f a="">
	<c path="nape.callbacks.InteractionCallback"/>
	<x path="Void"/>
</f></handler>
		<set_interactionType get="inline" set="null" line="257"><f a="interactionType">
	<c path="nape.callbacks.InteractionType"/>
	<c path="nape.callbacks.InteractionType"/>
</f></set_interactionType>
		<get_interactionType get="inline" set="null" line="249"><f a=""><c path="nape.callbacks.InteractionType"/></f></get_interactionType>
		<interactionType public="1" get="get_interactionType" set="set_interactionType"><c path="nape.callbacks.InteractionType"/></interactionType>
		<set_options2 get="inline" set="null" line="234"><f a="options2">
	<c path="nape.callbacks.OptionType"/>
	<c path="nape.callbacks.OptionType"/>
</f></set_options2>
		<get_options2 get="inline" set="null" line="231"><f a=""><c path="nape.callbacks.OptionType"/></f></get_options2>
		<options2 public="1" get="get_options2" set="set_options2"><c path="nape.callbacks.OptionType"/></options2>
		<set_options1 get="inline" set="null" line="220"><f a="options1">
	<c path="nape.callbacks.OptionType"/>
	<c path="nape.callbacks.OptionType"/>
</f></set_options1>
		<get_options1 get="inline" set="null" line="217"><f a=""><c path="nape.callbacks.OptionType"/></f></get_options1>
		<options1 public="1" get="get_options1" set="set_options1">
			<c path="nape.callbacks.OptionType"/>
			<haxe_doc>* The OptionType used to match against Interactors for the first object.</haxe_doc>
		</options1>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="338"><f a="event:interactionType:options1:options2:handler:?precedence">
	<c path="nape.callbacks.CbEvent"/>
	<c path="nape.callbacks.InteractionType"/>
	<t path="Null"><d/></t>
	<t path="Null"><d/></t>
	<f a="">
		<c path="nape.callbacks.InteractionCallback"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* Event listener for Interaction type events.
 * <br/><br/>
 * Interaction type events can occur between any two Interactors (whether they
 * be Shapes, Bodys, Compounds or a mix thereof).
 * <br/><br/>
 * The events that can be caught are BEGIN, ONGOING, and END type events.
 * Theses listeners will operate between pairs of Interactors.
 * <pre>
 *          _Space
 *         /      \
 *     Cmp1        Cmp3
 *    /    \         |
 * Body1  Cmp2     Body3
 *   |      |        |
 * Shp1   Body2    Shp3
 *          |
 *        Shp2
 * </pre>
 * The possible interactor pairs for callbacks are formed by finding the most
 * recent common ancestor in the world for the given pair of shapes and taking all
 * possible pairings. In the above situation we have:
 * <pre>
 * MRCA(Shp1, Shp2) = Cmp1  --> Possible pairings = [Shp1, Body1] x [Shp2, Body2, Cmp2]
 * MRCA(Shp1, Shp3) = Space --> Possible pairings = [Shp1, Body1, Cmp1] x [Shp3, Body3, Cmp3]
 * MRCA(Shp2, Shp3) = Space --> Possible pairings = [Shp2, Body2, Cmp2, Cmp1] x [Shp3, Body3, Cmp3]
 * </pre>
 * Of course, not all of these pairings will generate callbacks, only those for which
 * a valid listener exists for the event type, and for the cbtypes of each interactor.
 * <br/><br/>
 * Furthermore, the listener specifies an interaction type which works even in mixed
 * cases where many types of interaction between two objects is happening at once.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.InteractionType" params="" file="libSrc/napeLib/nape/callbacks/InteractionType.hx">
		<COLLISION public="1" get="get_COLLISION" set="null" static="1"><c path="nape.callbacks.InteractionType"/></COLLISION>
		<get_COLLISION get="inline" set="null" line="203" static="1"><f a=""><c path="nape.callbacks.InteractionType"/></f></get_COLLISION>
		<SENSOR public="1" get="get_SENSOR" set="null" static="1"><c path="nape.callbacks.InteractionType"/></SENSOR>
		<get_SENSOR get="inline" set="null" line="215" static="1"><f a=""><c path="nape.callbacks.InteractionType"/></f></get_SENSOR>
		<FLUID public="1" get="get_FLUID" set="null" static="1"><c path="nape.callbacks.InteractionType"/></FLUID>
		<get_FLUID get="inline" set="null" line="228" static="1"><f a=""><c path="nape.callbacks.InteractionType"/></f></get_FLUID>
		<ANY public="1" get="get_ANY" set="null" static="1"><c path="nape.callbacks.InteractionType"/></ANY>
		<get_ANY get="inline" set="null" line="241" static="1"><f a=""><c path="nape.callbacks.InteractionType"/></f></get_ANY>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of Interaction types.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.ListenerIterator" params="" file="libSrc/napeLib/nape/callbacks/ListenerIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.callbacks.ListenerIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1"><f a="list">
	<c path="nape.callbacks.ListenerList"/>
	<c path="nape.callbacks.ListenerIterator"/>
</f></get>
		<next public="1" get="inline" set="null" line="264"><f a=""><c path="nape.callbacks.Listener"/></f></next>
		<hasNext public="1" get="inline" set="null" line="240"><f a=""><x path="Bool"/></f></hasNext>
		<zpp_next public="1">
			<c path="nape.callbacks.ListenerIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.callbacks.ListenerList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.ListenerList" params="" file="libSrc/napeLib/nape/callbacks/ListenerList.hx">
		<fromArray public="1" set="method" line="304" static="1"><f a="array">
	<c path="Array"><c path="nape.callbacks.Listener"/></c>
	<c path="nape.callbacks.ListenerList"/>
</f></fromArray>
		<fromVector public="1" set="method" line="328" static="1"><f a="vector">
	<c path="flash.Vector"><c path="nape.callbacks.Listener"/></c>
	<c path="nape.callbacks.ListenerList"/>
</f></fromVector>
		<filter public="1" set="method" line="779"><f a="lambda">
	<f a="">
		<c path="nape.callbacks.Listener"/>
		<x path="Bool"/>
	</f>
	<c path="nape.callbacks.ListenerList"/>
</f></filter>
		<foreach public="1" get="inline" set="null" line="732"><f a="lambda">
	<f a="">
		<c path="nape.callbacks.Listener"/>
		<x path="Void"/>
	</f>
	<c path="nape.callbacks.ListenerList"/>
</f></foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<merge public="1" set="method" line="684"><f a="xs">
	<c path="nape.callbacks.ListenerList"/>
	<x path="Void"/>
</f></merge>
		<copy public="1" set="method" line="662"><f a="?deep">
	<x path="Bool"/>
	<c path="nape.callbacks.ListenerList"/>
</f></copy>
		<iterator public="1" get="inline" set="null" line="647"><f a=""><c path="nape.callbacks.ListenerIterator"/></f></iterator>
		<empty public="1" get="inline" set="null" line="631"><f a=""><x path="Bool"/></f></empty>
		<clear public="1" set="method" line="614"><f a=""><x path="Void"/></f></clear>
		<remove public="1" set="method" line="576"><f a="obj">
	<c path="nape.callbacks.Listener"/>
	<x path="Bool"/>
</f></remove>
		<add public="1" get="inline" set="null" line="563"><f a="obj">
	<c path="nape.callbacks.Listener"/>
	<x path="Bool"/>
</f></add>
		<shift public="1" set="method" line="519"><f a=""><c path="nape.callbacks.Listener"/></f></shift>
		<pop public="1" set="method" line="478"><f a=""><c path="nape.callbacks.Listener"/></f></pop>
		<unshift public="1" set="method" line="447"><f a="obj">
	<c path="nape.callbacks.Listener"/>
	<x path="Bool"/>
</f></unshift>
		<push public="1" set="method" line="416"><f a="obj">
	<c path="nape.callbacks.Listener"/>
	<x path="Bool"/>
</f></push>
		<at public="1" set="method" line="363"><f a="index">
	<x path="Int"/>
	<c path="nape.callbacks.Listener"/>
</f></at>
		<has public="1" set="method" line="346"><f a="obj">
	<c path="nape.callbacks.Listener"/>
	<x path="Bool"/>
</f></has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="get_length" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_ListenerList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* Nape list of Listener type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Listener = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Listener = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Listener = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.ListenerType" params="" file="libSrc/napeLib/nape/callbacks/ListenerType.hx">
		<BODY public="1" get="get_BODY" set="null" static="1"><c path="nape.callbacks.ListenerType"/></BODY>
		<get_BODY get="inline" set="null" line="203" static="1"><f a=""><c path="nape.callbacks.ListenerType"/></f></get_BODY>
		<CONSTRAINT public="1" get="get_CONSTRAINT" set="null" static="1"><c path="nape.callbacks.ListenerType"/></CONSTRAINT>
		<get_CONSTRAINT get="inline" set="null" line="216" static="1"><f a=""><c path="nape.callbacks.ListenerType"/></f></get_CONSTRAINT>
		<INTERACTION public="1" get="get_INTERACTION" set="null" static="1"><c path="nape.callbacks.ListenerType"/></INTERACTION>
		<get_INTERACTION get="inline" set="null" line="229" static="1"><f a=""><c path="nape.callbacks.ListenerType"/></f></get_INTERACTION>
		<PRE public="1" get="get_PRE" set="null" static="1"><c path="nape.callbacks.ListenerType"/></PRE>
		<get_PRE get="inline" set="null" line="242" static="1"><f a=""><c path="nape.callbacks.ListenerType"/></f></get_PRE>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of Listener types.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.OptionType" params="" file="libSrc/napeLib/nape/callbacks/OptionType.hx">
		<toString public="1" set="method" line="292">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<excluding public="1" set="method" line="285"><f a="?excludes">
	<d/>
	<c path="nape.callbacks.OptionType"/>
</f></excluding>
		<including public="1" set="method" line="267"><f a="?includes">
	<d/>
	<c path="nape.callbacks.OptionType"/>
</f></including>
		<get_excludes get="inline" set="null" line="228"><f a=""><c path="nape.callbacks.CbTypeList"/></f></get_excludes>
		<excludes public="1" get="get_excludes" set="null"><c path="nape.callbacks.CbTypeList"/></excludes>
		<get_includes get="inline" set="null" line="214"><f a=""><c path="nape.callbacks.CbTypeList"/></f></get_includes>
		<includes public="1" get="get_includes" set="null">
			<c path="nape.callbacks.CbTypeList"/>
			<haxe_doc><![CDATA[* List of included CbTypes.
     * <br/><br/>
     * This list is both readonly, and immutable. To remove an element
     * from this list you can use: <code>option.excluding(cbType)</code>
     *
     * @default []]]></haxe_doc>
		</includes>
		<zpp_inner public="1">
			<c path="zpp_nape.callbacks.ZPP_OptionType"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="247"><f a="?includes:?excludes">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* OptionType representing matching behaviour for Listeners.
 * <br/><br/>
 * An object's set of CbType's 'matches' against an OptionType iff.
 * the OptionType's includes list intersects the object's set of CbTypes
 * and the OptionType's excludes list 'does not' intersect the object's set
 * of CbTypes.
 * <pre>
 * option = new OptionType([A, B], [C, D]);
 * obj.cbTypes = [] // => does not match option.
 * obj.cbTypes = [A] // => matches the option
 * obj.cbTypes = [A, C] // => does not match option.
 * </pre>
 * The optionType's includes and excludes list are managed to be always
 * disjoint: The action of including an already excluded type serves to
 * remove it from the excludes list, equalliy excluding an already included
 * type serves to remove it from the includes list.
 * <pre>
 * var option = new OptionType();
 * option.including(A); // option = {[A]:[]}
 * option.excluding(A); // option = {[]:[]}
 * option.excluding(A); // option = {[]:[A]}
 * option.including(A); // option = {[A]:[]}
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.PreCallback" params="" file="libSrc/napeLib/nape/callbacks/PreCallback.hx">
		<extends path="nape.callbacks.Callback"/>
		<toString public="1" set="method" line="238" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<get_swapped get="inline" set="null" line="232"><f a=""><x path="Bool"/></f></get_swapped>
		<swapped public="1" get="get_swapped" set="null"><x path="Bool"/></swapped>
		<get_int2 get="inline" set="null" line="218"><f a=""><c path="nape.phys.Interactor"/></f></get_int2>
		<int2 public="1" get="get_int2" set="null"><c path="nape.phys.Interactor"/></int2>
		<get_int1 get="inline" set="null" line="207"><f a=""><c path="nape.phys.Interactor"/></f></get_int1>
		<int1 public="1" get="get_int1" set="null"><c path="nape.phys.Interactor"/></int1>
		<get_arbiter get="inline" set="null" line="196"><f a=""><c path="nape.dynamics.Arbiter"/></f></get_arbiter>
		<arbiter public="1" get="get_arbiter" set="null"><c path="nape.dynamics.Arbiter"/></arbiter>
		<new public="1" set="method" line="184">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Callback object for Pre-Interaction type events.
 * <br/><br/>
 * This, like all other callback objects are automatically reused
 * and you should not keep any reference to them.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.PreFlag" params="" file="libSrc/napeLib/nape/callbacks/PreFlag.hx">
		<ACCEPT public="1" get="get_ACCEPT" set="null" static="1"><c path="nape.callbacks.PreFlag"/></ACCEPT>
		<get_ACCEPT get="inline" set="null" line="204" static="1"><f a=""><c path="nape.callbacks.PreFlag"/></f></get_ACCEPT>
		<IGNORE public="1" get="get_IGNORE" set="null" static="1"><c path="nape.callbacks.PreFlag"/></IGNORE>
		<get_IGNORE get="inline" set="null" line="217" static="1"><f a=""><c path="nape.callbacks.PreFlag"/></f></get_IGNORE>
		<ACCEPT_ONCE public="1" get="get_ACCEPT_ONCE" set="null" static="1"><c path="nape.callbacks.PreFlag"/></ACCEPT_ONCE>
		<get_ACCEPT_ONCE get="inline" set="null" line="231" static="1"><f a=""><c path="nape.callbacks.PreFlag"/></f></get_ACCEPT_ONCE>
		<IGNORE_ONCE public="1" get="get_IGNORE_ONCE" set="null" static="1"><c path="nape.callbacks.PreFlag"/></IGNORE_ONCE>
		<get_IGNORE_ONCE get="inline" set="null" line="245" static="1"><f a=""><c path="nape.callbacks.PreFlag"/></f></get_IGNORE_ONCE>
		<toString public="1" set="method" line="190">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="182">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of interaction states for arbiters. These values are returned
 * by PreListener callback handlers.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.callbacks.PreListener" params="" file="libSrc/napeLib/nape/callbacks/PreListener.hx">
		<extends path="nape.callbacks.Listener"/>
		<set_interactionType get="inline" set="null" line="295"><f a="interactionType">
	<c path="nape.callbacks.InteractionType"/>
	<c path="nape.callbacks.InteractionType"/>
</f></set_interactionType>
		<get_interactionType get="inline" set="null" line="287"><f a=""><c path="nape.callbacks.InteractionType"/></f></get_interactionType>
		<interactionType public="1" get="get_interactionType" set="set_interactionType"><c path="nape.callbacks.InteractionType"/></interactionType>
		<set_pure get="inline" set="null" line="269"><f a="pure">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_pure>
		<get_pure get="inline" set="null" line="266"><f a=""><x path="Bool"/></f></get_pure>
		<pure public="1" get="get_pure" set="set_pure"><x path="Bool"/></pure>
		<set_handler get="inline" set="null" line="242"><f a="handler">
	<f a="">
		<c path="nape.callbacks.PreCallback"/>
		<t path="Null"><c path="nape.callbacks.PreFlag"/></t>
	</f>
	<f a="">
		<c path="nape.callbacks.PreCallback"/>
		<t path="Null"><c path="nape.callbacks.PreFlag"/></t>
	</f>
</f></set_handler>
		<get_handler get="inline" set="null" line="239"><f a=""><f a="">
	<c path="nape.callbacks.PreCallback"/>
	<t path="Null"><c path="nape.callbacks.PreFlag"/></t>
</f></f></get_handler>
		<handler public="1" get="get_handler" set="set_handler"><f a="">
	<c path="nape.callbacks.PreCallback"/>
	<t path="Null"><c path="nape.callbacks.PreFlag"/></t>
</f></handler>
		<set_options2 get="inline" set="null" line="207"><f a="options2">
	<c path="nape.callbacks.OptionType"/>
	<c path="nape.callbacks.OptionType"/>
</f></set_options2>
		<get_options2 get="inline" set="null" line="204"><f a=""><c path="nape.callbacks.OptionType"/></f></get_options2>
		<options2 public="1" get="get_options2" set="set_options2"><c path="nape.callbacks.OptionType"/></options2>
		<set_options1 get="inline" set="null" line="193"><f a="options1">
	<c path="nape.callbacks.OptionType"/>
	<c path="nape.callbacks.OptionType"/>
</f></set_options1>
		<get_options1 get="inline" set="null" line="190"><f a=""><c path="nape.callbacks.OptionType"/></f></get_options1>
		<options1 public="1" get="get_options1" set="set_options1">
			<c path="nape.callbacks.OptionType"/>
			<haxe_doc>* The OptionType used to match against Interactors for the first object.</haxe_doc>
		</options1>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="336"><f a="interactionType:options1:options2:handler:?precedence:?pure">
	<c path="nape.callbacks.InteractionType"/>
	<t path="Null"><d/></t>
	<t path="Null"><d/></t>
	<f a="">
		<c path="nape.callbacks.PreCallback"/>
		<t path="Null"><c path="nape.callbacks.PreFlag"/></t>
	</f>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* Event listener for Pre-Interaction type events.
 * <br/><br/>
 * Pre-Interaction type events can occur between any two Interactors (whether they
 * be Shapes, Bodys, Compounds or a mix thereof).]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.Constraint" params="" file="libSrc/napeLib/nape/constraint/Constraint.hx">
		<copy public="1" set="method" line="661"><f a=""><c path="nape.constraint.Constraint"/></f></copy>
		<toString public="1" set="method" line="650">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<get_cbTypes get="inline" set="null" line="632"><f a=""><c path="nape.callbacks.CbTypeList"/></f></get_cbTypes>
		<cbTypes public="1" get="get_cbTypes" set="null"><c path="nape.callbacks.CbTypeList"/></cbTypes>
		<visitBodies public="1" set="method" line="622"><f a="lambda">
	<f a="">
		<c path="nape.phys.Body"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></visitBodies>
		<bodyImpulse public="1" set="method" line="610"><f a="body">
	<c path="nape.phys.Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<impulse public="1" set="method" line="597"><f a=""><c path="nape.geom.MatMN"/></f></impulse>
		<set_removeOnBreak get="inline" set="null" line="586"><f a="removeOnBreak">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_removeOnBreak>
		<get_removeOnBreak get="inline" set="null" line="583"><f a=""><x path="Bool"/></f></get_removeOnBreak>
		<removeOnBreak public="1" get="get_removeOnBreak" set="set_removeOnBreak"><x path="Bool"/></removeOnBreak>
		<set_breakUnderError get="inline" set="null" line="564"><f a="breakUnderError">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_breakUnderError>
		<get_breakUnderError get="inline" set="null" line="561"><f a=""><x path="Bool"/></f></get_breakUnderError>
		<breakUnderError public="1" get="get_breakUnderError" set="set_breakUnderError"><x path="Bool"/></breakUnderError>
		<set_breakUnderForce get="inline" set="null" line="543"><f a="breakUnderForce">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_breakUnderForce>
		<get_breakUnderForce get="inline" set="null" line="540"><f a=""><x path="Bool"/></f></get_breakUnderForce>
		<breakUnderForce public="1" get="get_breakUnderForce" set="set_breakUnderForce"><x path="Bool"/></breakUnderForce>
		<set_maxError get="inline" set="null" line="512"><f a="maxError">
	<x path="Float"/>
	<x path="Float"/>
</f></set_maxError>
		<get_maxError get="inline" set="null" line="509"><f a=""><x path="Float"/></f></get_maxError>
		<maxError public="1" get="get_maxError" set="set_maxError"><x path="Float"/></maxError>
		<set_maxForce get="inline" set="null" line="478"><f a="maxForce">
	<x path="Float"/>
	<x path="Float"/>
</f></set_maxForce>
		<get_maxForce get="inline" set="null" line="475"><f a=""><x path="Float"/></f></get_maxForce>
		<maxForce public="1" get="get_maxForce" set="set_maxForce"><x path="Float"/></maxForce>
		<set_damping get="inline" set="null" line="442"><f a="damping">
	<x path="Float"/>
	<x path="Float"/>
</f></set_damping>
		<get_damping get="inline" set="null" line="439"><f a=""><x path="Float"/></f></get_damping>
		<damping public="1" get="get_damping" set="set_damping"><x path="Float"/></damping>
		<set_frequency get="inline" set="null" line="405"><f a="frequency">
	<x path="Float"/>
	<x path="Float"/>
</f></set_frequency>
		<get_frequency get="inline" set="null" line="402"><f a=""><x path="Float"/></f></get_frequency>
		<frequency public="1" get="get_frequency" set="set_frequency"><x path="Float"/></frequency>
		<set_stiff get="inline" set="null" line="379"><f a="stiff">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_stiff>
		<get_stiff get="inline" set="null" line="376"><f a=""><x path="Bool"/></f></get_stiff>
		<stiff public="1" get="get_stiff" set="set_stiff"><x path="Bool"/></stiff>
		<set_ignore get="inline" set="null" line="350"><f a="ignore">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ignore>
		<get_ignore get="inline" set="null" line="347"><f a=""><x path="Bool"/></f></get_ignore>
		<ignore public="1" get="get_ignore" set="set_ignore"><x path="Bool"/></ignore>
		<set_active get="inline" set="null" line="312"><f a="active">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_active>
		<get_active get="inline" set="null" line="309"><f a=""><x path="Bool"/></f></get_active>
		<active public="1" get="get_active" set="set_active"><x path="Bool"/></active>
		<get_isSleeping get="inline" set="null" line="290"><f a=""><x path="Bool"/></f></get_isSleeping>
		<isSleeping public="1" get="get_isSleeping" set="null"><x path="Bool"/></isSleeping>
		<set_space get="inline" set="null" line="251"><f a="space">
	<t path="Null"><c path="nape.space.Space"/></t>
	<t path="Null"><c path="nape.space.Space"/></t>
</f></set_space>
		<get_space get="inline" set="null" line="248"><f a=""><t path="Null"><c path="nape.space.Space"/></t></f></get_space>
		<space public="1" get="get_space" set="set_space"><t path="Null"><c path="nape.space.Space"/></t></space>
		<set_compound get="inline" set="null" line="222"><f a="compound">
	<t path="Null"><c path="nape.phys.Compound"/></t>
	<t path="Null"><c path="nape.phys.Compound"/></t>
</f></set_compound>
		<get_compound get="inline" set="null" line="219"><f a=""><t path="Null"><c path="nape.phys.Compound"/></t></f></get_compound>
		<compound public="1" get="get_compound" set="set_compound">
			<t path="Null"><c path="nape.phys.Compound"/></t>
			<haxe_doc><![CDATA[* Compound this Constraints belong to.
     * <br/><br/>
     * If this constraint is in a Space or another Compound and you change
     * its compound, then it will be removed from that Space or Compound.
     *
     * @default null]]></haxe_doc>
		</compound>
		<debugDraw public="1"><x path="Bool"/></debugDraw>
		<get_userData get="inline" set="null" line="195"><f a=""><d><d/></d></f></get_userData>
		<userData public="1" get="get_userData" set="null">
			<d><d/></d>
			<haxe_doc><![CDATA[* Dynamic object for user to store additional data.
     * <br/><br/>
     * This object cannot be set, only its dynamically created
     * properties may be set. In AS3 the type of this property is &#42
     * <br/><br/>
     * This object will be lazily constructed so that until accessed
     * for the first time, will be null internally.
     *
     * @default {}]]></haxe_doc>
		</userData>
		<zpp_inner public="1">
			<c path="zpp_nape.constraint.ZPP_Constraint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="641"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Base type for all Nape joints and constraints</haxe_doc>
	</class>
	<class path="nape.constraint.AngleJoint" params="" file="libSrc/napeLib/nape/constraint/AngleJoint.hx">
		<extends path="nape.constraint.Constraint"/>
		<visitBodies public="1" set="method" line="427" override="1"><f a="lambda">
	<f a="">
		<c path="nape.phys.Body"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></visitBodies>
		<bodyImpulse public="1" set="method" line="408" override="1"><f a="body">
	<c path="nape.phys.Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<impulse public="1" set="method" line="398" override="1"><f a=""><c path="nape.geom.MatMN"/></f></impulse>
		<isSlack public="1" get="inline" set="null" line="353"><f a=""><x path="Bool"/></f></isSlack>
		<set_ratio get="inline" set="null" line="327"><f a="ratio">
	<x path="Float"/>
	<x path="Float"/>
</f></set_ratio>
		<get_ratio get="inline" set="null" line="324"><f a=""><x path="Float"/></f></get_ratio>
		<ratio public="1" get="get_ratio" set="set_ratio"><x path="Float"/></ratio>
		<set_jointMax get="inline" set="null" line="302"><f a="jointMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_jointMax>
		<get_jointMax get="inline" set="null" line="299"><f a=""><x path="Float"/></f></get_jointMax>
		<jointMax public="1" get="get_jointMax" set="set_jointMax"><x path="Float"/></jointMax>
		<set_jointMin get="inline" set="null" line="275"><f a="jointMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_jointMin>
		<get_jointMin get="inline" set="null" line="272"><f a=""><x path="Float"/></f></get_jointMin>
		<jointMin public="1" get="get_jointMin" set="set_jointMin"><x path="Float"/></jointMin>
		<set_body2 get="inline" set="null" line="236"><f a="body2">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body2>
		<get_body2 get="inline" set="null" line="233"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body2>
		<body2 public="1" get="get_body2" set="set_body2"><t path="Null"><c path="nape.phys.Body"/></t></body2>
		<set_body1 get="inline" set="null" line="198"><f a="body1">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body1>
		<get_body1 get="inline" set="null" line="195"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body1>
		<body1 public="1" get="get_body1" set="set_body1">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* First Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body1>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.constraint.ZPP_AngleJoint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="373"><f a="body1:body2:jointMin:jointMax:?ratio">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* AngleJoint constraining the relative angles of two Bodies.
 * <br/><br/>
 * The equation for this constraint is:
 * <pre>
 * jointMin <= ratio * body2.rotation - body1.rotation <= jointMax
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.ConstraintIterator" params="" file="libSrc/napeLib/nape/constraint/ConstraintIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.constraint.ConstraintIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1"><f a="list">
	<c path="nape.constraint.ConstraintList"/>
	<c path="nape.constraint.ConstraintIterator"/>
</f></get>
		<next public="1" get="inline" set="null" line="264"><f a=""><c path="nape.constraint.Constraint"/></f></next>
		<hasNext public="1" get="inline" set="null" line="240"><f a=""><x path="Bool"/></f></hasNext>
		<zpp_next public="1">
			<c path="nape.constraint.ConstraintIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.constraint.ConstraintList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.ConstraintList" params="" file="libSrc/napeLib/nape/constraint/ConstraintList.hx">
		<fromArray public="1" set="method" line="304" static="1"><f a="array">
	<c path="Array"><c path="nape.constraint.Constraint"/></c>
	<c path="nape.constraint.ConstraintList"/>
</f></fromArray>
		<fromVector public="1" set="method" line="328" static="1"><f a="vector">
	<c path="flash.Vector"><c path="nape.constraint.Constraint"/></c>
	<c path="nape.constraint.ConstraintList"/>
</f></fromVector>
		<filter public="1" set="method" line="779"><f a="lambda">
	<f a="">
		<c path="nape.constraint.Constraint"/>
		<x path="Bool"/>
	</f>
	<c path="nape.constraint.ConstraintList"/>
</f></filter>
		<foreach public="1" get="inline" set="null" line="732"><f a="lambda">
	<f a="">
		<c path="nape.constraint.Constraint"/>
		<x path="Void"/>
	</f>
	<c path="nape.constraint.ConstraintList"/>
</f></foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<merge public="1" set="method" line="684"><f a="xs">
	<c path="nape.constraint.ConstraintList"/>
	<x path="Void"/>
</f></merge>
		<copy public="1" set="method" line="662"><f a="?deep">
	<x path="Bool"/>
	<c path="nape.constraint.ConstraintList"/>
</f></copy>
		<iterator public="1" get="inline" set="null" line="647"><f a=""><c path="nape.constraint.ConstraintIterator"/></f></iterator>
		<empty public="1" get="inline" set="null" line="631"><f a=""><x path="Bool"/></f></empty>
		<clear public="1" set="method" line="614"><f a=""><x path="Void"/></f></clear>
		<remove public="1" set="method" line="576"><f a="obj">
	<c path="nape.constraint.Constraint"/>
	<x path="Bool"/>
</f></remove>
		<add public="1" get="inline" set="null" line="563"><f a="obj">
	<c path="nape.constraint.Constraint"/>
	<x path="Bool"/>
</f></add>
		<shift public="1" set="method" line="519"><f a=""><c path="nape.constraint.Constraint"/></f></shift>
		<pop public="1" set="method" line="478"><f a=""><c path="nape.constraint.Constraint"/></f></pop>
		<unshift public="1" set="method" line="447"><f a="obj">
	<c path="nape.constraint.Constraint"/>
	<x path="Bool"/>
</f></unshift>
		<push public="1" set="method" line="416"><f a="obj">
	<c path="nape.constraint.Constraint"/>
	<x path="Bool"/>
</f></push>
		<at public="1" set="method" line="363"><f a="index">
	<x path="Int"/>
	<c path="nape.constraint.Constraint"/>
</f></at>
		<has public="1" set="method" line="346"><f a="obj">
	<c path="nape.constraint.Constraint"/>
	<x path="Bool"/>
</f></has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="get_length" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_ConstraintList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* Nape list of Constraint type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Constraint = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Constraint = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Constraint = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.DistanceJoint" params="" file="libSrc/napeLib/nape/constraint/DistanceJoint.hx">
		<extends path="nape.constraint.Constraint"/>
		<visitBodies public="1" set="method" line="456" override="1"><f a="lambda">
	<f a="">
		<c path="nape.phys.Body"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></visitBodies>
		<bodyImpulse public="1" set="method" line="437" override="1"><f a="body">
	<c path="nape.phys.Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<impulse public="1" set="method" line="429" override="1"><f a=""><c path="nape.geom.MatMN"/></f></impulse>
		<isSlack public="1" get="inline" set="null" line="382"><f a=""><x path="Bool"/></f></isSlack>
		<set_jointMax get="inline" set="null" line="353"><f a="jointMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_jointMax>
		<get_jointMax get="inline" set="null" line="350"><f a=""><x path="Float"/></f></get_jointMax>
		<jointMax public="1" get="get_jointMax" set="set_jointMax"><x path="Float"/></jointMax>
		<set_jointMin get="inline" set="null" line="325"><f a="jointMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_jointMin>
		<get_jointMin get="inline" set="null" line="322"><f a=""><x path="Float"/></f></get_jointMin>
		<jointMin public="1" get="get_jointMin" set="set_jointMin"><x path="Float"/></jointMin>
		<set_anchor2 get="inline" set="null" line="301"><f a="anchor2">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor2>
		<get_anchor2 get="inline" set="null" line="297"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor2>
		<anchor2 public="1" get="get_anchor2" set="set_anchor2"><c path="nape.geom.Vec2"/></anchor2>
		<set_anchor1 get="inline" set="null" line="276"><f a="anchor1">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor1>
		<get_anchor1 get="inline" set="null" line="272"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor1>
		<anchor1 public="1" get="get_anchor1" set="set_anchor1"><c path="nape.geom.Vec2"/></anchor1>
		<set_body2 get="inline" set="null" line="238"><f a="body2">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body2>
		<get_body2 get="inline" set="null" line="235"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body2>
		<body2 public="1" get="get_body2" set="set_body2"><t path="Null"><c path="nape.phys.Body"/></t></body2>
		<set_body1 get="inline" set="null" line="200"><f a="body1">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body1>
		<get_body1 get="inline" set="null" line="197"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body1>
		<body1 public="1" get="get_body1" set="set_body1">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* First Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body1>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.constraint.ZPP_DistanceJoint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="403"><f a="body1:body2:anchor1:anchor2:jointMin:jointMax">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* DistanceJoint limiting the distance between two local anchor points of Bodies.
 * <br/><br/>
 * The equation for this constraint could be written like:
 * <pre>
 * jointMin <= distance(body2.localPointToWorld(anchor2), body1.localPointToWorld(anchor1)) <= jointMax
 * </pre>
 * This joint is not designed to work when <code> jointMin = jointMax = 0 </code> and constraint is
 * stiff. In this instance you should use a PivotJoint instead.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.LineJoint" params="" file="libSrc/napeLib/nape/constraint/LineJoint.hx">
		<extends path="nape.constraint.Constraint"/>
		<visitBodies public="1" set="method" line="484" override="1"><f a="lambda">
	<f a="">
		<c path="nape.phys.Body"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></visitBodies>
		<bodyImpulse public="1" set="method" line="465" override="1"><f a="body">
	<c path="nape.phys.Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<impulse public="1" set="method" line="456" override="1"><f a=""><c path="nape.geom.MatMN"/></f></impulse>
		<set_jointMax get="inline" set="null" line="400"><f a="jointMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_jointMax>
		<get_jointMax get="inline" set="null" line="397"><f a=""><x path="Float"/></f></get_jointMax>
		<jointMax public="1" get="get_jointMax" set="set_jointMax"><x path="Float"/></jointMax>
		<set_jointMin get="inline" set="null" line="375"><f a="jointMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_jointMin>
		<get_jointMin get="inline" set="null" line="372"><f a=""><x path="Float"/></f></get_jointMin>
		<jointMin public="1" get="get_jointMin" set="set_jointMin"><x path="Float"/></jointMin>
		<set_direction get="inline" set="null" line="351"><f a="direction">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_direction>
		<get_direction get="inline" set="null" line="347"><f a=""><c path="nape.geom.Vec2"/></f></get_direction>
		<direction public="1" get="get_direction" set="set_direction"><c path="nape.geom.Vec2"/></direction>
		<set_anchor2 get="inline" set="null" line="325"><f a="anchor2">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor2>
		<get_anchor2 get="inline" set="null" line="321"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor2>
		<anchor2 public="1" get="get_anchor2" set="set_anchor2"><c path="nape.geom.Vec2"/></anchor2>
		<set_anchor1 get="inline" set="null" line="300"><f a="anchor1">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor1>
		<get_anchor1 get="inline" set="null" line="296"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor1>
		<anchor1 public="1" get="get_anchor1" set="set_anchor1"><c path="nape.geom.Vec2"/></anchor1>
		<set_body2 get="inline" set="null" line="262"><f a="body2">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body2>
		<get_body2 get="inline" set="null" line="259"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body2>
		<body2 public="1" get="get_body2" set="set_body2"><t path="Null"><c path="nape.phys.Body"/></t></body2>
		<set_body1 get="inline" set="null" line="224"><f a="body1">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body1>
		<get_body1 get="inline" set="null" line="221"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body1>
		<body1 public="1" get="get_body1" set="set_body1">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* First Body in constraint, defining the line segment.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body1>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.constraint.ZPP_LineJoint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="429"><f a="body1:body2:anchor1:anchor2:direction:jointMin:jointMax">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* LineJoint constraining anchor of one body, to a line segment of the other.
 * <br/><br/>
 * The equation for this constraint could be written like:
 * <pre>
 *        0  = [dir.cross(delta)]  = 0
 * jointMin <= [dor.dot  (delta)] <= jointMax
 * </pre>
 * where:
 * <pre>
 * dir   = body1.localVectorToWorld(direction).unit();
 * delta = body2.localPointToWorld(anchor2).sub(body1.localPointToWorld(anchor1));
 * </pre>
 * This is a 2 dimensional constraint, and is (when at the limits) solved as a
 * block constraint for better stability. This is however not the most stable
 * of joint when chained and put under stress and is a rather rare case where
 * using a non-stiff joint can actually be more stable than
 * using a stiff one.
 * <br/><br/>
 * When <code> jointMin = jointMax </code>, it would be better to use a PivotJoint
 *instead with suitable
 * placed anchors.
 * <br/><br/>
 * The line segment is defined implicitly via the
 * <code>anchor1, direction, jointMin and jointMax</code> properties with end
 * points defined in local coordinate system of body1 like:
 * <pre>
 * start = anchor1.add(direction.unit().mul(jointMin))
 * end   = anchor1.add(direction.unit().mul(jointMax))
 * </pre>
 * The reason for this more general description of a line segment is that one or
 * both of jointMin, jointMax are permitted to be infinite and a line segment
 * defined with a start and end point is not sufficient to describe such lines.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.MotorJoint" params="" file="libSrc/napeLib/nape/constraint/MotorJoint.hx">
		<extends path="nape.constraint.Constraint"/>
		<visitBodies public="1" set="method" line="378" override="1"><f a="lambda">
	<f a="">
		<c path="nape.phys.Body"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></visitBodies>
		<bodyImpulse public="1" set="method" line="359" override="1"><f a="body">
	<c path="nape.phys.Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<impulse public="1" set="method" line="349" override="1"><f a=""><c path="nape.geom.MatMN"/></f></impulse>
		<set_rate get="inline" set="null" line="299"><f a="rate">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rate>
		<get_rate get="inline" set="null" line="296"><f a=""><x path="Float"/></f></get_rate>
		<rate public="1" get="get_rate" set="set_rate"><x path="Float"/></rate>
		<set_ratio get="inline" set="null" line="274"><f a="ratio">
	<x path="Float"/>
	<x path="Float"/>
</f></set_ratio>
		<get_ratio get="inline" set="null" line="271"><f a=""><x path="Float"/></f></get_ratio>
		<ratio public="1" get="get_ratio" set="set_ratio"><x path="Float"/></ratio>
		<set_body2 get="inline" set="null" line="237"><f a="body2">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body2>
		<get_body2 get="inline" set="null" line="234"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body2>
		<body2 public="1" get="get_body2" set="set_body2"><t path="Null"><c path="nape.phys.Body"/></t></body2>
		<set_body1 get="inline" set="null" line="199"><f a="body1">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body1>
		<get_body1 get="inline" set="null" line="196"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body1>
		<body1 public="1" get="get_body1" set="set_body1">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* First Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body1>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.constraint.ZPP_MotorJoint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="325"><f a="body1:body2:?rate:?ratio">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* MotorJoint constraining the angular velocities of two bodies
 * <br/><br/>
 * The equation for this constraint is:
 * <pre>
 * (ratio * body2.angularVel) - body1.angularVel = rate
 * </pre>
 * This constraint operates only on the velocities of objects.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.PivotJoint" params="" file="libSrc/napeLib/nape/constraint/PivotJoint.hx">
		<extends path="nape.constraint.Constraint"/>
		<visitBodies public="1" set="method" line="380" override="1"><f a="lambda">
	<f a="">
		<c path="nape.phys.Body"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></visitBodies>
		<bodyImpulse public="1" set="method" line="361" override="1"><f a="body">
	<c path="nape.phys.Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<impulse public="1" set="method" line="352" override="1"><f a=""><c path="nape.geom.MatMN"/></f></impulse>
		<set_anchor2 get="inline" set="null" line="303"><f a="anchor2">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor2>
		<get_anchor2 get="inline" set="null" line="299"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor2>
		<anchor2 public="1" get="get_anchor2" set="set_anchor2"><c path="nape.geom.Vec2"/></anchor2>
		<set_anchor1 get="inline" set="null" line="278"><f a="anchor1">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor1>
		<get_anchor1 get="inline" set="null" line="274"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor1>
		<anchor1 public="1" get="get_anchor1" set="set_anchor1"><c path="nape.geom.Vec2"/></anchor1>
		<set_body2 get="inline" set="null" line="240"><f a="body2">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body2>
		<get_body2 get="inline" set="null" line="237"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body2>
		<body2 public="1" get="get_body2" set="set_body2"><t path="Null"><c path="nape.phys.Body"/></t></body2>
		<set_body1 get="inline" set="null" line="202"><f a="body1">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body1>
		<get_body1 get="inline" set="null" line="199"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body1>
		<body1 public="1" get="get_body1" set="set_body1">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* First Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body1>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.constraint.ZPP_PivotJoint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="328"><f a="body1:body2:anchor1:anchor2">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* PivotJoint constraining two anchors points of bodies to be equal.
 * <br/><br/>
 * The equation for this constraint is:
 * <pre>
 * body2.localPointToWorld(anchor2) = body1.localPointToWorld(anchor1)
 * </pre>
 * You may view this constraint as being equal to the DistanceJoint constraint
 * when both its jointMin and jointMax are exactly 0 (In such a case a
 * DistanceJoint becomes degenerate). Compared to the DistanceJoint this is
 * a 2 dimensional constraint.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.PulleyJoint" params="" file="libSrc/napeLib/nape/constraint/PulleyJoint.hx">
		<extends path="nape.constraint.Constraint"/>
		<visitBodies public="1" set="method" line="620" override="1"><f a="lambda">
	<f a="">
		<c path="nape.phys.Body"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></visitBodies>
		<bodyImpulse public="1" set="method" line="601" override="1"><f a="body">
	<c path="nape.phys.Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<impulse public="1" set="method" line="593" override="1"><f a=""><c path="nape.geom.MatMN"/></f></impulse>
		<isSlack public="1" get="inline" set="null" line="536"><f a=""><x path="Bool"/></f></isSlack>
		<set_ratio get="inline" set="null" line="510"><f a="ratio">
	<x path="Float"/>
	<x path="Float"/>
</f></set_ratio>
		<get_ratio get="inline" set="null" line="507"><f a=""><x path="Float"/></f></get_ratio>
		<ratio public="1" get="get_ratio" set="set_ratio"><x path="Float"/></ratio>
		<set_jointMax get="inline" set="null" line="482"><f a="jointMax">
	<x path="Float"/>
	<x path="Float"/>
</f></set_jointMax>
		<get_jointMax get="inline" set="null" line="479"><f a=""><x path="Float"/></f></get_jointMax>
		<jointMax public="1" get="get_jointMax" set="set_jointMax"><x path="Float"/></jointMax>
		<set_jointMin get="inline" set="null" line="454"><f a="jointMin">
	<x path="Float"/>
	<x path="Float"/>
</f></set_jointMin>
		<get_jointMin get="inline" set="null" line="451"><f a=""><x path="Float"/></f></get_jointMin>
		<jointMin public="1" get="get_jointMin" set="set_jointMin"><x path="Float"/></jointMin>
		<set_anchor4 get="inline" set="null" line="430"><f a="anchor4">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor4>
		<get_anchor4 get="inline" set="null" line="426"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor4>
		<anchor4 public="1" get="get_anchor4" set="set_anchor4"><c path="nape.geom.Vec2"/></anchor4>
		<set_anchor3 get="inline" set="null" line="405"><f a="anchor3">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor3>
		<get_anchor3 get="inline" set="null" line="401"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor3>
		<anchor3 public="1" get="get_anchor3" set="set_anchor3"><c path="nape.geom.Vec2"/></anchor3>
		<set_anchor2 get="inline" set="null" line="380"><f a="anchor2">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor2>
		<get_anchor2 get="inline" set="null" line="376"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor2>
		<anchor2 public="1" get="get_anchor2" set="set_anchor2"><c path="nape.geom.Vec2"/></anchor2>
		<set_anchor1 get="inline" set="null" line="355"><f a="anchor1">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor1>
		<get_anchor1 get="inline" set="null" line="351"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor1>
		<anchor1 public="1" get="get_anchor1" set="set_anchor1"><c path="nape.geom.Vec2"/></anchor1>
		<set_body4 get="inline" set="null" line="317"><f a="body4">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body4>
		<get_body4 get="inline" set="null" line="314"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body4>
		<body4 public="1" get="get_body4" set="set_body4"><t path="Null"><c path="nape.phys.Body"/></t></body4>
		<set_body3 get="inline" set="null" line="279"><f a="body3">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body3>
		<get_body3 get="inline" set="null" line="276"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body3>
		<body3 public="1" get="get_body3" set="set_body3"><t path="Null"><c path="nape.phys.Body"/></t></body3>
		<set_body2 get="inline" set="null" line="241"><f a="body2">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body2>
		<get_body2 get="inline" set="null" line="238"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body2>
		<body2 public="1" get="get_body2" set="set_body2"><t path="Null"><c path="nape.phys.Body"/></t></body2>
		<set_body1 get="inline" set="null" line="203"><f a="body1">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body1>
		<get_body1 get="inline" set="null" line="200"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body1>
		<body1 public="1" get="get_body1" set="set_body1">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* First Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body1>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.constraint.ZPP_PulleyJoint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="562"><f a="body1:body2:body3:body4:anchor1:anchor2:anchor3:anchor4:jointMin:jointMax:?ratio">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* PulleyJoint limiting the weighted sum of distances between 2 pairs of 4 local anchor points of Bodies.
 * <br/><br/>
 * The equation for this constraint could be written like:
 * <pre>
 * jointMin <= distance(body2.localPointToWorld(anchor2), body1.localPointToWorld(anchor1))
 *   + ratio * distance(body4.localPointToWorld(anchor4), body3.localPointToWorld(anchor3)) <= jointMax
 * </pre>
 * This joint is not designed to work when either of these pairs achieves a distance of 0, it will still work
 * but may not be entirely ideal.
!1*<br/><br/> * This constraint can be used in a full 4-body set up, or a 3-body set up or a 2-body set up permitting
 * any arrangement as long as body1 != body2 and body3 != body4]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.constraint.UserConstraint" params="" file="libSrc/napeLib/nape/constraint/UserConstraint.hx">
		<extends path="nape.constraint.Constraint"/>
		<__registerBody public="1" set="method" line="504"><f a="oldBody:newBody">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></__registerBody>
		<__invalidate public="1" set="method" line="469"><f a=""><x path="Void"/></f></__invalidate>
		<visitBodies public="1" set="method" line="437" override="1"><f a="lambda">
	<f a="">
		<c path="nape.phys.Body"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></visitBodies>
		<bodyImpulse public="1" set="method" line="411" override="1"><f a="body">
	<c path="nape.phys.Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<impulse public="1" set="method" line="401" override="1"><f a=""><c path="nape.geom.MatMN"/></f></impulse>
		<__impulse public="1" set="method" line="358"><f a="imp:body:out">
	<t path="nape.TArray"><x path="Float"/></t>
	<c path="nape.phys.Body"/>
	<c path="nape.geom.Vec3"/>
	<x path="Void"/>
</f></__impulse>
		<__clamp public="1" set="method" line="347"><f a="jAcc">
	<t path="nape.TArray"><x path="Float"/></t>
	<x path="Void"/>
</f></__clamp>
		<__eff_mass public="1" set="method" line="335"><f a="eff">
	<t path="nape.TArray"><x path="Float"/></t>
	<x path="Void"/>
</f></__eff_mass>
		<__velocity public="1" set="method" line="313"><f a="err">
	<t path="nape.TArray"><x path="Float"/></t>
	<x path="Void"/>
</f></__velocity>
		<__position public="1" set="method" line="300"><f a="err">
	<t path="nape.TArray"><x path="Float"/></t>
	<x path="Void"/>
</f></__position>
		<__prepare public="1" set="method" line="291"><f a=""><x path="Void"/></f></__prepare>
		<__draw public="1" set="method" line="282"><f a="debug">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></__draw>
		<__validate public="1" set="method" line="271"><f a=""><x path="Void"/></f></__validate>
		<__broken public="1" set="method" line="256"><f a=""><x path="Void"/></f></__broken>
		<__copy public="1" set="method" line="241"><f a=""><c path="nape.constraint.UserConstraint"/></f></__copy>
		<__bindVec2 public="1" set="method" line="223">
			<f a=""><c path="nape.geom.Vec2"/></f>
			<haxe_doc><![CDATA[* Create a Vec2 property for user-constraint.
     * <br/><br/>
     * This method is used in creating a custom constraint, to create a
     * Vec2 property which will be tied to this constraint so that modifications
     * to the Vec2 will have the appropriate side effects on constraint.
     * <pre>
     * //Haxe (Cleanest way without using macros, clearly you must ensure this
     * //      is set at least once, likely in constructor)
     * public var property(default, set_property):Vec2;
     * inline function set_property(property:Vec2) {
     *     if (this.property == null) this.property = __bindVec2();
     *     return this.property.set(property);
     * }
     *
     * //AS3
     * private var _property:Vec2 = __bindVec2();
     * public function get property():Vec2 { return _property; }
     * public function set property(property:Vec2):void {
     *     _property.set(property);
     * }
     * </pre>
     * This bound Vec2 will behave like standard Nape anchor/direction Vec2's.
     * <br/><br/>
     * You should hide this method in your sub-type.]]></haxe_doc>
		</__bindVec2>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.constraint.ZPP_UserConstraint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="376"><f a="dimensions:?velocityOnly">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* UserConstraint providing a low-level API for user-defined Constraints.
 * <br/><br/>
 * This API is intended to be powerful enough to model any constraint that
 * Nape can handle, but not so low level as to be completely prohibitive.
 * <br/>
 * For instance, things like soft-constraints are automatically provided
 * by this API.
 * <br/><br/>
 * Working with this API will require mathematical skills. A full manual
 * for this API is provided at: http://deltaluca.me.uk/docnew/exgif/userdef_constraints.pdf
 * <br/><br/>
 * You may also be interested in the nape-symbolic module that is available
 * on github/haxelib/nape downloads. Which provides a run-time compiled DSL
 * using this API to make prototyping (or creating non-performance critical)
 * user-defined constraints simple without the need for great mathematical
 * skills as well as being much quicker to work with.]]></haxe_doc>
	</class>
	<class path="nape.constraint.WeldJoint" params="" file="libSrc/napeLib/nape/constraint/WeldJoint.hx">
		<extends path="nape.constraint.Constraint"/>
		<visitBodies public="1" set="method" line="414" override="1"><f a="lambda">
	<f a="">
		<c path="nape.phys.Body"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></visitBodies>
		<bodyImpulse public="1" set="method" line="395" override="1"><f a="body">
	<c path="nape.phys.Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<impulse public="1" set="method" line="385" override="1"><f a=""><c path="nape.geom.MatMN"/></f></impulse>
		<set_phase get="inline" set="null" line="333"><f a="phase">
	<x path="Float"/>
	<x path="Float"/>
</f></set_phase>
		<get_phase get="inline" set="null" line="330"><f a=""><x path="Float"/></f></get_phase>
		<phase public="1" get="get_phase" set="set_phase"><x path="Float"/></phase>
		<set_anchor2 get="inline" set="null" line="309"><f a="anchor2">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor2>
		<get_anchor2 get="inline" set="null" line="305"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor2>
		<anchor2 public="1" get="get_anchor2" set="set_anchor2"><c path="nape.geom.Vec2"/></anchor2>
		<set_anchor1 get="inline" set="null" line="284"><f a="anchor1">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_anchor1>
		<get_anchor1 get="inline" set="null" line="280"><f a=""><c path="nape.geom.Vec2"/></f></get_anchor1>
		<anchor1 public="1" get="get_anchor1" set="set_anchor1"><c path="nape.geom.Vec2"/></anchor1>
		<set_body2 get="inline" set="null" line="246"><f a="body2">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body2>
		<get_body2 get="inline" set="null" line="243"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body2>
		<body2 public="1" get="get_body2" set="set_body2"><t path="Null"><c path="nape.phys.Body"/></t></body2>
		<set_body1 get="inline" set="null" line="208"><f a="body1">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body1>
		<get_body1 get="inline" set="null" line="205"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body1>
		<body1 public="1" get="get_body1" set="set_body1">
			<t path="Null"><c path="nape.phys.Body"/></t>
			<haxe_doc><![CDATA[* First Body in constraint.
     * <br/><br/>
     * This value may be null, but trying to simulate the constraint whilst
     * this body is null will result in an error.]]></haxe_doc>
		</body1>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.constraint.ZPP_WeldJoint"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="360"><f a="body1:body2:anchor1:anchor2:?phase">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* WeldJoint constraining two bodies to be exactly locked together.
 * <br/><br/>
 * The equation for this constraint is:
 * <pre>
 * [ body2.localPointToWorld(anchor2) ] = [ body1.localPointToWorld(anchor1) ]
 * [          body2.rotation          ]   [      body1.rotation + phase      ]
 * </pre>
 * This constraint is equivalent to using a PivotJoint and AngleJoint
 * together except that it is solved as a single constraint and thus
 * will be more stable.
 * <br/><br/>
 * This constraint is 3 dimensional.
 * <br/><br/>
 * Although this constraint is very stable, if you chain bodies together
 * using this constraint, you should except to see a small amount of rotation
 * about the anchor points so you should chose them accordingly.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.Arbiter" params="" file="libSrc/napeLib/nape/dynamics/Arbiter.hx">
		<toString public="1" set="method" line="372">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<totalImpulse public="1" set="method" line="350"><f a="?body:?freshOnly">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec3"/>
</f></totalImpulse>
		<get_state get="inline" set="null" line="323"><f a=""><c path="nape.callbacks.PreFlag"/></f></get_state>
		<state public="1" get="get_state" set="null"><c path="nape.callbacks.PreFlag"/></state>
		<get_body2 get="inline" set="null" line="305"><f a=""><c path="nape.phys.Body"/></f></get_body2>
		<body2 public="1" get="get_body2" set="null"><c path="nape.phys.Body"/></body2>
		<get_body1 get="inline" set="null" line="292"><f a=""><c path="nape.phys.Body"/></f></get_body1>
		<body1 public="1" get="get_body1" set="null"><c path="nape.phys.Body"/></body1>
		<get_shape2 get="inline" set="null" line="279"><f a=""><c path="nape.shape.Shape"/></f></get_shape2>
		<shape2 public="1" get="get_shape2" set="null"><c path="nape.shape.Shape"/></shape2>
		<get_shape1 get="inline" set="null" line="266"><f a=""><c path="nape.shape.Shape"/></f></get_shape1>
		<shape1 public="1" get="get_shape1" set="null"><c path="nape.shape.Shape"/></shape1>
		<get_fluidArbiter get="inline" set="null" line="256"><f a=""><t path="Null"><c path="nape.dynamics.FluidArbiter"/></t></f></get_fluidArbiter>
		<fluidArbiter public="1" get="get_fluidArbiter" set="null"><t path="Null"><c path="nape.dynamics.FluidArbiter"/></t></fluidArbiter>
		<get_collisionArbiter get="inline" set="null" line="246"><f a=""><t path="Null"><c path="nape.dynamics.CollisionArbiter"/></t></f></get_collisionArbiter>
		<collisionArbiter public="1" get="get_collisionArbiter" set="null"><t path="Null"><c path="nape.dynamics.CollisionArbiter"/></t></collisionArbiter>
		<isSensorArbiter public="1" get="inline" set="null" line="236"><f a=""><x path="Bool"/></f></isSensorArbiter>
		<isFluidArbiter public="1" get="inline" set="null" line="225"><f a=""><x path="Bool"/></f></isFluidArbiter>
		<isCollisionArbiter public="1" get="inline" set="null" line="214"><f a=""><x path="Bool"/></f></isCollisionArbiter>
		<get_type get="inline" set="null" line="203"><f a=""><c path="nape.dynamics.ArbiterType"/></f></get_type>
		<type public="1" get="get_type" set="null"><c path="nape.dynamics.ArbiterType"/></type>
		<get_isSleeping get="inline" set="null" line="192"><f a=""><x path="Bool"/></f></get_isSleeping>
		<isSleeping public="1" get="get_isSleeping" set="null">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Flag representing arbiter sleep state.
     * <br/><br/>
     * When true, this arbiter is sleeping.]]></haxe_doc>
		</isSleeping>
		<zpp_inner public="1">
			<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="362"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* Arbiter representing the state of an interaction between two Bodys.
 * <br/><br/>
 * These objects are automatically reused, and you should not keep your own
 * references to them.]]></haxe_doc>
	</class>
	<class path="nape.dynamics.ArbiterIterator" params="" file="libSrc/napeLib/nape/dynamics/ArbiterIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.dynamics.ArbiterIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1"><f a="list">
	<c path="nape.dynamics.ArbiterList"/>
	<c path="nape.dynamics.ArbiterIterator"/>
</f></get>
		<next public="1" get="inline" set="null" line="264"><f a=""><c path="nape.dynamics.Arbiter"/></f></next>
		<hasNext public="1" get="inline" set="null" line="240"><f a=""><x path="Bool"/></f></hasNext>
		<zpp_next public="1">
			<c path="nape.dynamics.ArbiterIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.dynamics.ArbiterList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.ArbiterList" params="" file="libSrc/napeLib/nape/dynamics/ArbiterList.hx">
		<fromArray public="1" set="method" line="304" static="1"><f a="array">
	<c path="Array"><c path="nape.dynamics.Arbiter"/></c>
	<c path="nape.dynamics.ArbiterList"/>
</f></fromArray>
		<fromVector public="1" set="method" line="328" static="1"><f a="vector">
	<c path="flash.Vector"><c path="nape.dynamics.Arbiter"/></c>
	<c path="nape.dynamics.ArbiterList"/>
</f></fromVector>
		<filter public="1" set="method" line="779"><f a="lambda">
	<f a="">
		<c path="nape.dynamics.Arbiter"/>
		<x path="Bool"/>
	</f>
	<c path="nape.dynamics.ArbiterList"/>
</f></filter>
		<foreach public="1" set="method" line="732"><f a="lambda">
	<f a="">
		<c path="nape.dynamics.Arbiter"/>
		<x path="Void"/>
	</f>
	<c path="nape.dynamics.ArbiterList"/>
</f></foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<merge public="1" set="method" line="684"><f a="xs">
	<c path="nape.dynamics.ArbiterList"/>
	<x path="Void"/>
</f></merge>
		<copy public="1" set="method" line="662"><f a="?deep">
	<x path="Bool"/>
	<c path="nape.dynamics.ArbiterList"/>
</f></copy>
		<iterator public="1" set="method" line="647"><f a=""><c path="nape.dynamics.ArbiterIterator"/></f></iterator>
		<empty public="1" set="method" line="631"><f a=""><x path="Bool"/></f></empty>
		<clear public="1" set="method" line="614"><f a=""><x path="Void"/></f></clear>
		<remove public="1" set="method" line="576"><f a="obj">
	<c path="nape.dynamics.Arbiter"/>
	<x path="Bool"/>
</f></remove>
		<add public="1" set="method" line="563"><f a="obj">
	<c path="nape.dynamics.Arbiter"/>
	<x path="Bool"/>
</f></add>
		<shift public="1" set="method" line="519"><f a=""><c path="nape.dynamics.Arbiter"/></f></shift>
		<pop public="1" set="method" line="478"><f a=""><c path="nape.dynamics.Arbiter"/></f></pop>
		<unshift public="1" set="method" line="447"><f a="obj">
	<c path="nape.dynamics.Arbiter"/>
	<x path="Bool"/>
</f></unshift>
		<push public="1" set="method" line="416"><f a="obj">
	<c path="nape.dynamics.Arbiter"/>
	<x path="Bool"/>
</f></push>
		<at public="1" set="method" line="363"><f a="index">
	<x path="Int"/>
	<c path="nape.dynamics.Arbiter"/>
</f></at>
		<has public="1" set="method" line="346"><f a="obj">
	<c path="nape.dynamics.Arbiter"/>
	<x path="Bool"/>
</f></has>
		<zpp_vm public="1" set="method" line="291"><f a=""><x path="Void"/></f></zpp_vm>
		<zpp_gl public="1" set="method" line="269"><f a=""><x path="Int"/></f></zpp_gl>
		<get_length get="inline" set="null" line="263"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="get_length" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_ArbiterList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* Nape list of Arbiter type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Arbiter = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Arbiter = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Arbiter = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
	</class>
	<class path="nape.dynamics.ArbiterType" params="" file="libSrc/napeLib/nape/dynamics/ArbiterType.hx">
		<COLLISION public="1" get="get_COLLISION" set="null" static="1"><c path="nape.dynamics.ArbiterType"/></COLLISION>
		<get_COLLISION get="inline" set="null" line="202" static="1"><f a=""><c path="nape.dynamics.ArbiterType"/></f></get_COLLISION>
		<SENSOR public="1" get="get_SENSOR" set="null" static="1"><c path="nape.dynamics.ArbiterType"/></SENSOR>
		<get_SENSOR get="inline" set="null" line="215" static="1"><f a=""><c path="nape.dynamics.ArbiterType"/></f></get_SENSOR>
		<FLUID public="1" get="get_FLUID" set="null" static="1"><c path="nape.dynamics.ArbiterType"/></FLUID>
		<get_FLUID get="inline" set="null" line="228" static="1"><f a=""><c path="nape.dynamics.ArbiterType"/></f></get_FLUID>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of Arbiter types.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.CollisionArbiter" params="" file="libSrc/napeLib/nape/dynamics/CollisionArbiter.hx">
		<extends path="nape.dynamics.Arbiter"/>
		<set_rollingFriction get="inline" set="null" line="709"><f a="rollingFriction">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rollingFriction>
		<get_rollingFriction get="inline" set="null" line="701"><f a=""><x path="Float"/></f></get_rollingFriction>
		<rollingFriction public="1" get="get_rollingFriction" set="set_rollingFriction"><x path="Float"/></rollingFriction>
		<set_staticFriction get="inline" set="null" line="674"><f a="staticFriction">
	<x path="Float"/>
	<x path="Float"/>
</f></set_staticFriction>
		<get_staticFriction get="inline" set="null" line="666"><f a=""><x path="Float"/></f></get_staticFriction>
		<staticFriction public="1" get="get_staticFriction" set="set_staticFriction"><x path="Float"/></staticFriction>
		<set_dynamicFriction get="inline" set="null" line="639"><f a="dynamicFriction">
	<x path="Float"/>
	<x path="Float"/>
</f></set_dynamicFriction>
		<get_dynamicFriction get="inline" set="null" line="631"><f a=""><x path="Float"/></f></get_dynamicFriction>
		<dynamicFriction public="1" get="get_dynamicFriction" set="set_dynamicFriction"><x path="Float"/></dynamicFriction>
		<set_elasticity get="inline" set="null" line="604"><f a="elasticity">
	<x path="Float"/>
	<x path="Float"/>
</f></set_elasticity>
		<get_elasticity get="inline" set="null" line="596"><f a=""><x path="Float"/></f></get_elasticity>
		<elasticity public="1" get="get_elasticity" set="set_elasticity"><x path="Float"/></elasticity>
		<rollingImpulse public="1" set="method" line="573"><f a="?body:?freshOnly">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rollingImpulse>
		<totalImpulse public="1" set="method" line="485" override="1"><f a="?body:?freshOnly">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec3"/>
</f></totalImpulse>
		<tangentImpulse public="1" set="method" line="394"><f a="?body:?freshOnly">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec3"/>
</f></tangentImpulse>
		<normalImpulse public="1" set="method" line="300"><f a="?body:?freshOnly">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec3"/>
</f></normalImpulse>
		<secondVertex public="1" set="method" line="276"><f a=""><x path="Bool"/></f></secondVertex>
		<firstVertex public="1" set="method" line="257"><f a=""><x path="Bool"/></f></firstVertex>
		<get_referenceEdge2 get="inline" set="null" line="239"><f a=""><t path="Null"><c path="nape.shape.Edge"/></t></f></get_referenceEdge2>
		<referenceEdge2 public="1" get="get_referenceEdge2" set="null"><t path="Null"><c path="nape.shape.Edge"/></t></referenceEdge2>
		<get_referenceEdge1 get="inline" set="null" line="225"><f a=""><t path="Null"><c path="nape.shape.Edge"/></t></f></get_referenceEdge1>
		<referenceEdge1 public="1" get="get_referenceEdge1" set="null"><t path="Null"><c path="nape.shape.Edge"/></t></referenceEdge1>
		<get_radius get="inline" set="null" line="213"><f a=""><x path="Float"/></f></get_radius>
		<radius public="1" get="get_radius" set="null"><x path="Float"/></radius>
		<get_normal get="inline" set="null" line="199"><f a=""><c path="nape.geom.Vec2"/></f></get_normal>
		<normal public="1" get="get_normal" set="null"><c path="nape.geom.Vec2"/></normal>
		<get_contacts get="inline" set="null" line="183"><f a=""><c path="nape.dynamics.ContactList"/></f></get_contacts>
		<contacts public="1" get="get_contacts" set="null">
			<c path="nape.dynamics.ContactList"/>
			<haxe_doc>* Set of contact points for the related pairs of shapes.</haxe_doc>
		</contacts>
		<new public="1" set="method" line="728"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Arbiter sub type for collision interactions.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.Contact" params="" file="libSrc/napeLib/nape/dynamics/Contact.hx">
		<toString public="1" set="method" line="403">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<get_friction get="inline" set="null" line="386"><f a=""><x path="Float"/></f></get_friction>
		<friction public="1" get="get_friction" set="null"><x path="Float"/></friction>
		<totalImpulse public="1" set="method" line="337"><f a="?body">
	<c path="nape.phys.Body"/>
	<c path="nape.geom.Vec3"/>
</f></totalImpulse>
		<rollingImpulse public="1" set="method" line="308"><f a="?body">
	<c path="nape.phys.Body"/>
	<x path="Float"/>
</f></rollingImpulse>
		<tangentImpulse public="1" set="method" line="281"><f a="?body">
	<c path="nape.phys.Body"/>
	<c path="nape.geom.Vec3"/>
</f></tangentImpulse>
		<normalImpulse public="1" set="method" line="248"><f a="?body">
	<c path="nape.phys.Body"/>
	<c path="nape.geom.Vec3"/>
</f></normalImpulse>
		<get_fresh get="inline" set="null" line="228"><f a=""><x path="Bool"/></f></get_fresh>
		<fresh public="1" get="get_fresh" set="null"><x path="Bool"/></fresh>
		<get_position get="inline" set="null" line="216"><f a=""><c path="nape.geom.Vec2"/></f></get_position>
		<position public="1" get="get_position" set="null"><c path="nape.geom.Vec2"/></position>
		<get_penetration get="inline" set="null" line="201"><f a=""><x path="Float"/></f></get_penetration>
		<penetration public="1" get="get_penetration" set="null"><x path="Float"/></penetration>
		<get_arbiter get="inline" set="null" line="189"><f a=""><c path="nape.dynamics.CollisionArbiter"/></f></get_arbiter>
		<arbiter public="1" get="get_arbiter" set="null">
			<c path="nape.dynamics.CollisionArbiter"/>
			<haxe_doc>* Reference to the CollisionArbiter this contact belongs to</haxe_doc>
		</arbiter>
		<zpp_inner public="1">
			<c path="zpp_nape.dynamics.ZPP_Contact"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="395"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* Contact point for collision interactions
 * <br/><br/>
 * These objects are automatically reused and you should not keep references to them.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.ContactIterator" params="" file="libSrc/napeLib/nape/dynamics/ContactIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.dynamics.ContactIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1"><f a="list">
	<c path="nape.dynamics.ContactList"/>
	<c path="nape.dynamics.ContactIterator"/>
</f></get>
		<next public="1" get="inline" set="null" line="264"><f a=""><c path="nape.dynamics.Contact"/></f></next>
		<hasNext public="1" get="inline" set="null" line="240"><f a=""><x path="Bool"/></f></hasNext>
		<zpp_next public="1">
			<c path="nape.dynamics.ContactIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.dynamics.ContactList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.ContactList" params="" file="libSrc/napeLib/nape/dynamics/ContactList.hx">
		<fromArray public="1" set="method" line="304" static="1"><f a="array">
	<c path="Array"><c path="nape.dynamics.Contact"/></c>
	<c path="nape.dynamics.ContactList"/>
</f></fromArray>
		<fromVector public="1" set="method" line="328" static="1"><f a="vector">
	<c path="flash.Vector"><c path="nape.dynamics.Contact"/></c>
	<c path="nape.dynamics.ContactList"/>
</f></fromVector>
		<filter public="1" set="method" line="779"><f a="lambda">
	<f a="">
		<c path="nape.dynamics.Contact"/>
		<x path="Bool"/>
	</f>
	<c path="nape.dynamics.ContactList"/>
</f></filter>
		<foreach public="1" get="inline" set="null" line="732"><f a="lambda">
	<f a="">
		<c path="nape.dynamics.Contact"/>
		<x path="Void"/>
	</f>
	<c path="nape.dynamics.ContactList"/>
</f></foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<merge public="1" set="method" line="684"><f a="xs">
	<c path="nape.dynamics.ContactList"/>
	<x path="Void"/>
</f></merge>
		<copy public="1" set="method" line="662"><f a="?deep">
	<x path="Bool"/>
	<c path="nape.dynamics.ContactList"/>
</f></copy>
		<iterator public="1" get="inline" set="null" line="647"><f a=""><c path="nape.dynamics.ContactIterator"/></f></iterator>
		<empty public="1" get="inline" set="null" line="631"><f a=""><x path="Bool"/></f></empty>
		<clear public="1" set="method" line="614"><f a=""><x path="Void"/></f></clear>
		<remove public="1" set="method" line="576"><f a="obj">
	<c path="nape.dynamics.Contact"/>
	<x path="Bool"/>
</f></remove>
		<add public="1" get="inline" set="null" line="563"><f a="obj">
	<c path="nape.dynamics.Contact"/>
	<x path="Bool"/>
</f></add>
		<shift public="1" set="method" line="519"><f a=""><c path="nape.dynamics.Contact"/></f></shift>
		<pop public="1" set="method" line="478"><f a=""><c path="nape.dynamics.Contact"/></f></pop>
		<unshift public="1" set="method" line="447"><f a="obj">
	<c path="nape.dynamics.Contact"/>
	<x path="Bool"/>
</f></unshift>
		<push public="1" set="method" line="416"><f a="obj">
	<c path="nape.dynamics.Contact"/>
	<x path="Bool"/>
</f></push>
		<at public="1" set="method" line="363"><f a="index">
	<x path="Int"/>
	<c path="nape.dynamics.Contact"/>
</f></at>
		<has public="1" set="method" line="346"><f a="obj">
	<c path="nape.dynamics.Contact"/>
	<x path="Bool"/>
</f></has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="get_length" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_ContactList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* Nape list of Contact type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Contact = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Contact = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Contact = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.FluidArbiter" params="" file="libSrc/napeLib/nape/dynamics/FluidArbiter.hx">
		<extends path="nape.dynamics.Arbiter"/>
		<totalImpulse public="1" set="method" line="298" override="1"><f a="?body:?freshOnly">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec3"/>
</f></totalImpulse>
		<dragImpulse public="1" set="method" line="275"><f a="?body">
	<c path="nape.phys.Body"/>
	<c path="nape.geom.Vec3"/>
</f></dragImpulse>
		<buoyancyImpulse public="1" set="method" line="246"><f a="?body">
	<c path="nape.phys.Body"/>
	<c path="nape.geom.Vec3"/>
</f></buoyancyImpulse>
		<set_overlap get="inline" set="null" line="220"><f a="overlap">
	<x path="Float"/>
	<x path="Float"/>
</f></set_overlap>
		<get_overlap get="inline" set="null" line="214"><f a=""><x path="Float"/></f></get_overlap>
		<overlap public="1" get="get_overlap" set="set_overlap"><x path="Float"/></overlap>
		<set_position get="inline" set="null" line="192"><f a="position">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_position>
		<get_position get="inline" set="null" line="185"><f a=""><c path="nape.geom.Vec2"/></f></get_position>
		<position public="1" get="get_position" set="set_position">
			<c path="nape.geom.Vec2"/>
			<haxe_doc><![CDATA[* Centre of buoyancy for fluid interaction.
     * <br/><br/>
     * This value can be modified during a related PreListener handler.]]></haxe_doc>
		</position>
		<new public="1" set="method" line="316"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Fluid interaction subtype for Arbiter.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.InteractionFilter" params="" file="libSrc/napeLib/nape/dynamics/InteractionFilter.hx">
		<toString public="1" set="method" line="451"><f a=""><c path="String"/></f></toString>
		<copy public="1" set="method" line="444"><f a=""><c path="nape.dynamics.InteractionFilter"/></f></copy>
		<shouldFlow public="1" set="method" line="432"><f a="filter">
	<c path="nape.dynamics.InteractionFilter"/>
	<x path="Bool"/>
</f></shouldFlow>
		<shouldSense public="1" set="method" line="416"><f a="filter">
	<c path="nape.dynamics.InteractionFilter"/>
	<x path="Bool"/>
</f></shouldSense>
		<shouldCollide public="1" set="method" line="400"><f a="filter">
	<c path="nape.dynamics.InteractionFilter"/>
	<x path="Bool"/>
</f></shouldCollide>
		<set_fluidMask get="inline" set="null" line="342"><f a="fluidMask">
	<x path="Int"/>
	<x path="Int"/>
</f></set_fluidMask>
		<get_fluidMask get="inline" set="null" line="339"><f a=""><x path="Int"/></f></get_fluidMask>
		<fluidMask public="1" get="get_fluidMask" set="set_fluidMask"><x path="Int"/></fluidMask>
		<set_fluidGroup get="inline" set="null" line="324"><f a="fluidGroup">
	<x path="Int"/>
	<x path="Int"/>
</f></set_fluidGroup>
		<get_fluidGroup get="inline" set="null" line="321"><f a=""><x path="Int"/></f></get_fluidGroup>
		<fluidGroup public="1" get="get_fluidGroup" set="set_fluidGroup"><x path="Int"/></fluidGroup>
		<set_sensorMask get="inline" set="null" line="306"><f a="sensorMask">
	<x path="Int"/>
	<x path="Int"/>
</f></set_sensorMask>
		<get_sensorMask get="inline" set="null" line="303"><f a=""><x path="Int"/></f></get_sensorMask>
		<sensorMask public="1" get="get_sensorMask" set="set_sensorMask"><x path="Int"/></sensorMask>
		<set_sensorGroup get="inline" set="null" line="288"><f a="sensorGroup">
	<x path="Int"/>
	<x path="Int"/>
</f></set_sensorGroup>
		<get_sensorGroup get="inline" set="null" line="285"><f a=""><x path="Int"/></f></get_sensorGroup>
		<sensorGroup public="1" get="get_sensorGroup" set="set_sensorGroup"><x path="Int"/></sensorGroup>
		<set_collisionMask get="inline" set="null" line="270"><f a="collisionMask">
	<x path="Int"/>
	<x path="Int"/>
</f></set_collisionMask>
		<get_collisionMask get="inline" set="null" line="267"><f a=""><x path="Int"/></f></get_collisionMask>
		<collisionMask public="1" get="get_collisionMask" set="set_collisionMask"><x path="Int"/></collisionMask>
		<set_collisionGroup get="inline" set="null" line="252"><f a="collisionGroup">
	<x path="Int"/>
	<x path="Int"/>
</f></set_collisionGroup>
		<get_collisionGroup get="inline" set="null" line="249"><f a=""><x path="Int"/></f></get_collisionGroup>
		<collisionGroup public="1" get="get_collisionGroup" set="set_collisionGroup"><x path="Int"/></collisionGroup>
		<get_shapes get="inline" set="null" line="239"><f a=""><c path="nape.shape.ShapeList"/></f></get_shapes>
		<shapes public="1" get="get_shapes" set="null"><c path="nape.shape.ShapeList"/></shapes>
		<get_userData get="inline" set="null" line="224"><f a=""><d><d/></d></f></get_userData>
		<userData public="1" get="get_userData" set="null">
			<d><d/></d>
			<haxe_doc><![CDATA[* Dynamic object for user to store additional data.
     * <br/><br/>
     * This object cannot be set, only its dynamically created
     * properties may be set. In AS3 the type of this property is &#42
     * <br/><br/>
     * This object will be lazily constructed so that until accessed
     * for the first time, will be null internally.
     *
     * @default {}]]></haxe_doc>
		</userData>
		<zpp_inner public="1">
			<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="364"><f a="?collisionGroup:?collisionMask:?sensorGroup:?sensorMask:?fluidGroup:?fluidMask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* InteractionFilter provides bit flags for low-level filtering of interactions.
 * <br/><br/>
 * For a given interaction type, two Shapes will be permitted to interact only if
 * <code>(shape1.group & shape2.mask) != 0 && (shape2.group & shape1.mask) != 0</code>
 * <br/><br/>
 * There are 32 real groups corresponding to a set bit in the group/mask fields. For instance
 * a group value of 0x120 corresponds to the 'real' groups 5 and 8 as <code>0x120 = (1<<5) | (1<<8)</code>
 * <br/><br/>
 * Nape provides group/mask for each interaction type. The actual precedence of interactions
 * is further defined simply as: Sensor > Fluid > Collision.
 * <br/>
 * Two static bodies can never interact, and with the exception of sensor interaction, at least one
 * of the two bodies must be dynamic.
 * <br/>
 * Sensor interactions have the highest precedence, followed by fluid and then collisions.
 * Sensor interaction is permitted only if one of the shapes is sensorEnabled, whilst fluid
 * is permitted only if one of the shapes is fluidEnabled.
 * <pre>
 * if ((shapeA.sensorEnabled || shapeB.sensorEnabled) && shapeA.filter.shouldSense(shapeB.filter)) {
 *     SENSOR INTERACTION!!
 * }
 * else if (bodyA.isDynamic() || bodyB.isDynamic()) {
 *     if ((shapeA.fluidEnabled || shapeB.fluidEnabled) && shapeA.filter.shouldFlow(shapeB.filter)) {
 *         FLUID INTERACTION!!
 *     }
 *     else if (shapeA.filter.shouldCollide(shapeB.filter)) {
 *         COLLISION INTERACTION!!
 *     }
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.InteractionGroup" params="" file="libSrc/napeLib/nape/dynamics/InteractionGroup.hx">
		<toString public="1" set="method" line="299"><f a=""><c path="String"/></f></toString>
		<get_groups get="inline" set="null" line="282"><f a=""><c path="nape.dynamics.InteractionGroupList"/></f></get_groups>
		<groups public="1" get="get_groups" set="null"><c path="nape.dynamics.InteractionGroupList"/></groups>
		<get_interactors get="inline" set="null" line="268"><f a=""><c path="nape.phys.InteractorList"/></f></get_interactors>
		<interactors public="1" get="get_interactors" set="null"><c path="nape.phys.InteractorList"/></interactors>
		<set_ignore get="inline" set="null" line="250"><f a="ignore">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ignore>
		<get_ignore get="inline" set="null" line="247"><f a=""><x path="Bool"/></f></get_ignore>
		<ignore public="1" get="get_ignore" set="set_ignore"><x path="Bool"/></ignore>
		<set_group get="inline" set="null" line="232"><f a="group">
	<t path="Null"><c path="nape.dynamics.InteractionGroup"/></t>
	<t path="Null"><c path="nape.dynamics.InteractionGroup"/></t>
</f></set_group>
		<get_group get="inline" set="null" line="229"><f a=""><t path="Null"><c path="nape.dynamics.InteractionGroup"/></t></f></get_group>
		<group public="1" get="get_group" set="set_group">
			<t path="Null"><c path="nape.dynamics.InteractionGroup"/></t>
			<haxe_doc>* Parent group in InteractionGroup tree.
     * @default null</haxe_doc>
		</group>
		<zpp_inner public="1">
			<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="291"><f a="?ignore">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* InteractionGroups are another way of filtering interactions.
 * <br/><br/>
 * InteractionGroups form tree structures which are checked along side InteractionFilters
 * when deciding if two Shapes should interact.
 * <br/><br/>
 * InteractionGroups are assigned to any Interactor (not just Shapes), and two Shapes will
 * interact only if the most recent common ancestor in the InteractionGroup tree permits it.
 * <br/><br/>
 * For the purposes of the search, if any Interactor has no InteractionGroup assigned, we
 * search up the Compound tree first.
 * <pre>
 *            _Group1
 *           /   |
 *          /  Group2      Group3
 *         /    |    \       |                 Group1
 *     Body1   /      Cmp1   |                 /   \           Group3
 *    /    \  /      /    \  |      ==>    Shp1    Group2        |
 * Shp1   Shp2   Body2     Cmp2                    /    \      Shp4
 *                 |         |                  Shp2    Shp3
 *                Shp3     Body3
 *                           |
 *                         Shp4
 * </pre>
 * If we look at which InteractionGroup is used for which Shape following this rule, then
 * the left graph can be transformed into an InteractionGroup tree on the right and we get
 * that the MRCA (Most recent common ancestors) are such that:
 * <pre>
 * MRCA(Shp1, Shp3) == Group1;
 * MRCA(Shp2, Shp3) == Group2;
 * MRCA(Shp4,   # ) == null;
 * </pre>
 * If we were to set up the groups such that <code>Group1.ignore = false</code> and
 * <code>Group2.ignore = true</code>; then shapes 1 and 3 would not be permitted to
 * interact, whilst shapes 2 and 3 would be permitted.
 * <br/>
 * As the MRCA for shape 4 with any other is null, then the value of Group3's ignore field
 * is irrelevant, but the existance of Group3 is not as it serves to otherwise prevent Shape 4
 * from being permitted to interact with shapes 2 and 3.
 * <br/><br/>
 * InteractionGroup's can be fairly expressive, but they are strictly less powerful than
 * InteractionFilters. InteractionGroup's have their place however as there is no limit
 * to the number of Groups you can use.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.InteractionGroupIterator" params="" file="libSrc/napeLib/nape/dynamics/InteractionGroupIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.dynamics.InteractionGroupIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1"><f a="list">
	<c path="nape.dynamics.InteractionGroupList"/>
	<c path="nape.dynamics.InteractionGroupIterator"/>
</f></get>
		<next public="1" get="inline" set="null" line="264"><f a=""><c path="nape.dynamics.InteractionGroup"/></f></next>
		<hasNext public="1" get="inline" set="null" line="240"><f a=""><x path="Bool"/></f></hasNext>
		<zpp_next public="1">
			<c path="nape.dynamics.InteractionGroupIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.dynamics.InteractionGroupList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.dynamics.InteractionGroupList" params="" file="libSrc/napeLib/nape/dynamics/InteractionGroupList.hx">
		<fromArray public="1" set="method" line="304" static="1"><f a="array">
	<c path="Array"><c path="nape.dynamics.InteractionGroup"/></c>
	<c path="nape.dynamics.InteractionGroupList"/>
</f></fromArray>
		<fromVector public="1" set="method" line="328" static="1"><f a="vector">
	<c path="flash.Vector"><c path="nape.dynamics.InteractionGroup"/></c>
	<c path="nape.dynamics.InteractionGroupList"/>
</f></fromVector>
		<filter public="1" set="method" line="779"><f a="lambda">
	<f a="">
		<c path="nape.dynamics.InteractionGroup"/>
		<x path="Bool"/>
	</f>
	<c path="nape.dynamics.InteractionGroupList"/>
</f></filter>
		<foreach public="1" get="inline" set="null" line="732"><f a="lambda">
	<f a="">
		<c path="nape.dynamics.InteractionGroup"/>
		<x path="Void"/>
	</f>
	<c path="nape.dynamics.InteractionGroupList"/>
</f></foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<merge public="1" set="method" line="684"><f a="xs">
	<c path="nape.dynamics.InteractionGroupList"/>
	<x path="Void"/>
</f></merge>
		<copy public="1" set="method" line="662"><f a="?deep">
	<x path="Bool"/>
	<c path="nape.dynamics.InteractionGroupList"/>
</f></copy>
		<iterator public="1" get="inline" set="null" line="647"><f a=""><c path="nape.dynamics.InteractionGroupIterator"/></f></iterator>
		<empty public="1" get="inline" set="null" line="631"><f a=""><x path="Bool"/></f></empty>
		<clear public="1" set="method" line="614"><f a=""><x path="Void"/></f></clear>
		<remove public="1" set="method" line="576"><f a="obj">
	<c path="nape.dynamics.InteractionGroup"/>
	<x path="Bool"/>
</f></remove>
		<add public="1" get="inline" set="null" line="563"><f a="obj">
	<c path="nape.dynamics.InteractionGroup"/>
	<x path="Bool"/>
</f></add>
		<shift public="1" set="method" line="519"><f a=""><c path="nape.dynamics.InteractionGroup"/></f></shift>
		<pop public="1" set="method" line="478"><f a=""><c path="nape.dynamics.InteractionGroup"/></f></pop>
		<unshift public="1" set="method" line="447"><f a="obj">
	<c path="nape.dynamics.InteractionGroup"/>
	<x path="Bool"/>
</f></unshift>
		<push public="1" set="method" line="416"><f a="obj">
	<c path="nape.dynamics.InteractionGroup"/>
	<x path="Bool"/>
</f></push>
		<at public="1" set="method" line="363"><f a="index">
	<x path="Int"/>
	<c path="nape.dynamics.InteractionGroup"/>
</f></at>
		<has public="1" set="method" line="346"><f a="obj">
	<c path="nape.dynamics.InteractionGroup"/>
	<x path="Bool"/>
</f></has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="get_length" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_InteractionGroupList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* Nape list of InteractionGroup type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:InteractionGroup = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:InteractionGroup = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:InteractionGroup = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.AABB" params="" file="libSrc/napeLib/nape/geom/AABB.hx">
		<fromRect public="1" set="method" line="243" static="1"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="nape.geom.AABB"/>
</f></fromRect>
		<toString public="1" set="method" line="493">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<set_height get="inline" set="null" line="468"><f a="height">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<get_height get="inline" set="null" line="464"><f a=""><x path="Float"/></f></get_height>
		<height public="1" get="get_height" set="set_height"><x path="Float"/></height>
		<set_width get="inline" set="null" line="434"><f a="width">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<get_width get="inline" set="null" line="430"><f a=""><x path="Float"/></f></get_width>
		<width public="1" get="get_width" set="set_width"><x path="Float"/></width>
		<set_y get="inline" set="null" line="404"><f a="y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<get_y get="inline" set="null" line="400"><f a=""><x path="Float"/></f></get_y>
		<y public="1" get="get_y" set="set_y"><x path="Float"/></y>
		<set_x get="inline" set="null" line="374"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<get_x get="inline" set="null" line="370"><f a=""><x path="Float"/></f></get_x>
		<x public="1" get="get_x" set="set_x"><x path="Float"/></x>
		<set_max get="inline" set="null" line="332"><f a="max">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_max>
		<get_max get="inline" set="null" line="329"><f a=""><c path="nape.geom.Vec2"/></f></get_max>
		<max public="1" get="get_max" set="set_max"><c path="nape.geom.Vec2"/></max>
		<set_min get="inline" set="null" line="283"><f a="min">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_min>
		<get_min get="inline" set="null" line="280"><f a=""><c path="nape.geom.Vec2"/></f></get_min>
		<min public="1" get="get_min" set="set_min"><c path="nape.geom.Vec2"/></min>
		<toRect public="1" set="method" line="260"><f a=""><c path="flash.geom.Rectangle"/></f></toRect>
		<copy public="1" set="method" line="226"><f a=""><c path="nape.geom.AABB"/></f></copy>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_AABB"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="205">
			<f a="?x:?y:?width:?height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new AABB.
     * <br/><br/>
     * As input width/height are permitted to be negative it is not guaranteed
     * that the resultant AABB will have the same parameters as those
     * specified as the AABB parameters are guaranteed to always have positive
     * width/height, and for x/y to always be the top-left corner.
     *
     * @param x      The x coordinate of the top-left corner of the AABB.
     *               (default 0)
     * @param y      The y coordinate of the top-left corner of the AABB
     *               (default 0)
     * @param width  The width of the AABB. This value may be negative.
     *               (default 0)
     * @param height The height of the AABB. This value may be negative.
     *               (default 0)
     * @return       The newly constructed AABB object.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Axis Aligned Bounding Box (AABB)
 * <br/><br/>
 * Note that in many cases of an AABB object being returned by a Nape function
 * the AABB object will be marked internally as an 'immutable' AABB. This will
 * always be documented and trying to mutate such an AABB will result in an
 * error being thrown.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.ConvexResult" params="" file="libSrc/napeLib/nape/geom/ConvexResult.hx">
		<toString public="1" set="method" line="252">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<dispose public="1" get="inline" set="null" line="243"><f a=""><x path="Void"/></f></dispose>
		<get_shape get="inline" set="null" line="223"><f a=""><c path="nape.shape.Shape"/></f></get_shape>
		<shape public="1" get="get_shape" set="null"><c path="nape.shape.Shape"/></shape>
		<get_toi get="inline" set="null" line="212"><f a=""><x path="Float"/></f></get_toi>
		<toi public="1" get="get_toi" set="null"><x path="Float"/></toi>
		<get_position get="inline" set="null" line="201"><f a=""><c path="nape.geom.Vec2"/></f></get_position>
		<position public="1" get="get_position" set="null"><c path="nape.geom.Vec2"/></position>
		<get_normal get="inline" set="null" line="190"><f a=""><c path="nape.geom.Vec2"/></f></get_normal>
		<normal public="1" get="get_normal" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc>* The normal of the surface at collision.</haxe_doc>
		</normal>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_ConvexRayResult"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="234"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* Class representing the results of a convex cast operation.
 * <br/><br/>
 * These objects are allocated from an object pool and can
 * be released back to that pool by calling its dispose method.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.ConvexResultIterator" params="" file="libSrc/napeLib/nape/geom/ConvexResultIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.geom.ConvexResultIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1"><f a="list">
	<c path="nape.geom.ConvexResultList"/>
	<c path="nape.geom.ConvexResultIterator"/>
</f></get>
		<next public="1" get="inline" set="null" line="264"><f a=""><c path="nape.geom.ConvexResult"/></f></next>
		<hasNext public="1" get="inline" set="null" line="240"><f a=""><x path="Bool"/></f></hasNext>
		<zpp_next public="1">
			<c path="nape.geom.ConvexResultIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.geom.ConvexResultList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.ConvexResultList" params="" file="libSrc/napeLib/nape/geom/ConvexResultList.hx">
		<fromArray public="1" set="method" line="304" static="1"><f a="array">
	<c path="Array"><c path="nape.geom.ConvexResult"/></c>
	<c path="nape.geom.ConvexResultList"/>
</f></fromArray>
		<fromVector public="1" set="method" line="328" static="1"><f a="vector">
	<c path="flash.Vector"><c path="nape.geom.ConvexResult"/></c>
	<c path="nape.geom.ConvexResultList"/>
</f></fromVector>
		<filter public="1" set="method" line="779"><f a="lambda">
	<f a="">
		<c path="nape.geom.ConvexResult"/>
		<x path="Bool"/>
	</f>
	<c path="nape.geom.ConvexResultList"/>
</f></filter>
		<foreach public="1" get="inline" set="null" line="732"><f a="lambda">
	<f a="">
		<c path="nape.geom.ConvexResult"/>
		<x path="Void"/>
	</f>
	<c path="nape.geom.ConvexResultList"/>
</f></foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<merge public="1" set="method" line="684"><f a="xs">
	<c path="nape.geom.ConvexResultList"/>
	<x path="Void"/>
</f></merge>
		<copy public="1" set="method" line="662"><f a="?deep">
	<x path="Bool"/>
	<c path="nape.geom.ConvexResultList"/>
</f></copy>
		<iterator public="1" get="inline" set="null" line="647"><f a=""><c path="nape.geom.ConvexResultIterator"/></f></iterator>
		<empty public="1" get="inline" set="null" line="631"><f a=""><x path="Bool"/></f></empty>
		<clear public="1" set="method" line="614"><f a=""><x path="Void"/></f></clear>
		<remove public="1" set="method" line="576"><f a="obj">
	<c path="nape.geom.ConvexResult"/>
	<x path="Bool"/>
</f></remove>
		<add public="1" get="inline" set="null" line="563"><f a="obj">
	<c path="nape.geom.ConvexResult"/>
	<x path="Bool"/>
</f></add>
		<shift public="1" set="method" line="519"><f a=""><c path="nape.geom.ConvexResult"/></f></shift>
		<pop public="1" set="method" line="478"><f a=""><c path="nape.geom.ConvexResult"/></f></pop>
		<unshift public="1" set="method" line="447"><f a="obj">
	<c path="nape.geom.ConvexResult"/>
	<x path="Bool"/>
</f></unshift>
		<push public="1" set="method" line="416"><f a="obj">
	<c path="nape.geom.ConvexResult"/>
	<x path="Bool"/>
</f></push>
		<at public="1" set="method" line="363"><f a="index">
	<x path="Int"/>
	<c path="nape.geom.ConvexResult"/>
</f></at>
		<has public="1" set="method" line="346"><f a="obj">
	<c path="nape.geom.ConvexResult"/>
	<x path="Bool"/>
</f></has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="get_length" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_ConvexResultList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* Nape list of ConvexResult type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:ConvexResult = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:ConvexResult = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:ConvexResult = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.Geom" params="" file="libSrc/napeLib/nape/geom/Geom.hx">
		<distanceBody public="1" set="method" line="223" static="1">
			<f a="body1:body2:out1:out2">
				<c path="nape.phys.Body"/>
				<c path="nape.phys.Body"/>
				<c path="nape.geom.Vec2"/>
				<c path="nape.geom.Vec2"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Determine distance and closest points between two Bodies.
     * <br/><br/>
     * If the bodies are intersecting, then a negative value is returned
     * equal to the penetration of the bodies, and the out1/out2 vectors
     * will still be meaningful with their difference being the minimum
     * translational vector to seperate the intersecting shapes of the bodies.
     * (This may not be a global seperation vector as it is considering only
     *  one pair of shapes at a time).
     * <br/><br/>
     * As the out1/out2 vectors are used to return values from the function,
     * this is one of the rare cases where should out1/out2 be weak Vec2's
     * they will 'not' be sent to the global object pool on being passed to
     * this function.
     * <pre>
     * var closest1 = Vec2.get();
     * var closest2 = Vec2.get();
     * var distance = Geom.distanceBody(body1, body2, out1, out2);
     * if (distance < 0) {
     *     trace("Bodies intersect and penetration distance is " +
     *           (-distance) + " with witness points " + closest1.toString() +
     *           " <-> " + closest2.toString());
     * }else {
     *     trace("Bodies do not intersect and distance betweem them is " +
     *           distance + " with closest points " + closest1.toString() +
     *           " <-> " + closest2.toString());
     * }
     * </pre>
     * This algorithm is able to take shortcuts in culling pair tests between Shapes
     * based on the current state of the search, and will be more effecient than
     * a custom implementation that uses Geom.distance(..) method.
     *
     * @param body1 First input Body.
     * @param body2 Second input Body.
     * @param out1 This Vec2 object will be populated with coordinates of
     *             closest point on body1.
     * @param out2 This Vec2 object will be populated with coordinates of
     *             closest point on body2.
     * @return The distance between the two bodies if seperated, or the
     *         penetration distance (negative) if intersecting.
     * @throws # If either body has no shapes.
     * @throws # If out1 or out2 has been disposed.
     * @throws # If out1 or out2 is immutable.]]></haxe_doc>
		</distanceBody>
		<distance public="1" set="method" line="301" static="1"><f a="shape1:shape2:out1:out2">
	<c path="nape.shape.Shape"/>
	<c path="nape.shape.Shape"/>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
</f></distance>
		<intersectsBody public="1" set="method" line="370" static="1"><f a="body1:body2">
	<c path="nape.phys.Body"/>
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
</f></intersectsBody>
		<intersects public="1" set="method" line="435" static="1"><f a="shape1:shape2">
	<c path="nape.shape.Shape"/>
	<c path="nape.shape.Shape"/>
	<x path="Bool"/>
</f></intersects>
		<contains public="1" set="method" line="456" static="1"><f a="shape1:shape2">
	<c path="nape.shape.Shape"/>
	<c path="nape.shape.Shape"/>
	<x path="Bool"/>
</f></contains>
		<haxe_doc>* Geom class provides interface to collision detection routines in nape.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.GeomPoly" params="" file="libSrc/napeLib/nape/geom/GeomPoly.hx">
		<get public="1" set="method" line="1175" static="1"><f a="?vertices">
	<d/>
	<c path="nape.geom.GeomPoly"/>
</f></get>
		<right public="1" set="method" line="2770"><f a=""><c path="nape.geom.Vec2"/></f></right>
		<left public="1" set="method" line="2728"><f a=""><c path="nape.geom.Vec2"/></f></left>
		<bottom public="1" set="method" line="2686"><f a=""><c path="nape.geom.Vec2"/></f></bottom>
		<top public="1" set="method" line="2644"><f a=""><c path="nape.geom.Vec2"/></f></top>
		<bounds public="1" set="method" line="2562"><f a=""><c path="nape.geom.AABB"/></f></bounds>
		<transform public="1" set="method" line="2521"><f a="matrix">
	<c path="nape.geom.Mat23"/>
	<c path="nape.geom.GeomPoly"/>
</f></transform>
		<cut public="1" set="method" line="2460"><f a="start:end:?boundedStart:?boundedEnd:?output">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="nape.geom.GeomPolyList"/>
	<c path="nape.geom.GeomPolyList"/>
</f></cut>
		<inflate public="1" set="method" line="2227"><f a="inflation">
	<x path="Float"/>
	<c path="nape.geom.GeomPoly"/>
</f></inflate>
		<triangularDecomposition public="1" set="method" line="2154"><f a="?delaunay:?output">
	<x path="Bool"/>
	<c path="nape.geom.GeomPolyList"/>
	<c path="nape.geom.GeomPolyList"/>
</f></triangularDecomposition>
		<convexDecomposition public="1" set="method" line="2075"><f a="?delaunay:?output">
	<x path="Bool"/>
	<c path="nape.geom.GeomPolyList"/>
	<c path="nape.geom.GeomPolyList"/>
</f></convexDecomposition>
		<monotoneDecomposition public="1" set="method" line="2019"><f a="?output">
	<c path="nape.geom.GeomPolyList"/>
	<c path="nape.geom.GeomPolyList"/>
</f></monotoneDecomposition>
		<simpleDecomposition public="1" set="method" line="1973"><f a="?output">
	<c path="nape.geom.GeomPolyList"/>
	<c path="nape.geom.GeomPolyList"/>
</f></simpleDecomposition>
		<simplify public="1" set="method" line="1931"><f a="epsilon">
	<x path="Float"/>
	<c path="nape.geom.GeomPoly"/>
</f></simplify>
		<isDegenerate public="1" get="inline" set="null" line="1895"><f a=""><x path="Bool"/></f></isDegenerate>
		<isMonotone public="1" get="inline" set="null" line="1875"><f a=""><x path="Bool"/></f></isMonotone>
		<isSimple public="1" get="inline" set="null" line="1844"><f a=""><x path="Bool"/></f></isSimple>
		<isConvex public="1" set="method" line="1735"><f a=""><x path="Bool"/></f></isConvex>
		<isClockwise public="1" get="inline" set="null" line="1707"><f a=""><x path="Bool"/></f></isClockwise>
		<contains public="1" set="method" line="1641"><f a="point">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
</f></contains>
		<winding public="1" set="method" line="1565"><f a=""><c path="nape.geom.Winding"/></f></winding>
		<area public="1" set="method" line="1487"><f a=""><x path="Float"/></f></area>
		<toString public="1" set="method" line="1454">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<dispose public="1" set="method" line="1416"><f a=""><x path="Void"/></f></dispose>
		<copy public="1" set="method" line="902"><f a=""><c path="nape.geom.GeomPoly"/></f></copy>
		<clear public="1" set="method" line="827"><f a=""><c path="nape.geom.GeomPoly"/></f></clear>
		<erase public="1" set="method" line="737"><f a="count">
	<x path="Int"/>
	<c path="nape.geom.GeomPoly"/>
</f></erase>
		<skipBackwards public="1" get="inline" set="null" line="698"><f a="times">
	<x path="Int"/>
	<c path="nape.geom.GeomPoly"/>
</f></skipBackwards>
		<skipForward public="1" set="method" line="656"><f a="times">
	<x path="Int"/>
	<c path="nape.geom.GeomPoly"/>
</f></skipForward>
		<shift public="1" set="method" line="576"><f a=""><c path="nape.geom.GeomPoly"/></f></shift>
		<unshift public="1" set="method" line="518"><f a="vertex">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.GeomPoly"/>
</f></unshift>
		<pop public="1" set="method" line="436"><f a=""><c path="nape.geom.GeomPoly"/></f></pop>
		<push public="1" set="method" line="374"><f a="vertex">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.GeomPoly"/>
</f></push>
		<current public="1" get="inline" set="null" line="334"><f a=""><c path="nape.geom.Vec2"/></f></current>
		<backwardsIterator public="1" get="inline" set="null" line="308"><f a=""><c path="nape.geom.GeomVertexIterator"/></f></backwardsIterator>
		<forwardIterator public="1" get="inline" set="null" line="292"><f a=""><c path="nape.geom.GeomVertexIterator"/></f></forwardIterator>
		<iterator public="1" get="inline" set="null" line="276"><f a=""><c path="nape.geom.GeomVertexIterator"/></f></iterator>
		<size public="1" set="method" line="243"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="229">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Determine if polygon is empty.
     *
     * @return True if polygon is empty.
     * @throws # If this GeomPoly has been disposed.</haxe_doc>
		</empty>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_GeomPoly"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<zpp_disp public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_disp>
		<zpp_pool public="1">
			<c path="nape.geom.GeomPoly"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<new public="1" set="method" line="954"><f a="?vertices">
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* Polygon class with various geometric methods
 * <br/><br/>
 * This class represents a general Polygon, rather than the Polygon class
 * which is physics shape.
 * <br/><br/>
 * Internally this polygon is stored as a circularly linked list of special
 * vertex types that are exposed via a Vec2 that is lazily constructed whenever
 * necessary to the API.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.GeomPolyIterator" params="" file="libSrc/napeLib/nape/geom/GeomPolyIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.geom.GeomPolyIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1"><f a="list">
	<c path="nape.geom.GeomPolyList"/>
	<c path="nape.geom.GeomPolyIterator"/>
</f></get>
		<next public="1" get="inline" set="null" line="264"><f a=""><c path="nape.geom.GeomPoly"/></f></next>
		<hasNext public="1" get="inline" set="null" line="240"><f a=""><x path="Bool"/></f></hasNext>
		<zpp_next public="1">
			<c path="nape.geom.GeomPolyIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.geom.GeomPolyList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.GeomPolyList" params="" file="libSrc/napeLib/nape/geom/GeomPolyList.hx">
		<fromArray public="1" set="method" line="304" static="1"><f a="array">
	<c path="Array"><c path="nape.geom.GeomPoly"/></c>
	<c path="nape.geom.GeomPolyList"/>
</f></fromArray>
		<fromVector public="1" set="method" line="328" static="1"><f a="vector">
	<c path="flash.Vector"><c path="nape.geom.GeomPoly"/></c>
	<c path="nape.geom.GeomPolyList"/>
</f></fromVector>
		<filter public="1" set="method" line="779"><f a="lambda">
	<f a="">
		<c path="nape.geom.GeomPoly"/>
		<x path="Bool"/>
	</f>
	<c path="nape.geom.GeomPolyList"/>
</f></filter>
		<foreach public="1" get="inline" set="null" line="732"><f a="lambda">
	<f a="">
		<c path="nape.geom.GeomPoly"/>
		<x path="Void"/>
	</f>
	<c path="nape.geom.GeomPolyList"/>
</f></foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<merge public="1" set="method" line="684"><f a="xs">
	<c path="nape.geom.GeomPolyList"/>
	<x path="Void"/>
</f></merge>
		<copy public="1" set="method" line="662"><f a="?deep">
	<x path="Bool"/>
	<c path="nape.geom.GeomPolyList"/>
</f></copy>
		<iterator public="1" get="inline" set="null" line="647"><f a=""><c path="nape.geom.GeomPolyIterator"/></f></iterator>
		<empty public="1" get="inline" set="null" line="631"><f a=""><x path="Bool"/></f></empty>
		<clear public="1" set="method" line="614"><f a=""><x path="Void"/></f></clear>
		<remove public="1" set="method" line="576"><f a="obj">
	<c path="nape.geom.GeomPoly"/>
	<x path="Bool"/>
</f></remove>
		<add public="1" get="inline" set="null" line="563"><f a="obj">
	<c path="nape.geom.GeomPoly"/>
	<x path="Bool"/>
</f></add>
		<shift public="1" set="method" line="519"><f a=""><c path="nape.geom.GeomPoly"/></f></shift>
		<pop public="1" set="method" line="478"><f a=""><c path="nape.geom.GeomPoly"/></f></pop>
		<unshift public="1" set="method" line="447"><f a="obj">
	<c path="nape.geom.GeomPoly"/>
	<x path="Bool"/>
</f></unshift>
		<push public="1" set="method" line="416"><f a="obj">
	<c path="nape.geom.GeomPoly"/>
	<x path="Bool"/>
</f></push>
		<at public="1" set="method" line="363"><f a="index">
	<x path="Int"/>
	<c path="nape.geom.GeomPoly"/>
</f></at>
		<has public="1" set="method" line="346"><f a="obj">
	<c path="nape.geom.GeomPoly"/>
	<x path="Bool"/>
</f></has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="get_length" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_GeomPolyList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* Nape list of GeomPoly type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:GeomPoly = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:GeomPoly = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:GeomPoly = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.GeomVertexIterator" params="" file="libSrc/napeLib/nape/geom/GeomVertexIterator.hx">
		<next public="1" set="method" line="237"><f a=""><c path="nape.geom.Vec2"/></f></next>
		<hasNext public="1" set="method" line="200"><f a=""><x path="Bool"/></f></hasNext>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_GeomVertexIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="188">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe compatible iterator over vertices of GeomPoly.
 * <br/><br/>
 * Vec2's intrinsically tied to the vertices are exposed through
 * the iterator which does not modify the state of the polygon.]]></haxe_doc>
	</class>
	<class path="nape.geom.IsoFunction" params="" file="libSrc/napeLib/nape/geom/IsoFunction.hx" interface="1">
		<iso public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* iso-function implementation.
     * <br/><br/>
     * @param x The x-value of point.
     * @param y The y-value of point.
     * @return The value of iso-function for input point.]]></haxe_doc>
		</iso>
		<haxe_doc><![CDATA[* For 'flash' targets only.
 * <br/><br/>
 * Iso-functions for MarchingSquares must be given
 * as an object implementing this IsoFunction interface. This is for
 * reasons of avoiding excessive memory allocations that occur through
 * automatic boxing of arguments/return values when using function values.
 * <br/>
 * Since iso-functions may be called 10,000's of times per-invocation of
 * marching-squares, this can quickly accumulate into a lot of GC activity.]]></haxe_doc>
	</class>
	<typedef path="nape.geom.IsoFunctionDef" params="" file="libSrc/napeLib/nape/geom/IsoFunction.hx" module="nape.geom.IsoFunction">
		<c path="nape.geom.IsoFunction"/>
		<haxe_doc><![CDATA[* Typedef defining iso-function type for MarchingSquares.
 * <code>
 * typedef IsoFunctionDef = #if flash IsoFunction #else Float-&gt;Float-&gt;Float #end;
 * </code>]]></haxe_doc>
	</typedef>
	<class path="nape.geom.MarchingSquares" params="" file="libSrc/napeLib/nape/geom/MarchingSquares.hx">
		<run public="1" set="method" line="269" static="1">
			<f a="iso:bounds:cellsize:?quality:?subgrid:?combine:?output">
				<t path="nape.geom.IsoFunctionDef"/>
				<c path="nape.geom.AABB"/>
				<c path="nape.geom.Vec2"/>
				<x path="Int"/>
				<c path="nape.geom.Vec2"/>
				<x path="Bool"/>
				<c path="nape.geom.GeomPolyList"/>
				<c path="nape.geom.GeomPolyList"/>
			</f>
			<haxe_doc><![CDATA[* Execute marching squares algorithm over region of space.
     * <br/><br/>
     * We can, optionally provide a subgrid argument which, when non null
     * will invoke this algorithm seperately on each subgrid cell of the region
     * in space, instead of on the entire region at once. This can be very useful
     * as shown in the DestructibleTerrain demo where regions of a terrain are
     * recomputed with marching squares without needing to regenerate the whole
     * of the terrain.
     *
     * @param iso The iso-function defining the regions where polygons should
     *            be extracted, a negative return indicates a region to be extracted.
     *            This function need not be continuous, but if it is continuous
     *            then more accurate results will be given for the same input
     *            parameters.
     * @param bounds The AABB representing the region of space to be converted.
     *               The arguments to the iso-function will be in the same region.
     * @param cellsize The dimensions of each cell used individual polygon extraction.
     *                 Smaller cells will give more accurate results at a greater
     *                 cost permitting smaller features to be extracted.
     * @param quality This is the number of recursive interpolations which will be
     *                performed along cell edges. If the iso-function is not
     *                continuous, then this value should be increased to get better
     *                accuracy. (default 2)
     * @param subgrid When supplied, the region of space will be first subdivided
     *                into cells with these given dimensions, and each cell treated
     *                as a seperate invocation of this method, this value should
     *                obviously be greater than cellsize or it would be a bit
     *                pointless. (default null)
     * @param combine When True, the polygons generated in each cell of the grid
     *                will be combined into the largest possible weakly-simple
     *                polygons representing the same area. These polygons will
     *                always be suitable for decomposition in Nape. (default true)
     * @param output When supplied, GeomPoly will be inserted into the list (via add)
     *               instead of creating a new GeomPolyList object.
     * @return A list of GeomPoly representing the results of the extraction.
     * @throws # If iso, bounds or cellsize argument is null.
     * @throws # If cellsize is disposed, or its components have 0, or negative values.
     * @throws # If quality is less than 0.
     * @throws # If subgrid is not null, but is disposed or has zero or negative
     *           component values.]]></haxe_doc>
		</run>
		<haxe_doc><![CDATA[* Iso-surface extraction into polygons.
 * <br/><br/>
 * This class, with only one static method provides an interface to
 * an algorithm which will, when given a function mapping each point
 * in a given AABB to a scalar value extract approximated polygons
 * which represent the region of the AABB where the function returns
 * a negative value.
 * <br/><br/>
 * This function could be a mathematical function like the equation of
 * a circle: <code> function (x, y) return (x*x + y*y) - r*r </code>
 * <br/>
 * Or something more practical like the biased alpha value interpolated
 * from a Bitmap:
 * <pre>
 * function (x, y) {
 *    var ix = if (x < 0) 0 else if (x >= bitmap.width - 1) bitmap.width - 2 else Std.int(x);
 *    var iy = if (y < 0) 0 else if (y >= bitmap.height - 1) bitmap.height - 2 else Std.int(y);
 *    var fx = x - ix;
 *    var fy = y - iy;
 *    var gx = 1 - fx;
 *    var gy = 1 - fy;
 *
 *    var a00 = bitmap.getPixel32(ix, iy) >>> 24;
 *    var a01 = bitmap.getPixel32(ix, iy + 1) >>> 24;
 *    var a10 = bitmap.getPixel32(ix + 1, iy) >>> 24;
 *    var a11 = bitmap.getPixel32(ix + 1, iy + 1) >>> 24;
 *
 *    return 0x80 - (gx*gy*a00 + fx*gy*a10 + gx*fy*a01 + fx*fy*a11);
 * }
 * </pre>
 * For 'flash', we must wrap this in an IsoFunction interface to be used
 * by MarchingSquares for performance reasons:
 * <pre>
 * class BitmapIsoFunction implements nape.geom.IsoFunction {
 *     public function iso(x:Float, y:Float):Float {
 *         ...
 *     }
 * }
 * </pre>
 * This function is converted into a set of polygons by sampling along regular
 * grid points, and then recursively interpolating along cell edges based on
 * the function provided to find the point in space along that edge where the
 * function is approximately 0.
 * <br/><br/>
 * From this we generate polygons in each grid cell, which are then by default
 * combined into larger, weakly simply polygons suitable for use in the
 * decomposition routines of GeomPoly like convexDecomposition!
 * <br/><br/>
 * The runtime of the algorithm is O(N+K) for N number of cells and K number
 * of output vertices (A final pass is made to remove unnecessary vertices).]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.Mat23" params="" file="libSrc/napeLib/nape/geom/Mat23.hx">
		<fromMatrix public="1" set="method" line="451" static="1"><f a="matrix">
	<c path="flash.geom.Matrix"/>
	<c path="nape.geom.Mat23"/>
</f></fromMatrix>
		<rotation public="1" set="method" line="490" static="1"><f a="angle">
	<x path="Float"/>
	<c path="nape.geom.Mat23"/>
</f></rotation>
		<translation public="1" set="method" line="513" static="1"><f a="tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<c path="nape.geom.Mat23"/>
</f></translation>
		<scale public="1" set="method" line="529" static="1"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<c path="nape.geom.Mat23"/>
</f></scale>
		<orthogonalise public="1" set="method" line="862"><f a=""><c path="nape.geom.Mat23"/></f></orthogonalise>
		<equiorthogonalise public="1" set="method" line="817"><f a=""><c path="nape.geom.Mat23"/></f></equiorthogonalise>
		<orthogonal public="1" set="method" line="794"><f a=""><x path="Bool"/></f></orthogonal>
		<equiorthogonal public="1" set="method" line="766"><f a=""><x path="Bool"/></f></equiorthogonal>
		<toString public="1" set="method" line="742">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<inverseTransform public="1" set="method" line="702"><f a="point:?noTranslation:?weak">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec2"/>
</f></inverseTransform>
		<transform public="1" set="method" line="648"><f a="point:?noTranslation:?weak">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec2"/>
</f></transform>
		<concat public="1" set="method" line="622"><f a="matrix">
	<c path="nape.geom.Mat23"/>
	<c path="nape.geom.Mat23"/>
</f></concat>
		<transpose public="1" set="method" line="606"><f a=""><c path="nape.geom.Mat23"/></f></transpose>
		<inverse public="1" set="method" line="577"><f a=""><c path="nape.geom.Mat23"/></f></inverse>
		<singular public="1" set="method" line="560"><f a=""><x path="Bool"/></f></singular>
		<get_determinant get="inline" set="null" line="547"><f a=""><x path="Float"/></f></get_determinant>
		<determinant public="1" get="get_determinant" set="null"><x path="Float"/></determinant>
		<toMatrix public="1" set="method" line="467"><f a="?output">
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.Matrix"/>
</f></toMatrix>
		<reset public="1" get="inline" set="null" line="433"><f a=""><c path="nape.geom.Mat23"/></f></reset>
		<setAs public="1" set="method" line="420"><f a="?a:?b:?c:?d:?tx:?ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="nape.geom.Mat23"/>
</f></setAs>
		<set public="1" set="method" line="396"><f a="matrix">
	<c path="nape.geom.Mat23"/>
	<c path="nape.geom.Mat23"/>
</f></set>
		<copy public="1" set="method" line="386"><f a=""><c path="nape.geom.Mat23"/></f></copy>
		<set_ty get="inline" set="null" line="342"><f a="ty">
	<x path="Float"/>
	<x path="Float"/>
</f></set_ty>
		<get_ty get="inline" set="null" line="339"><f a=""><x path="Float"/></f></get_ty>
		<ty public="1" get="get_ty" set="set_ty"><x path="Float"/></ty>
		<set_tx get="inline" set="null" line="315"><f a="tx">
	<x path="Float"/>
	<x path="Float"/>
</f></set_tx>
		<get_tx get="inline" set="null" line="312"><f a=""><x path="Float"/></f></get_tx>
		<tx public="1" get="get_tx" set="set_tx"><x path="Float"/></tx>
		<set_d get="inline" set="null" line="288"><f a="d">
	<x path="Float"/>
	<x path="Float"/>
</f></set_d>
		<get_d get="inline" set="null" line="285"><f a=""><x path="Float"/></f></get_d>
		<d public="1" get="get_d" set="set_d"><x path="Float"/></d>
		<set_c get="inline" set="null" line="261"><f a="c">
	<x path="Float"/>
	<x path="Float"/>
</f></set_c>
		<get_c get="inline" set="null" line="258"><f a=""><x path="Float"/></f></get_c>
		<c public="1" get="get_c" set="set_c"><x path="Float"/></c>
		<set_b get="inline" set="null" line="234"><f a="b">
	<x path="Float"/>
	<x path="Float"/>
</f></set_b>
		<get_b get="inline" set="null" line="231"><f a=""><x path="Float"/></f></get_b>
		<b public="1" get="get_b" set="set_b"><x path="Float"/></b>
		<set_a get="inline" set="null" line="207"><f a="a">
	<x path="Float"/>
	<x path="Float"/>
</f></set_a>
		<get_a get="inline" set="null" line="204"><f a=""><x path="Float"/></f></get_a>
		<a public="1" get="get_a" set="set_a">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The (1,1) entry in Mat23:
     * <br/><br/>
     * <pre>
     * [ a  .  . ]
     * [ .  .  . ]
     * </pre>
     *
     * @default 1]]></haxe_doc>
		</a>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_Mat23"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="370"><f a="?a:?b:?c:?d:?tx:?ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* 2D Matrix class representing affine transformations:
 * <pre>
 * [ a  b  tx ]
 * [ c  d  ty ]
 * [ 0  0  1  ]
 * </pre>
 *
 * Note that in AS3, flash.geom.Matrix has 'b' and 'c' swapped! so if you are
 * converting between flash.geom.Matrix and nape.geom.Mat23 you should use the
 * methods provided to avoid any mistakes with this.
 *]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.MatMN" params="" file="libSrc/napeLib/nape/geom/MatMN.hx">
		<mul public="1" set="method" line="294"><f a="matrix">
	<c path="nape.geom.MatMN"/>
	<c path="nape.geom.MatMN"/>
</f></mul>
		<transpose public="1" set="method" line="274"><f a=""><c path="nape.geom.MatMN"/></f></transpose>
		<toString public="1" set="method" line="258">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<setx public="1" get="inline" set="null" line="228"><f a="row:col:x">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></setx>
		<x public="1" get="inline" set="null" line="209"><f a="row:col">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></x>
		<get_cols get="inline" set="null" line="197"><f a=""><x path="Int"/></f></get_cols>
		<cols public="1" get="get_cols" set="null"><x path="Int"/></cols>
		<get_rows get="inline" set="null" line="189"><f a=""><x path="Int"/></f></get_rows>
		<rows public="1" get="get_rows" set="null">
			<x path="Int"/>
			<haxe_doc>* The number of rows in the matrix.</haxe_doc>
		</rows>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_MatMN"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="246"><f a="rows:cols">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* A general MxN dimensional matrix.
 * <br/><br/>
 * This object is not often used in Nape :)]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.Ray" params="" file="libSrc/napeLib/nape/geom/Ray.hx">
		<fromSegment public="1" set="method" line="370" static="1"><f a="start:end">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Ray"/>
</f></fromSegment>
		<copy public="1" set="method" line="350"><f a=""><c path="nape.geom.Ray"/></f></copy>
		<at public="1" set="method" line="313"><f a="distance:?weak">
	<x path="Float"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec2"/>
</f></at>
		<aabb public="1" set="method" line="295"><f a=""><c path="nape.geom.AABB"/></f></aabb>
		<set_maxDistance get="inline" set="null" line="275"><f a="maxDistance">
	<x path="Float"/>
	<x path="Float"/>
</f></set_maxDistance>
		<get_maxDistance get="inline" set="null" line="272"><f a=""><x path="Float"/></f></get_maxDistance>
		<maxDistance public="1" get="get_maxDistance" set="set_maxDistance"><x path="Float"/></maxDistance>
		<set_direction get="inline" set="null" line="242"><f a="direction">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_direction>
		<get_direction get="inline" set="null" line="239"><f a=""><c path="nape.geom.Vec2"/></f></get_direction>
		<direction public="1" get="get_direction" set="set_direction"><c path="nape.geom.Vec2"/></direction>
		<set_origin get="inline" set="null" line="212"><f a="origin">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_origin>
		<get_origin get="inline" set="null" line="209"><f a=""><c path="nape.geom.Vec2"/></f></get_origin>
		<origin public="1" get="get_origin" set="set_origin"><c path="nape.geom.Vec2"/></origin>
		<get_userData get="inline" set="null" line="195"><f a=""><d><d/></d></f></get_userData>
		<userData public="1" get="get_userData" set="null">
			<d><d/></d>
			<haxe_doc><![CDATA[* Dynamic object for user to store additional data.
     * <br/><br/>
     * This object cannot be set, only its dynamically created
     * properties may be set. In AS3 the type of this property is &#42
     * <br/><br/>
     * This object will be lazily constructed so that until accessed
     * for the first time, will be null internally.
     *
     * @default {}]]></haxe_doc>
		</userData>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_Ray"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="327"><f a="origin:direction">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Parametrically defined ray used in ray casting functions.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.RayResult" params="" file="libSrc/napeLib/nape/geom/RayResult.hx">
		<toString public="1" set="method" line="252">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<dispose public="1" get="inline" set="null" line="243"><f a=""><x path="Void"/></f></dispose>
		<get_shape get="inline" set="null" line="223"><f a=""><c path="nape.shape.Shape"/></f></get_shape>
		<shape public="1" get="get_shape" set="null"><c path="nape.shape.Shape"/></shape>
		<get_inner get="inline" set="null" line="212"><f a=""><x path="Bool"/></f></get_inner>
		<inner public="1" get="get_inner" set="null"><x path="Bool"/></inner>
		<get_distance get="inline" set="null" line="201"><f a=""><x path="Float"/></f></get_distance>
		<distance public="1" get="get_distance" set="null"><x path="Float"/></distance>
		<get_normal get="inline" set="null" line="190"><f a=""><c path="nape.geom.Vec2"/></f></get_normal>
		<normal public="1" get="get_normal" set="null">
			<c path="nape.geom.Vec2"/>
			<haxe_doc>* The normal of the surface at intersection.</haxe_doc>
		</normal>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_ConvexRayResult"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="234"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* Class representing the results of a ray cast operation.
 * <br/><br/>
 * These objects are allocated from an object pool and can
 * be released back to that pool by calling its dispose method.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.RayResultIterator" params="" file="libSrc/napeLib/nape/geom/RayResultIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.geom.RayResultIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1"><f a="list">
	<c path="nape.geom.RayResultList"/>
	<c path="nape.geom.RayResultIterator"/>
</f></get>
		<next public="1" get="inline" set="null" line="264"><f a=""><c path="nape.geom.RayResult"/></f></next>
		<hasNext public="1" get="inline" set="null" line="240"><f a=""><x path="Bool"/></f></hasNext>
		<zpp_next public="1">
			<c path="nape.geom.RayResultIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.geom.RayResultList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.RayResultList" params="" file="libSrc/napeLib/nape/geom/RayResultList.hx">
		<fromArray public="1" set="method" line="304" static="1"><f a="array">
	<c path="Array"><c path="nape.geom.RayResult"/></c>
	<c path="nape.geom.RayResultList"/>
</f></fromArray>
		<fromVector public="1" set="method" line="328" static="1"><f a="vector">
	<c path="flash.Vector"><c path="nape.geom.RayResult"/></c>
	<c path="nape.geom.RayResultList"/>
</f></fromVector>
		<filter public="1" set="method" line="779"><f a="lambda">
	<f a="">
		<c path="nape.geom.RayResult"/>
		<x path="Bool"/>
	</f>
	<c path="nape.geom.RayResultList"/>
</f></filter>
		<foreach public="1" get="inline" set="null" line="732"><f a="lambda">
	<f a="">
		<c path="nape.geom.RayResult"/>
		<x path="Void"/>
	</f>
	<c path="nape.geom.RayResultList"/>
</f></foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<merge public="1" set="method" line="684"><f a="xs">
	<c path="nape.geom.RayResultList"/>
	<x path="Void"/>
</f></merge>
		<copy public="1" set="method" line="662"><f a="?deep">
	<x path="Bool"/>
	<c path="nape.geom.RayResultList"/>
</f></copy>
		<iterator public="1" get="inline" set="null" line="647"><f a=""><c path="nape.geom.RayResultIterator"/></f></iterator>
		<empty public="1" get="inline" set="null" line="631"><f a=""><x path="Bool"/></f></empty>
		<clear public="1" set="method" line="614"><f a=""><x path="Void"/></f></clear>
		<remove public="1" set="method" line="576"><f a="obj">
	<c path="nape.geom.RayResult"/>
	<x path="Bool"/>
</f></remove>
		<add public="1" get="inline" set="null" line="563"><f a="obj">
	<c path="nape.geom.RayResult"/>
	<x path="Bool"/>
</f></add>
		<shift public="1" set="method" line="519"><f a=""><c path="nape.geom.RayResult"/></f></shift>
		<pop public="1" set="method" line="478"><f a=""><c path="nape.geom.RayResult"/></f></pop>
		<unshift public="1" set="method" line="447"><f a="obj">
	<c path="nape.geom.RayResult"/>
	<x path="Bool"/>
</f></unshift>
		<push public="1" set="method" line="416"><f a="obj">
	<c path="nape.geom.RayResult"/>
	<x path="Bool"/>
</f></push>
		<at public="1" set="method" line="363"><f a="index">
	<x path="Int"/>
	<c path="nape.geom.RayResult"/>
</f></at>
		<has public="1" set="method" line="346"><f a="obj">
	<c path="nape.geom.RayResult"/>
	<x path="Bool"/>
</f></has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="get_length" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_RayResultList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* Nape list of RayResult type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:RayResult = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:RayResult = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:RayResult = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.Vec2" params="" file="libSrc/napeLib/nape/geom/Vec2.hx">
		<weak public="1" get="inline" set="null" line="256" static="1">
			<f a="?x:?y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="nape.geom.Vec2"/>
			</f>
			<haxe_doc><![CDATA[* Allocate a weak Vec2 from global object pool.
     * <br/><br/>
     * This object which will be automaticaly released back to the object pool
     * when supplied as an argument to a Nape function.
     * <br/><br/>
     * Note that <code>Vec2.weak(x, y)</code> is exactly equivalent to <code>
     * Vec2.get(x, y, true)</code>.
     *
     * @param x The x coordinate for the vector. (default 0)
     * @param y The y coordiante for the vector. (default 0)
     * @return  The allocated weak Vec2 with given x/y values.]]></haxe_doc>
		</weak>
		<get public="1" get="inline" set="null" line="273" static="1"><f a="?x:?y:?weak">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec2"/>
</f></get>
		<fromPoint public="1" set="method" line="452" static="1"><f a="point:?weak">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec2"/>
</f></fromPoint>
		<fromPolar public="1" set="method" line="505" static="1"><f a="length:angle:?weak">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec2"/>
</f></fromPolar>
		<dsq public="1" get="inline" set="null" line="711" static="1"><f a="a:b">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
</f></dsq>
		<distance public="1" get="inline" set="null" line="759" static="1"><f a="a:b">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
</f></distance>
		<toString public="1" set="method" line="1481">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<perp public="1" set="method" line="1470"><f a="?weak">
	<x path="Bool"/>
	<c path="nape.geom.Vec2"/>
</f></perp>
		<cross public="1" set="method" line="1419"><f a="vector">
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
</f></cross>
		<dot public="1" set="method" line="1359"><f a="vector">
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
</f></dot>
		<muleq public="1" set="method" line="1328"><f a="scalar">
	<x path="Float"/>
	<c path="nape.geom.Vec2"/>
</f></muleq>
		<subeq public="1" set="method" line="1283"><f a="vector">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></subeq>
		<addeq public="1" set="method" line="1237"><f a="vector">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></addeq>
		<mul public="1" set="method" line="1209"><f a="scalar:?weak">
	<x path="Float"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec2"/>
</f></mul>
		<sub public="1" set="method" line="1165"><f a="vector:?weak">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec2"/>
</f></sub>
		<addMul public="1" set="method" line="1119"><f a="vector:scalar:?weak">
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec2"/>
</f></addMul>
		<add public="1" set="method" line="1066"><f a="vector:?weak">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec2"/>
</f></add>
		<unit public="1" set="method" line="1035"><f a="?weak">
	<x path="Bool"/>
	<c path="nape.geom.Vec2"/>
</f></unit>
		<normalise public="1" set="method" line="984"><f a=""><c path="nape.geom.Vec2"/></f></normalise>
		<reflect public="1" set="method" line="942"><f a="vec:?weak">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec2"/>
</f></reflect>
		<rotate public="1" set="method" line="907"><f a="angle">
	<x path="Float"/>
	<c path="nape.geom.Vec2"/>
</f></rotate>
		<set_angle get="inline" set="null" line="874"><f a="angle">
	<x path="Float"/>
	<x path="Float"/>
</f></set_angle>
		<get_angle get="inline" set="null" line="861"><f a=""><x path="Float"/></f></get_angle>
		<angle public="1" get="get_angle" set="set_angle"><x path="Float"/></angle>
		<setxy public="1" get="inline" set="null" line="808"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="nape.geom.Vec2"/>
</f></setxy>
		<set public="1" get="inline" set="null" line="671"><f a="vector">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set>
		<lsq public="1" set="method" line="650"><f a=""><x path="Float"/></f></lsq>
		<set_length get="inline" set="null" line="607"><f a="length">
	<x path="Float"/>
	<x path="Float"/>
</f></set_length>
		<get_length get="inline" set="null" line="599"><f a=""><x path="Float"/></f></get_length>
		<length public="1" get="get_length" set="set_length"><x path="Float"/></length>
		<set_y get="inline" set="null" line="568"><f a="y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<get_y get="inline" set="null" line="559"><f a=""><x path="Float"/></f></get_y>
		<y public="1" get="get_y" set="set_y"><x path="Float"/></y>
		<set_x get="inline" set="null" line="532"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<get_x get="inline" set="null" line="523"><f a=""><x path="Float"/></f></get_x>
		<x public="1" get="get_x" set="set_x"><x path="Float"/></x>
		<toPoint public="1" set="method" line="475"><f a="?output">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></toPoint>
		<copy public="1" get="inline" set="null" line="425"><f a="?weak">
	<x path="Bool"/>
	<c path="nape.geom.Vec2"/>
</f></copy>
		<dispose public="1" get="inline" set="null" line="328"><f a=""><x path="Void"/></f></dispose>
		<zpp_disp public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_disp>
		<zpp_pool public="1">
			<c path="nape.geom.Vec2"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_Vec2"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="400"><f a="?x:?y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* 2 Dimensional vector.
 * <br/><br/>
 * Note that in many cases of a Vec2 object being returned by a Nape function
 * the Vec2 object will be marked internally as an 'immutable' Vec2. This will
 * always be documented and trying to mutate such a Vec2 will result in an
 * error being thrown.
 * <br/><br/>
 * Vec2 objects can make use of a global object pool, attempting to make use
 * of a disposed Vec2 will also result in an error with the object pool
 * working in a FILO order to increase the likelihood of such misuse being
 * caught.
 * <br/><br/>
 * Additionally Vec2 objects can be created as 'weak'. Passing a weak Vec2 to
 * any Nape function as an argument will result in the automatic disposal of
 * the Vec2 once the method has finished with it. There may be exceptions to
 * this rule which will also be documented; a notable case being the appending
 * of a weak Vec2 to a Nape Vec2List in which case the disposal of the weak
 * Vec2 is performed when that Vec2List is handed to a Nape function instead.
 * <br/><br/>
 * Example:
 * <pre>
 * var vertices = Polygon.box(20, 20, true);
 * var polygon = new Polygon(vertices);
 * </pre>
 * In this example, passing <code>true</code> to the Polygon.box method means
 * that we will be returned a Vec2List containing only 'weak' Vec2s. Upon
 * passing this Vec2List to the Polygon constructor, all of the Vec2s from
 * that list will be automatically disposed.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.Vec2Iterator" params="" file="libSrc/napeLib/nape/geom/Vec2Iterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.geom.Vec2Iterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1"><f a="list">
	<c path="nape.geom.Vec2List"/>
	<c path="nape.geom.Vec2Iterator"/>
</f></get>
		<next public="1" get="inline" set="null" line="264"><f a=""><c path="nape.geom.Vec2"/></f></next>
		<hasNext public="1" get="inline" set="null" line="240"><f a=""><x path="Bool"/></f></hasNext>
		<zpp_next public="1">
			<c path="nape.geom.Vec2Iterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.geom.Vec2List"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.Vec2List" params="" file="libSrc/napeLib/nape/geom/Vec2List.hx">
		<fromArray public="1" set="method" line="304" static="1"><f a="array">
	<c path="Array"><c path="nape.geom.Vec2"/></c>
	<c path="nape.geom.Vec2List"/>
</f></fromArray>
		<fromVector public="1" set="method" line="328" static="1"><f a="vector">
	<c path="flash.Vector"><c path="nape.geom.Vec2"/></c>
	<c path="nape.geom.Vec2List"/>
</f></fromVector>
		<filter public="1" set="method" line="773"><f a="lambda">
	<f a="">
		<c path="nape.geom.Vec2"/>
		<x path="Bool"/>
	</f>
	<c path="nape.geom.Vec2List"/>
</f></filter>
		<foreach public="1" set="method" line="726"><f a="lambda">
	<f a="">
		<c path="nape.geom.Vec2"/>
		<x path="Void"/>
	</f>
	<c path="nape.geom.Vec2List"/>
</f></foreach>
		<toString public="1" set="method" line="696">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<merge public="1" set="method" line="678"><f a="xs">
	<c path="nape.geom.Vec2List"/>
	<x path="Void"/>
</f></merge>
		<copy public="1" set="method" line="662"><f a="?deep">
	<x path="Bool"/>
	<c path="nape.geom.Vec2List"/>
</f></copy>
		<iterator public="1" set="method" line="647"><f a=""><c path="nape.geom.Vec2Iterator"/></f></iterator>
		<empty public="1" set="method" line="631"><f a=""><x path="Bool"/></f></empty>
		<clear public="1" set="method" line="614"><f a=""><x path="Void"/></f></clear>
		<remove public="1" set="method" line="576"><f a="obj">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
</f></remove>
		<add public="1" set="method" line="563"><f a="obj">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
</f></add>
		<shift public="1" set="method" line="519"><f a=""><c path="nape.geom.Vec2"/></f></shift>
		<pop public="1" set="method" line="478"><f a=""><c path="nape.geom.Vec2"/></f></pop>
		<unshift public="1" set="method" line="447"><f a="obj">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
</f></unshift>
		<push public="1" set="method" line="416"><f a="obj">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
</f></push>
		<at public="1" set="method" line="363"><f a="index">
	<x path="Int"/>
	<c path="nape.geom.Vec2"/>
</f></at>
		<has public="1" set="method" line="346"><f a="obj">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
</f></has>
		<zpp_vm public="1" set="method" line="291"><f a=""><x path="Void"/></f></zpp_vm>
		<zpp_gl public="1" set="method" line="269"><f a=""><x path="Int"/></f></zpp_gl>
		<get_length get="inline" set="null" line="263"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="get_length" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_Vec2List"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="689"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* Nape list of Vec2 type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Vec2 = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Vec2 = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Vec2 = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
	</class>
	<class path="nape.geom.Vec3" params="" file="libSrc/napeLib/nape/geom/Vec3.hx">
		<get public="1" set="method" line="322" static="1"><f a="?x:?y:?z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="nape.geom.Vec3"/>
</f></get>
		<toString public="1" set="method" line="608">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<xy public="1" set="method" line="597"><f a="?weak">
	<x path="Bool"/>
	<c path="nape.geom.Vec2"/>
</f></xy>
		<setxyz public="1" set="method" line="552"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="nape.geom.Vec3"/>
</f></setxyz>
		<set public="1" set="method" line="524"><f a="vector">
	<c path="nape.geom.Vec3"/>
	<c path="nape.geom.Vec3"/>
</f></set>
		<lsq public="1" set="method" line="507"><f a=""><x path="Float"/></f></lsq>
		<set_length get="inline" set="null" line="465"><f a="length">
	<x path="Float"/>
	<x path="Float"/>
</f></set_length>
		<get_length get="inline" set="null" line="457"><f a=""><x path="Float"/></f></get_length>
		<length public="1" get="get_length" set="set_length"><x path="Float"/></length>
		<dispose public="1" set="method" line="406"><f a=""><x path="Void"/></f></dispose>
		<set_z get="inline" set="null" line="296"><f a="z">
	<x path="Float"/>
	<x path="Float"/>
</f></set_z>
		<get_z get="inline" set="null" line="287"><f a=""><x path="Float"/></f></get_z>
		<z public="1" get="get_z" set="set_z"><x path="Float"/></z>
		<set_y get="inline" set="null" line="265"><f a="y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<get_y get="inline" set="null" line="256"><f a=""><x path="Float"/></f></get_y>
		<y public="1" get="get_y" set="set_y"><x path="Float"/></y>
		<set_x get="inline" set="null" line="234"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<get_x get="inline" set="null" line="225"><f a=""><x path="Float"/></f></get_x>
		<x public="1" get="get_x" set="set_x">
			<x path="Float"/>
			<haxe_doc>* The x component of Vec3.
     * @default 0</haxe_doc>
		</x>
		<zpp_disp public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_disp>
		<zpp_pool public="1">
			<c path="nape.geom.Vec3"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<zpp_inner public="1">
			<c path="zpp_nape.geom.ZPP_Vec3"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="360"><f a="?x:?y:?z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* A 3 dimensional vector object.
 * <br/><br/>
 * In many instances a Vec3 will be accessible from Nape which is marked
 * as immutable, these cases will be documented and modifying such a Vec3
 * will result in an error.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.geom.Winding" params="" file="libSrc/napeLib/nape/geom/Winding.hx">
		<UNDEFINED public="1" get="get_UNDEFINED" set="null" static="1"><c path="nape.geom.Winding"/></UNDEFINED>
		<get_UNDEFINED get="inline" set="null" line="213" static="1"><f a=""><c path="nape.geom.Winding"/></f></get_UNDEFINED>
		<CLOCKWISE public="1" get="get_CLOCKWISE" set="null" static="1"><c path="nape.geom.Winding"/></CLOCKWISE>
		<get_CLOCKWISE get="inline" set="null" line="226" static="1"><f a=""><c path="nape.geom.Winding"/></f></get_CLOCKWISE>
		<ANTICLOCKWISE public="1" get="get_ANTICLOCKWISE" set="null" static="1"><c path="nape.geom.Winding"/></ANTICLOCKWISE>
		<get_ANTICLOCKWISE get="inline" set="null" line="239" static="1"><f a=""><c path="nape.geom.Winding"/></f></get_ANTICLOCKWISE>
		<toString public="1" set="method" line="196">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="188">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Enumeration represents the winding of a Polygon.
 * <br/><br/>
 * To appreciate what the winding of a polygon means, think of a polygon who's
 * vertices are the numbers on a clock face.
 *
 * If the vertices are ordered <code>12 -&gt; 1 -&gt; 2 ... -&gt; 12</code>
 * then this polygon is clockwise wound. The reverse order would mean the
 * polygon is wound anticlockwise.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.Interactor" params="" file="libSrc/napeLib/nape/phys/Interactor.hx">
		<toString public="1" set="method" line="293">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<get_cbTypes get="inline" set="null" line="278"><f a=""><c path="nape.callbacks.CbTypeList"/></f></get_cbTypes>
		<cbTypes public="1" get="get_cbTypes" set="null"><c path="nape.callbacks.CbTypeList"/></cbTypes>
		<set_group get="inline" set="null" line="264"><f a="group">
	<t path="Null"><c path="nape.dynamics.InteractionGroup"/></t>
	<t path="Null"><c path="nape.dynamics.InteractionGroup"/></t>
</f></set_group>
		<get_group get="inline" set="null" line="261"><f a=""><t path="Null"><c path="nape.dynamics.InteractionGroup"/></t></f></get_group>
		<group public="1" get="get_group" set="set_group"><t path="Null"><c path="nape.dynamics.InteractionGroup"/></t></group>
		<get_castCompound get="inline" set="null" line="251"><f a=""><t path="Null"><c path="nape.phys.Compound"/></t></f></get_castCompound>
		<castCompound public="1" get="get_castCompound" set="null"><t path="Null"><c path="nape.phys.Compound"/></t></castCompound>
		<get_castBody get="inline" set="null" line="243"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_castBody>
		<castBody public="1" get="get_castBody" set="null"><t path="Null"><c path="nape.phys.Body"/></t></castBody>
		<get_castShape get="inline" set="null" line="235"><f a=""><t path="Null"><c path="nape.shape.Shape"/></t></f></get_castShape>
		<castShape public="1" get="get_castShape" set="null"><t path="Null"><c path="nape.shape.Shape"/></t></castShape>
		<isCompound public="1" get="inline" set="null" line="227"><f a=""><x path="Bool"/></f></isCompound>
		<isBody public="1" get="inline" set="null" line="219"><f a=""><x path="Bool"/></f></isBody>
		<isShape public="1" get="inline" set="null" line="211"><f a=""><x path="Bool"/></f></isShape>
		<get_userData get="inline" set="null" line="200"><f a=""><d><d/></d></f></get_userData>
		<userData public="1" get="get_userData" set="null"><d><d/></d></userData>
		<get_id get="inline" set="null" line="184"><f a=""><x path="Int"/></f></get_id>
		<id public="1" get="get_id" set="null">
			<x path="Int"/>
			<haxe_doc>* Unique id of this Interactor.</haxe_doc>
		</id>
		<zpp_inner_i public="1">
			<c path="zpp_nape.phys.ZPP_Interactor"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_i>
		<new public="1" set="method" line="285"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="nape.phys.Body" params="" file="libSrc/napeLib/nape/phys/Body.hx">
		<extends path="nape.phys.Interactor"/>
		<toString public="1" set="method" line="2537" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<contains public="1" set="method" line="2492"><f a="point">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
</f></contains>
		<totalImpulse public="1" set="method" line="2407"><f a="?body:?freshOnly">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec3"/>
</f></totalImpulse>
		<constraintsImpulse public="1" set="method" line="2341"><f a=""><c path="nape.geom.Vec3"/></f></constraintsImpulse>
		<totalFluidImpulse public="1" set="method" line="2284"><f a="?body">
	<c path="nape.phys.Body"/>
	<c path="nape.geom.Vec3"/>
</f></totalFluidImpulse>
		<dragImpulse public="1" set="method" line="2222"><f a="?body">
	<c path="nape.phys.Body"/>
	<c path="nape.geom.Vec3"/>
</f></dragImpulse>
		<buoyancyImpulse public="1" set="method" line="2160"><f a="?body">
	<c path="nape.phys.Body"/>
	<c path="nape.geom.Vec3"/>
</f></buoyancyImpulse>
		<rollingImpulse public="1" set="method" line="2134"><f a="?body:?freshOnly">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rollingImpulse>
		<totalContactsImpulse public="1" set="method" line="2070"><f a="?body:?freshOnly">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec3"/>
</f></totalContactsImpulse>
		<tangentImpulse public="1" set="method" line="2006"><f a="?body:?freshOnly">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec3"/>
</f></tangentImpulse>
		<normalImpulse public="1" set="method" line="1942"><f a="?body:?freshOnly">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec3"/>
</f></normalImpulse>
		<get_worldCOM get="inline" set="null" line="1917"><f a=""><c path="nape.geom.Vec2"/></f></get_worldCOM>
		<worldCOM public="1" get="get_worldCOM" set="null"><c path="nape.geom.Vec2"/></worldCOM>
		<get_localCOM get="inline" set="null" line="1895"><f a=""><c path="nape.geom.Vec2"/></f></get_localCOM>
		<localCOM public="1" get="get_localCOM" set="null"><c path="nape.geom.Vec2"/></localCOM>
		<setShapeFluidProperties public="1" set="method" line="1870"><f a="fluidProperties">
	<c path="nape.phys.FluidProperties"/>
	<c path="nape.phys.Body"/>
</f></setShapeFluidProperties>
		<setShapeFilters public="1" set="method" line="1846"><f a="filter">
	<c path="nape.dynamics.InteractionFilter"/>
	<c path="nape.phys.Body"/>
</f></setShapeFilters>
		<setShapeMaterials public="1" set="method" line="1822"><f a="material">
	<c path="nape.phys.Material"/>
	<c path="nape.phys.Body"/>
</f></setShapeMaterials>
		<rotate public="1" set="method" line="1780"><f a="centre:angle">
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<c path="nape.phys.Body"/>
</f></rotate>
		<align public="1" set="method" line="1737"><f a=""><c path="nape.phys.Body"/></f></align>
		<transformShapes public="1" set="method" line="1706"><f a="matrix">
	<c path="nape.geom.Mat23"/>
	<c path="nape.phys.Body"/>
</f></transformShapes>
		<scaleShapes public="1" set="method" line="1677"><f a="scaleX:scaleY">
	<x path="Float"/>
	<x path="Float"/>
	<c path="nape.phys.Body"/>
</f></scaleShapes>
		<rotateShapes public="1" set="method" line="1649"><f a="angle">
	<x path="Float"/>
	<c path="nape.phys.Body"/>
</f></rotateShapes>
		<translateShapes public="1" set="method" line="1601"><f a="translation">
	<c path="nape.geom.Vec2"/>
	<c path="nape.phys.Body"/>
</f></translateShapes>
		<applyAngularImpulse public="1" set="method" line="1575"><f a="impulse:?sleepable">
	<x path="Float"/>
	<x path="Bool"/>
	<c path="nape.phys.Body"/>
</f></applyAngularImpulse>
		<applyImpulse public="1" set="method" line="1479"><f a="impulse:?pos:?sleepable">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
	<c path="nape.phys.Body"/>
</f></applyImpulse>
		<worldVectorToLocal public="1" set="method" line="1429"><f a="vector:?weak">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec2"/>
</f></worldVectorToLocal>
		<localVectorToWorld public="1" set="method" line="1388"><f a="vector:?weak">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec2"/>
</f></localVectorToWorld>
		<worldPointToLocal public="1" set="method" line="1341"><f a="point:?weak">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec2"/>
</f></worldPointToLocal>
		<localPointToWorld public="1" set="method" line="1301"><f a="point:?weak">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec2"/>
</f></localPointToWorld>
		<crushFactor public="1" set="method" line="1264"><f a=""><x path="Float"/></f></crushFactor>
		<interactingBodies public="1" set="method" line="1242"><f a="?type:?depth:?output">
	<c path="nape.callbacks.InteractionType"/>
	<x path="Int"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></interactingBodies>
		<connectedBodies public="1" set="method" line="1224"><f a="?depth:?output">
	<x path="Int"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></connectedBodies>
		<set_inertia get="inline" set="null" line="1190"><f a="inertia">
	<x path="Float"/>
	<x path="Float"/>
</f></set_inertia>
		<get_inertia get="inline" set="null" line="1180"><f a=""><x path="Float"/></f></get_inertia>
		<inertia public="1" get="get_inertia" set="set_inertia"><x path="Float"/></inertia>
		<get_constraintInertia get="inline" set="null" line="1169"><f a=""><x path="Float"/></f></get_constraintInertia>
		<constraintInertia public="1" get="get_constraintInertia" set="null"><x path="Float"/></constraintInertia>
		<set_inertiaMode get="inline" set="null" line="1146"><f a="inertiaMode">
	<c path="nape.phys.InertiaMode"/>
	<c path="nape.phys.InertiaMode"/>
</f></set_inertiaMode>
		<get_inertiaMode get="inline" set="null" line="1143"><f a=""><c path="nape.phys.InertiaMode"/></f></get_inertiaMode>
		<inertiaMode public="1" get="get_inertiaMode" set="set_inertiaMode"><c path="nape.phys.InertiaMode"/></inertiaMode>
		<set_gravMassScale get="inline" set="null" line="1119"><f a="gravMassScale">
	<x path="Float"/>
	<x path="Float"/>
</f></set_gravMassScale>
		<get_gravMassScale get="inline" set="null" line="1110"><f a=""><x path="Float"/></f></get_gravMassScale>
		<gravMassScale public="1" get="get_gravMassScale" set="set_gravMassScale"><x path="Float"/></gravMassScale>
		<set_gravMass get="inline" set="null" line="1085"><f a="gravMass">
	<x path="Float"/>
	<x path="Float"/>
</f></set_gravMass>
		<get_gravMass get="inline" set="null" line="1073"><f a=""><x path="Float"/></f></get_gravMass>
		<gravMass public="1" get="get_gravMass" set="set_gravMass"><x path="Float"/></gravMass>
		<set_gravMassMode get="inline" set="null" line="1050"><f a="gravMassMode">
	<c path="nape.phys.GravMassMode"/>
	<c path="nape.phys.GravMassMode"/>
</f></set_gravMassMode>
		<get_gravMassMode get="inline" set="null" line="1047"><f a=""><c path="nape.phys.GravMassMode"/></f></get_gravMassMode>
		<gravMassMode public="1" get="get_gravMassMode" set="set_gravMassMode"><c path="nape.phys.GravMassMode"/></gravMassMode>
		<set_mass get="inline" set="null" line="1021"><f a="mass">
	<x path="Float"/>
	<x path="Float"/>
</f></set_mass>
		<get_mass get="inline" set="null" line="1011"><f a=""><x path="Float"/></f></get_mass>
		<mass public="1" get="get_mass" set="set_mass"><x path="Float"/></mass>
		<get_constraintMass get="inline" set="null" line="993"><f a=""><x path="Float"/></f></get_constraintMass>
		<constraintMass public="1" get="get_constraintMass" set="null"><x path="Float"/></constraintMass>
		<set_massMode get="inline" set="null" line="970"><f a="massMode">
	<c path="nape.phys.MassMode"/>
	<c path="nape.phys.MassMode"/>
</f></set_massMode>
		<get_massMode get="inline" set="null" line="967"><f a=""><c path="nape.phys.MassMode"/></f></get_massMode>
		<massMode public="1" get="get_massMode" set="set_massMode"><c path="nape.phys.MassMode"/></massMode>
		<set_allowRotation get="inline" set="null" line="946"><f a="allowRotation">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_allowRotation>
		<get_allowRotation get="inline" set="null" line="943"><f a=""><x path="Bool"/></f></get_allowRotation>
		<allowRotation public="1" get="get_allowRotation" set="set_allowRotation"><x path="Bool"/></allowRotation>
		<set_allowMovement get="inline" set="null" line="922"><f a="allowMovement">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_allowMovement>
		<get_allowMovement get="inline" set="null" line="919"><f a=""><x path="Bool"/></f></get_allowMovement>
		<allowMovement public="1" get="get_allowMovement" set="set_allowMovement"><x path="Bool"/></allowMovement>
		<get_bounds get="inline" set="null" line="902"><f a=""><c path="nape.geom.AABB"/></f></get_bounds>
		<bounds public="1" get="get_bounds" set="null"><c path="nape.geom.AABB"/></bounds>
		<set_torque get="inline" set="null" line="873"><f a="torque">
	<x path="Float"/>
	<x path="Float"/>
</f></set_torque>
		<get_torque get="inline" set="null" line="870"><f a=""><x path="Float"/></f></get_torque>
		<torque public="1" get="get_torque" set="set_torque"><x path="Float"/></torque>
		<set_kinAngVel get="inline" set="null" line="844"><f a="kinAngVel">
	<x path="Float"/>
	<x path="Float"/>
</f></set_kinAngVel>
		<get_kinAngVel get="inline" set="null" line="841"><f a=""><x path="Float"/></f></get_kinAngVel>
		<kinAngVel public="1" get="get_kinAngVel" set="set_kinAngVel"><x path="Float"/></kinAngVel>
		<set_angularVel get="inline" set="null" line="809"><f a="angularVel">
	<x path="Float"/>
	<x path="Float"/>
</f></set_angularVel>
		<get_angularVel get="inline" set="null" line="806"><f a=""><x path="Float"/></f></get_angularVel>
		<angularVel public="1" get="get_angularVel" set="set_angularVel"><x path="Float"/></angularVel>
		<set_rotation get="inline" set="null" line="777"><f a="rotation">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotation>
		<get_rotation get="inline" set="null" line="774"><f a=""><x path="Float"/></f></get_rotation>
		<rotation public="1" get="get_rotation" set="set_rotation"><x path="Float"/></rotation>
		<get_constraintVelocity get="inline" set="null" line="756"><f a=""><c path="nape.geom.Vec3"/></f></get_constraintVelocity>
		<constraintVelocity public="1" get="get_constraintVelocity" set="null"><c path="nape.geom.Vec3"/></constraintVelocity>
		<set_force get="inline" set="null" line="734"><f a="force">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_force>
		<get_force get="inline" set="null" line="730"><f a=""><c path="nape.geom.Vec2"/></f></get_force>
		<force public="1" get="get_force" set="set_force"><c path="nape.geom.Vec2"/></force>
		<set_surfaceVel get="inline" set="null" line="705"><f a="surfaceVel">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_surfaceVel>
		<get_surfaceVel get="inline" set="null" line="701"><f a=""><c path="nape.geom.Vec2"/></f></get_surfaceVel>
		<surfaceVel public="1" get="get_surfaceVel" set="set_surfaceVel"><c path="nape.geom.Vec2"/></surfaceVel>
		<set_kinematicVel get="inline" set="null" line="673"><f a="kinematicVel">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_kinematicVel>
		<get_kinematicVel get="inline" set="null" line="669"><f a=""><c path="nape.geom.Vec2"/></f></get_kinematicVel>
		<kinematicVel public="1" get="get_kinematicVel" set="set_kinematicVel"><c path="nape.geom.Vec2"/></kinematicVel>
		<setVelocityFromTarget public="1" set="method" line="629"><f a="targetPosition:targetRotation:deltaTime">
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="nape.phys.Body"/>
</f></setVelocityFromTarget>
		<set_velocity get="inline" set="null" line="598"><f a="velocity">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_velocity>
		<get_velocity get="inline" set="null" line="594"><f a=""><c path="nape.geom.Vec2"/></f></get_velocity>
		<velocity public="1" get="get_velocity" set="set_velocity"><c path="nape.geom.Vec2"/></velocity>
		<set_position get="inline" set="null" line="569"><f a="position">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_position>
		<get_position get="inline" set="null" line="565"><f a=""><c path="nape.geom.Vec2"/></f></get_position>
		<position public="1" get="get_position" set="set_position"><c path="nape.geom.Vec2"/></position>
		<copy public="1" set="method" line="543"><f a=""><c path="nape.phys.Body"/></f></copy>
		<get_constraints get="inline" set="null" line="443"><f a=""><c path="nape.constraint.ConstraintList"/></f></get_constraints>
		<constraints public="1" get="get_constraints" set="null"><c path="nape.constraint.ConstraintList"/></constraints>
		<get_isSleeping get="inline" set="null" line="428"><f a=""><x path="Bool"/></f></get_isSleeping>
		<isSleeping public="1" get="get_isSleeping" set="null"><x path="Bool"/></isSleeping>
		<get_arbiters get="inline" set="null" line="412"><f a=""><c path="nape.dynamics.ArbiterList"/></f></get_arbiters>
		<arbiters public="1" get="get_arbiters" set="null"><c path="nape.dynamics.ArbiterList"/></arbiters>
		<set_space get="inline" set="null" line="388"><f a="space">
	<t path="Null"><c path="nape.space.Space"/></t>
	<t path="Null"><c path="nape.space.Space"/></t>
</f></set_space>
		<get_space get="inline" set="null" line="385"><f a=""><t path="Null"><c path="nape.space.Space"/></t></f></get_space>
		<space public="1" get="get_space" set="set_space"><t path="Null"><c path="nape.space.Space"/></t></space>
		<set_compound get="inline" set="null" line="366"><f a="compound">
	<t path="Null"><c path="nape.phys.Compound"/></t>
	<t path="Null"><c path="nape.phys.Compound"/></t>
</f></set_compound>
		<get_compound get="inline" set="null" line="363"><f a=""><t path="Null"><c path="nape.phys.Compound"/></t></f></get_compound>
		<compound public="1" get="get_compound" set="set_compound"><t path="Null"><c path="nape.phys.Compound"/></t></compound>
		<get_shapes get="inline" set="null" line="349"><f a=""><c path="nape.shape.ShapeList"/></f></get_shapes>
		<shapes public="1" get="get_shapes" set="null"><c path="nape.shape.ShapeList"/></shapes>
		<isKinematic public="1" get="inline" set="null" line="337"><f a=""><x path="Bool"/></f></isKinematic>
		<isDynamic public="1" get="inline" set="null" line="328"><f a=""><x path="Bool"/></f></isDynamic>
		<isStatic public="1" get="inline" set="null" line="319"><f a=""><x path="Bool"/></f></isStatic>
		<integrate public="1" set="method" line="295"><f a="deltaTime">
	<x path="Float"/>
	<c path="nape.phys.Body"/>
</f></integrate>
		<set_disableCCD get="inline" set="null" line="281"><f a="disableCCD">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_disableCCD>
		<get_disableCCD get="inline" set="null" line="278"><f a=""><x path="Bool"/></f></get_disableCCD>
		<disableCCD public="1" get="get_disableCCD" set="set_disableCCD"><x path="Bool"/></disableCCD>
		<set_isBullet get="inline" set="null" line="262"><f a="isBullet">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isBullet>
		<get_isBullet get="inline" set="null" line="259"><f a=""><x path="Bool"/></f></get_isBullet>
		<isBullet public="1" get="get_isBullet" set="set_isBullet"><x path="Bool"/></isBullet>
		<set_type get="inline" set="null" line="200"><f a="type">
	<c path="nape.phys.BodyType"/>
	<c path="nape.phys.BodyType"/>
</f></set_type>
		<get_type get="inline" set="null" line="197"><f a=""><c path="nape.phys.BodyType"/></f></get_type>
		<type public="1" get="get_type" set="set_type">
			<c path="nape.phys.BodyType"/>
			<haxe_doc><![CDATA[* Type of body.
     * <br/><br/>
     * This value can be changed even if Body is inside of a Space.]]></haxe_doc>
		</type>
		<debugDraw public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Set to disable debug drawing/
     * <br/><br/>
     * When true, this Body will not be drawn during debug draw operations
     * unless specifically given as argument to Debug draw() method.
     * @default true]]></haxe_doc>
		</debugDraw>
		<zpp_inner public="1">
			<c path="zpp_nape.phys.ZPP_Body"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="457"><f a="?type:?position">
	<c path="nape.phys.BodyType"/>
	<c path="nape.geom.Vec2"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Class representing a physics Rigid Body.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.BodyIterator" params="" file="libSrc/napeLib/nape/phys/BodyIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.phys.BodyIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1"><f a="list">
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyIterator"/>
</f></get>
		<next public="1" get="inline" set="null" line="264"><f a=""><c path="nape.phys.Body"/></f></next>
		<hasNext public="1" get="inline" set="null" line="240"><f a=""><x path="Bool"/></f></hasNext>
		<zpp_next public="1">
			<c path="nape.phys.BodyIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.phys.BodyList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.BodyList" params="" file="libSrc/napeLib/nape/phys/BodyList.hx">
		<fromArray public="1" set="method" line="304" static="1"><f a="array">
	<c path="Array"><c path="nape.phys.Body"/></c>
	<c path="nape.phys.BodyList"/>
</f></fromArray>
		<fromVector public="1" set="method" line="328" static="1"><f a="vector">
	<c path="flash.Vector"><c path="nape.phys.Body"/></c>
	<c path="nape.phys.BodyList"/>
</f></fromVector>
		<filter public="1" set="method" line="779"><f a="lambda">
	<f a="">
		<c path="nape.phys.Body"/>
		<x path="Bool"/>
	</f>
	<c path="nape.phys.BodyList"/>
</f></filter>
		<foreach public="1" get="inline" set="null" line="732"><f a="lambda">
	<f a="">
		<c path="nape.phys.Body"/>
		<x path="Void"/>
	</f>
	<c path="nape.phys.BodyList"/>
</f></foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<merge public="1" set="method" line="684"><f a="xs">
	<c path="nape.phys.BodyList"/>
	<x path="Void"/>
</f></merge>
		<copy public="1" set="method" line="662"><f a="?deep">
	<x path="Bool"/>
	<c path="nape.phys.BodyList"/>
</f></copy>
		<iterator public="1" get="inline" set="null" line="647"><f a=""><c path="nape.phys.BodyIterator"/></f></iterator>
		<empty public="1" get="inline" set="null" line="631"><f a=""><x path="Bool"/></f></empty>
		<clear public="1" set="method" line="614"><f a=""><x path="Void"/></f></clear>
		<remove public="1" set="method" line="576"><f a="obj">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
</f></remove>
		<add public="1" get="inline" set="null" line="563"><f a="obj">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
</f></add>
		<shift public="1" set="method" line="519"><f a=""><c path="nape.phys.Body"/></f></shift>
		<pop public="1" set="method" line="478"><f a=""><c path="nape.phys.Body"/></f></pop>
		<unshift public="1" set="method" line="447"><f a="obj">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
</f></unshift>
		<push public="1" set="method" line="416"><f a="obj">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
</f></push>
		<at public="1" set="method" line="363"><f a="index">
	<x path="Int"/>
	<c path="nape.phys.Body"/>
</f></at>
		<has public="1" set="method" line="346"><f a="obj">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
</f></has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="get_length" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_BodyList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* Nape list of Body type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Body = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Body = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Body = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.BodyType" params="" file="libSrc/napeLib/nape/phys/BodyType.hx">
		<STATIC public="1" get="get_STATIC" set="null" static="1"><c path="nape.phys.BodyType"/></STATIC>
		<get_STATIC get="inline" set="null" line="203" static="1"><f a=""><c path="nape.phys.BodyType"/></f></get_STATIC>
		<DYNAMIC public="1" get="get_DYNAMIC" set="null" static="1"><c path="nape.phys.BodyType"/></DYNAMIC>
		<get_DYNAMIC get="inline" set="null" line="217" static="1"><f a=""><c path="nape.phys.BodyType"/></f></get_DYNAMIC>
		<KINEMATIC public="1" get="get_KINEMATIC" set="null" static="1"><c path="nape.phys.BodyType"/></KINEMATIC>
		<get_KINEMATIC get="inline" set="null" line="232" static="1"><f a=""><c path="nape.phys.BodyType"/></f></get_KINEMATIC>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of rigid body types.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.Compound" params="" file="libSrc/napeLib/nape/phys/Compound.hx">
		<extends path="nape.phys.Interactor"/>
		<rotate public="1" set="method" line="463"><f a="centre:angle">
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<c path="nape.phys.Compound"/>
</f></rotate>
		<translate public="1" set="method" line="426"><f a="translation">
	<c path="nape.geom.Vec2"/>
	<c path="nape.phys.Compound"/>
</f></translate>
		<COM public="1" set="method" line="401"><f a="?weak">
	<x path="Bool"/>
	<c path="nape.geom.Vec2"/>
</f></COM>
		<visitCompounds public="1" set="method" line="382"><f a="lambda">
	<f a="">
		<c path="nape.phys.Compound"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></visitCompounds>
		<visitConstraints public="1" set="method" line="368"><f a="lambda">
	<f a="">
		<c path="nape.constraint.Constraint"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></visitConstraints>
		<visitBodies public="1" set="method" line="354"><f a="lambda">
	<f a="">
		<c path="nape.phys.Body"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></visitBodies>
		<breakApart public="1" set="method" line="344"><f a=""><x path="Void"/></f></breakApart>
		<copy public="1" set="method" line="330"><f a=""><c path="nape.phys.Compound"/></f></copy>
		<toString public="1" set="method" line="306" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<set_space get="inline" set="null" line="269"><f a="space">
	<t path="Null"><c path="nape.space.Space"/></t>
	<t path="Null"><c path="nape.space.Space"/></t>
</f></set_space>
		<get_space get="inline" set="null" line="266"><f a=""><t path="Null"><c path="nape.space.Space"/></t></f></get_space>
		<space public="1" get="get_space" set="set_space"><t path="Null"><c path="nape.space.Space"/></t></space>
		<set_compound get="inline" set="null" line="247"><f a="compound">
	<t path="Null"><c path="nape.phys.Compound"/></t>
	<t path="Null"><c path="nape.phys.Compound"/></t>
</f></set_compound>
		<get_compound get="inline" set="null" line="244"><f a=""><t path="Null"><c path="nape.phys.Compound"/></t></f></get_compound>
		<compound public="1" get="get_compound" set="set_compound"><t path="Null"><c path="nape.phys.Compound"/></t></compound>
		<get_compounds get="inline" set="null" line="234"><f a=""><c path="nape.phys.CompoundList"/></f></get_compounds>
		<compounds public="1" get="get_compounds" set="null"><c path="nape.phys.CompoundList"/></compounds>
		<get_constraints get="inline" set="null" line="222"><f a=""><c path="nape.constraint.ConstraintList"/></f></get_constraints>
		<constraints public="1" get="get_constraints" set="null"><c path="nape.constraint.ConstraintList"/></constraints>
		<get_bodies get="inline" set="null" line="210"><f a=""><c path="nape.phys.BodyList"/></f></get_bodies>
		<bodies public="1" get="get_bodies" set="null">
			<c path="nape.phys.BodyList"/>
			<haxe_doc><![CDATA[* List of bodies directly owned by this Compound.
     * <br/><br/>
     * This list does not include those bodies belonging to sub-compounds.
     *
     * @default []]]></haxe_doc>
		</bodies>
		<zpp_inner public="1">
			<c path="zpp_nape.phys.ZPP_Compound"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="287"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* Compound represents a grouping of physics objects into a single object.
 * <br/><br/>
 * This compound owns its constituents and works in the callback system and with
 * respect to adding/removing from a Space as a single object.
 * <pre>
 *       ____Cmp1_____
 *      /    /    &#92;   &#92;
 * Body1 Body2--Joint Cmp2
 *   |     |        &#92;  |
 * Shp1  Shp2        Body3
 *                     |
 *                    Shp3
 * </pre>
 * For example if you have a complex car built with several bodies and
 * constraints you might store this in a Compound providing an easy way
 * of removing/adding/copying the Car as well as being able to get a single
 * callback for when the car collides with something.
 * <br/><br/>
 * When you add a compound to a Space, all of it's constituents get added
 * and furthermore, those constituents cannot be added seperately.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.CompoundIterator" params="" file="libSrc/napeLib/nape/phys/CompoundIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.phys.CompoundIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1"><f a="list">
	<c path="nape.phys.CompoundList"/>
	<c path="nape.phys.CompoundIterator"/>
</f></get>
		<next public="1" get="inline" set="null" line="264"><f a=""><c path="nape.phys.Compound"/></f></next>
		<hasNext public="1" get="inline" set="null" line="240"><f a=""><x path="Bool"/></f></hasNext>
		<zpp_next public="1">
			<c path="nape.phys.CompoundIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.phys.CompoundList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.CompoundList" params="" file="libSrc/napeLib/nape/phys/CompoundList.hx">
		<fromArray public="1" set="method" line="304" static="1"><f a="array">
	<c path="Array"><c path="nape.phys.Compound"/></c>
	<c path="nape.phys.CompoundList"/>
</f></fromArray>
		<fromVector public="1" set="method" line="328" static="1"><f a="vector">
	<c path="flash.Vector"><c path="nape.phys.Compound"/></c>
	<c path="nape.phys.CompoundList"/>
</f></fromVector>
		<filter public="1" set="method" line="779"><f a="lambda">
	<f a="">
		<c path="nape.phys.Compound"/>
		<x path="Bool"/>
	</f>
	<c path="nape.phys.CompoundList"/>
</f></filter>
		<foreach public="1" get="inline" set="null" line="732"><f a="lambda">
	<f a="">
		<c path="nape.phys.Compound"/>
		<x path="Void"/>
	</f>
	<c path="nape.phys.CompoundList"/>
</f></foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<merge public="1" set="method" line="684"><f a="xs">
	<c path="nape.phys.CompoundList"/>
	<x path="Void"/>
</f></merge>
		<copy public="1" set="method" line="662"><f a="?deep">
	<x path="Bool"/>
	<c path="nape.phys.CompoundList"/>
</f></copy>
		<iterator public="1" get="inline" set="null" line="647"><f a=""><c path="nape.phys.CompoundIterator"/></f></iterator>
		<empty public="1" get="inline" set="null" line="631"><f a=""><x path="Bool"/></f></empty>
		<clear public="1" set="method" line="614"><f a=""><x path="Void"/></f></clear>
		<remove public="1" set="method" line="576"><f a="obj">
	<c path="nape.phys.Compound"/>
	<x path="Bool"/>
</f></remove>
		<add public="1" get="inline" set="null" line="563"><f a="obj">
	<c path="nape.phys.Compound"/>
	<x path="Bool"/>
</f></add>
		<shift public="1" set="method" line="519"><f a=""><c path="nape.phys.Compound"/></f></shift>
		<pop public="1" set="method" line="478"><f a=""><c path="nape.phys.Compound"/></f></pop>
		<unshift public="1" set="method" line="447"><f a="obj">
	<c path="nape.phys.Compound"/>
	<x path="Bool"/>
</f></unshift>
		<push public="1" set="method" line="416"><f a="obj">
	<c path="nape.phys.Compound"/>
	<x path="Bool"/>
</f></push>
		<at public="1" set="method" line="363"><f a="index">
	<x path="Int"/>
	<c path="nape.phys.Compound"/>
</f></at>
		<has public="1" set="method" line="346"><f a="obj">
	<c path="nape.phys.Compound"/>
	<x path="Bool"/>
</f></has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="get_length" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_CompoundList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* Nape list of Compound type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Compound = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Compound = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Compound = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.FluidProperties" params="" file="libSrc/napeLib/nape/phys/FluidProperties.hx">
		<toString public="1" set="method" line="344">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<set_gravity get="inline" set="null" line="320"><f a="gravity">
	<t path="Null"><c path="nape.geom.Vec2"/></t>
	<t path="Null"><c path="nape.geom.Vec2"/></t>
</f></set_gravity>
		<get_gravity get="inline" set="null" line="317"><f a=""><t path="Null"><c path="nape.geom.Vec2"/></t></f></get_gravity>
		<gravity public="1" get="get_gravity" set="set_gravity"><t path="Null"><c path="nape.geom.Vec2"/></t></gravity>
		<set_viscosity get="inline" set="null" line="296"><f a="viscosity">
	<x path="Float"/>
	<x path="Float"/>
</f></set_viscosity>
		<get_viscosity get="inline" set="null" line="293"><f a=""><x path="Float"/></f></get_viscosity>
		<viscosity public="1" get="get_viscosity" set="set_viscosity"><x path="Float"/></viscosity>
		<set_density get="inline" set="null" line="271"><f a="density">
	<x path="Float"/>
	<x path="Float"/>
</f></set_density>
		<get_density get="inline" set="null" line="268"><f a=""><x path="Float"/></f></get_density>
		<density public="1" get="get_density" set="set_density"><x path="Float"/></density>
		<copy public="1" set="method" line="254"><f a=""><c path="nape.phys.FluidProperties"/></f></copy>
		<get_shapes get="inline" set="null" line="210"><f a=""><c path="nape.shape.ShapeList"/></f></get_shapes>
		<shapes public="1" get="get_shapes" set="null"><c path="nape.shape.ShapeList"/></shapes>
		<get_userData get="inline" set="null" line="195"><f a=""><d><d/></d></f></get_userData>
		<userData public="1" get="get_userData" set="null">
			<d><d/></d>
			<haxe_doc><![CDATA[* Dynamic object for user to store additional data.
     * <br/><br/>
     * This object cannot be set, only its dynamically created
     * properties may be set. In AS3 the type of this property is &#42
     * <br/><br/>
     * This object will be lazily constructed so that until accessed
     * for the first time, will be null internally.
     *
     * @default {}]]></haxe_doc>
		</userData>
		<zpp_inner public="1">
			<c path="zpp_nape.phys.ZPP_FluidProperties"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="222"><f a="?density:?viscosity">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* FluidProperties providing shared parameters for fluid interaction.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.GravMassMode" params="" file="libSrc/napeLib/nape/phys/GravMassMode.hx">
		<DEFAULT public="1" get="get_DEFAULT" set="null" static="1"><c path="nape.phys.GravMassMode"/></DEFAULT>
		<get_DEFAULT get="inline" set="null" line="204" static="1"><f a=""><c path="nape.phys.GravMassMode"/></f></get_DEFAULT>
		<FIXED public="1" get="get_FIXED" set="null" static="1"><c path="nape.phys.GravMassMode"/></FIXED>
		<get_FIXED get="inline" set="null" line="219" static="1"><f a=""><c path="nape.phys.GravMassMode"/></f></get_FIXED>
		<SCALED public="1" get="get_SCALED" set="null" static="1"><c path="nape.phys.GravMassMode"/></SCALED>
		<get_SCALED get="inline" set="null" line="235" static="1"><f a=""><c path="nape.phys.GravMassMode"/></f></get_SCALED>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of GravMassMode values for a Body.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.InertiaMode" params="" file="libSrc/napeLib/nape/phys/InertiaMode.hx">
		<DEFAULT public="1" get="get_DEFAULT" set="null" static="1"><c path="nape.phys.InertiaMode"/></DEFAULT>
		<get_DEFAULT get="inline" set="null" line="203" static="1"><f a=""><c path="nape.phys.InertiaMode"/></f></get_DEFAULT>
		<FIXED public="1" get="get_FIXED" set="null" static="1"><c path="nape.phys.InertiaMode"/></FIXED>
		<get_FIXED get="inline" set="null" line="218" static="1"><f a=""><c path="nape.phys.InertiaMode"/></f></get_FIXED>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of InertiaMode values for a Body.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.InteractorIterator" params="" file="libSrc/napeLib/nape/phys/InteractorIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.phys.InteractorIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1"><f a="list">
	<c path="nape.phys.InteractorList"/>
	<c path="nape.phys.InteractorIterator"/>
</f></get>
		<next public="1" get="inline" set="null" line="264"><f a=""><c path="nape.phys.Interactor"/></f></next>
		<hasNext public="1" get="inline" set="null" line="240"><f a=""><x path="Bool"/></f></hasNext>
		<zpp_next public="1">
			<c path="nape.phys.InteractorIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.phys.InteractorList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.InteractorList" params="" file="libSrc/napeLib/nape/phys/InteractorList.hx">
		<fromArray public="1" set="method" line="304" static="1"><f a="array">
	<c path="Array"><c path="nape.phys.Interactor"/></c>
	<c path="nape.phys.InteractorList"/>
</f></fromArray>
		<fromVector public="1" set="method" line="328" static="1"><f a="vector">
	<c path="flash.Vector"><c path="nape.phys.Interactor"/></c>
	<c path="nape.phys.InteractorList"/>
</f></fromVector>
		<filter public="1" set="method" line="779"><f a="lambda">
	<f a="">
		<c path="nape.phys.Interactor"/>
		<x path="Bool"/>
	</f>
	<c path="nape.phys.InteractorList"/>
</f></filter>
		<foreach public="1" get="inline" set="null" line="732"><f a="lambda">
	<f a="">
		<c path="nape.phys.Interactor"/>
		<x path="Void"/>
	</f>
	<c path="nape.phys.InteractorList"/>
</f></foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<merge public="1" set="method" line="684"><f a="xs">
	<c path="nape.phys.InteractorList"/>
	<x path="Void"/>
</f></merge>
		<copy public="1" set="method" line="662"><f a="?deep">
	<x path="Bool"/>
	<c path="nape.phys.InteractorList"/>
</f></copy>
		<iterator public="1" get="inline" set="null" line="647"><f a=""><c path="nape.phys.InteractorIterator"/></f></iterator>
		<empty public="1" get="inline" set="null" line="631"><f a=""><x path="Bool"/></f></empty>
		<clear public="1" set="method" line="614"><f a=""><x path="Void"/></f></clear>
		<remove public="1" set="method" line="576"><f a="obj">
	<c path="nape.phys.Interactor"/>
	<x path="Bool"/>
</f></remove>
		<add public="1" get="inline" set="null" line="563"><f a="obj">
	<c path="nape.phys.Interactor"/>
	<x path="Bool"/>
</f></add>
		<shift public="1" set="method" line="519"><f a=""><c path="nape.phys.Interactor"/></f></shift>
		<pop public="1" set="method" line="478"><f a=""><c path="nape.phys.Interactor"/></f></pop>
		<unshift public="1" set="method" line="447"><f a="obj">
	<c path="nape.phys.Interactor"/>
	<x path="Bool"/>
</f></unshift>
		<push public="1" set="method" line="416"><f a="obj">
	<c path="nape.phys.Interactor"/>
	<x path="Bool"/>
</f></push>
		<at public="1" set="method" line="363"><f a="index">
	<x path="Int"/>
	<c path="nape.phys.Interactor"/>
</f></at>
		<has public="1" set="method" line="346"><f a="obj">
	<c path="nape.phys.Interactor"/>
	<x path="Bool"/>
</f></has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="get_length" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_InteractorList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* Nape list of Interactor type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Interactor = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Interactor = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Interactor = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.MassMode" params="" file="libSrc/napeLib/nape/phys/MassMode.hx">
		<DEFAULT public="1" get="get_DEFAULT" set="null" static="1"><c path="nape.phys.MassMode"/></DEFAULT>
		<get_DEFAULT get="inline" set="null" line="203" static="1"><f a=""><c path="nape.phys.MassMode"/></f></get_DEFAULT>
		<FIXED public="1" get="get_FIXED" set="null" static="1"><c path="nape.phys.MassMode"/></FIXED>
		<get_FIXED get="inline" set="null" line="218" static="1"><f a=""><c path="nape.phys.MassMode"/></f></get_FIXED>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of MassMode values for a Body.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.phys.Material" params="" file="libSrc/napeLib/nape/phys/Material.hx">
		<wood public="1" set="method" line="434" static="1"><f a=""><c path="nape.phys.Material"/></f></wood>
		<steel public="1" set="method" line="443" static="1"><f a=""><c path="nape.phys.Material"/></f></steel>
		<ice public="1" set="method" line="452" static="1"><f a=""><c path="nape.phys.Material"/></f></ice>
		<rubber public="1" set="method" line="461" static="1"><f a=""><c path="nape.phys.Material"/></f></rubber>
		<glass public="1" set="method" line="470" static="1"><f a=""><c path="nape.phys.Material"/></f></glass>
		<sand public="1" set="method" line="479" static="1"><f a=""><c path="nape.phys.Material"/></f></sand>
		<toString public="1" set="method" line="425">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<set_rollingFriction get="inline" set="null" line="408"><f a="rollingFriction">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rollingFriction>
		<get_rollingFriction get="inline" set="null" line="405"><f a=""><x path="Float"/></f></get_rollingFriction>
		<rollingFriction public="1" get="get_rollingFriction" set="set_rollingFriction"><x path="Float"/></rollingFriction>
		<set_density get="inline" set="null" line="377"><f a="density">
	<x path="Float"/>
	<x path="Float"/>
</f></set_density>
		<get_density get="inline" set="null" line="374"><f a=""><x path="Float"/></f></get_density>
		<density public="1" get="get_density" set="set_density"><x path="Float"/></density>
		<set_staticFriction get="inline" set="null" line="349"><f a="staticFriction">
	<x path="Float"/>
	<x path="Float"/>
</f></set_staticFriction>
		<get_staticFriction get="inline" set="null" line="346"><f a=""><x path="Float"/></f></get_staticFriction>
		<staticFriction public="1" get="get_staticFriction" set="set_staticFriction"><x path="Float"/></staticFriction>
		<set_dynamicFriction get="inline" set="null" line="319"><f a="dynamicFriction">
	<x path="Float"/>
	<x path="Float"/>
</f></set_dynamicFriction>
		<get_dynamicFriction get="inline" set="null" line="316"><f a=""><x path="Float"/></f></get_dynamicFriction>
		<dynamicFriction public="1" get="get_dynamicFriction" set="set_dynamicFriction"><x path="Float"/></dynamicFriction>
		<set_elasticity get="inline" set="null" line="289"><f a="elasticity">
	<x path="Float"/>
	<x path="Float"/>
</f></set_elasticity>
		<get_elasticity get="inline" set="null" line="286"><f a=""><x path="Float"/></f></get_elasticity>
		<elasticity public="1" get="get_elasticity" set="set_elasticity"><x path="Float"/></elasticity>
		<copy public="1" set="method" line="264"><f a=""><c path="nape.phys.Material"/></f></copy>
		<get_shapes get="inline" set="null" line="210"><f a=""><c path="nape.shape.ShapeList"/></f></get_shapes>
		<shapes public="1" get="get_shapes" set="null"><c path="nape.shape.ShapeList"/></shapes>
		<get_userData get="inline" set="null" line="195"><f a=""><d><d/></d></f></get_userData>
		<userData public="1" get="get_userData" set="null">
			<d><d/></d>
			<haxe_doc><![CDATA[* Dynamic object for user to store additional data.
     * <br/><br/>
     * This object cannot be set, only its dynamically created
     * properties may be set. In AS3 the type of this property is &#42
     * <br/><br/>
     * This object will be lazily constructed so that until accessed
     * for the first time, will be null internally.
     *
     * @default {}]]></haxe_doc>
		</userData>
		<zpp_inner public="1">
			<c path="zpp_nape.phys.ZPP_Material"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="229"><f a="?elasticity:?dynamicFriction:?staticFriction:?density:?rollingFriction">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Material property providing physical attributes to a Shape.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.Shape" params="" file="libSrc/napeLib/nape/shape/Shape.hx">
		<extends path="nape.phys.Interactor"/>
		<toString public="1" set="method" line="660" override="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<copy public="1" set="method" line="654"><f a=""><c path="nape.shape.Shape"/></f></copy>
		<contains public="1" set="method" line="616"><f a="point">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
</f></contains>
		<transform public="1" set="method" line="584"><f a="matrix">
	<c path="nape.geom.Mat23"/>
	<c path="nape.shape.Shape"/>
</f></transform>
		<rotate public="1" set="method" line="557"><f a="angle">
	<x path="Float"/>
	<c path="nape.shape.Shape"/>
</f></rotate>
		<scale public="1" set="method" line="527"><f a="scalex:scaley">
	<x path="Float"/>
	<x path="Float"/>
	<c path="nape.shape.Shape"/>
</f></scale>
		<translate public="1" set="method" line="487"><f a="translation">
	<c path="nape.geom.Vec2"/>
	<c path="nape.shape.Shape"/>
</f></translate>
		<get_bounds get="inline" set="null" line="473"><f a=""><c path="nape.geom.AABB"/></f></get_bounds>
		<bounds public="1" get="get_bounds" set="null"><c path="nape.geom.AABB"/></bounds>
		<set_sensorEnabled get="inline" set="null" line="454"><f a="sensorEnabled">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_sensorEnabled>
		<get_sensorEnabled get="inline" set="null" line="451"><f a=""><x path="Bool"/></f></get_sensorEnabled>
		<sensorEnabled public="1" get="get_sensorEnabled" set="set_sensorEnabled"><x path="Bool"/></sensorEnabled>
		<set_fluidEnabled get="inline" set="null" line="429"><f a="fluidEnabled">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_fluidEnabled>
		<get_fluidEnabled get="inline" set="null" line="426"><f a=""><x path="Bool"/></f></get_fluidEnabled>
		<fluidEnabled public="1" get="get_fluidEnabled" set="set_fluidEnabled"><x path="Bool"/></fluidEnabled>
		<set_fluidProperties get="inline" set="null" line="403"><f a="fluidProperties">
	<c path="nape.phys.FluidProperties"/>
	<c path="nape.phys.FluidProperties"/>
</f></set_fluidProperties>
		<get_fluidProperties get="inline" set="null" line="398"><f a=""><c path="nape.phys.FluidProperties"/></f></get_fluidProperties>
		<fluidProperties public="1" get="get_fluidProperties" set="set_fluidProperties"><c path="nape.phys.FluidProperties"/></fluidProperties>
		<set_filter get="inline" set="null" line="378"><f a="filter">
	<c path="nape.dynamics.InteractionFilter"/>
	<c path="nape.dynamics.InteractionFilter"/>
</f></set_filter>
		<get_filter get="inline" set="null" line="375"><f a=""><c path="nape.dynamics.InteractionFilter"/></f></get_filter>
		<filter public="1" get="get_filter" set="set_filter"><c path="nape.dynamics.InteractionFilter"/></filter>
		<set_material get="inline" set="null" line="358"><f a="material">
	<c path="nape.phys.Material"/>
	<c path="nape.phys.Material"/>
</f></set_material>
		<get_material get="inline" set="null" line="355"><f a=""><c path="nape.phys.Material"/></f></get_material>
		<material public="1" get="get_material" set="set_material"><c path="nape.phys.Material"/></material>
		<get_angDrag get="inline" set="null" line="344"><f a=""><x path="Float"/></f></get_angDrag>
		<angDrag public="1" get="get_angDrag" set="null"><x path="Float"/></angDrag>
		<get_inertia get="inline" set="null" line="335"><f a=""><x path="Float"/></f></get_inertia>
		<inertia public="1" get="get_inertia" set="null"><x path="Float"/></inertia>
		<get_area get="inline" set="null" line="326"><f a=""><x path="Float"/></f></get_area>
		<area public="1" get="get_area" set="null"><x path="Float"/></area>
		<set_localCOM get="inline" set="null" line="305"><f a="localCOM">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_localCOM>
		<get_localCOM get="inline" set="null" line="298"><f a=""><c path="nape.geom.Vec2"/></f></get_localCOM>
		<localCOM public="1" get="get_localCOM" set="set_localCOM"><c path="nape.geom.Vec2"/></localCOM>
		<get_worldCOM get="inline" set="null" line="277"><f a=""><c path="nape.geom.Vec2"/></f></get_worldCOM>
		<worldCOM public="1" get="get_worldCOM" set="null"><c path="nape.geom.Vec2"/></worldCOM>
		<get_castPolygon get="inline" set="null" line="263"><f a=""><t path="Null"><c path="nape.shape.Polygon"/></t></f></get_castPolygon>
		<castPolygon public="1" get="get_castPolygon" set="null"><t path="Null"><c path="nape.shape.Polygon"/></t></castPolygon>
		<get_castCircle get="inline" set="null" line="255"><f a=""><t path="Null"><c path="nape.shape.Circle"/></t></f></get_castCircle>
		<castCircle public="1" get="get_castCircle" set="null"><t path="Null"><c path="nape.shape.Circle"/></t></castCircle>
		<set_body get="inline" set="null" line="240"><f a="body">
	<t path="Null"><c path="nape.phys.Body"/></t>
	<t path="Null"><c path="nape.phys.Body"/></t>
</f></set_body>
		<get_body get="inline" set="null" line="237"><f a=""><t path="Null"><c path="nape.phys.Body"/></t></f></get_body>
		<body public="1" get="get_body" set="set_body"><t path="Null"><c path="nape.phys.Body"/></t></body>
		<isPolygon public="1" get="inline" set="null" line="207"><f a=""><x path="Bool"/></f></isPolygon>
		<isCircle public="1" get="inline" set="null" line="197"><f a=""><x path="Bool"/></f></isCircle>
		<get_type get="inline" set="null" line="187"><f a=""><c path="nape.shape.ShapeType"/></f></get_type>
		<type public="1" get="get_type" set="null">
			<c path="nape.shape.ShapeType"/>
			<haxe_doc>* Type of shape.</haxe_doc>
		</type>
		<zpp_inner public="1">
			<c path="zpp_nape.shape.ZPP_Shape"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new set="method" line="213"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Base type for Nape Shape's</haxe_doc>
	</class>
	<class path="nape.shape.Circle" params="" file="libSrc/napeLib/nape/shape/Circle.hx">
		<extends path="nape.shape.Shape"/>
		<set_radius get="inline" set="null" line="321"><f a="radius">
	<x path="Float"/>
	<x path="Float"/>
</f></set_radius>
		<get_radius get="inline" set="null" line="318"><f a=""><x path="Float"/></f></get_radius>
		<radius public="1" get="get_radius" set="set_radius"><x path="Float"/></radius>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.shape.ZPP_Circle"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="196">
			<f a="radius:?localCOM:?material:?filter">
				<x path="Float"/>
				<c path="nape.geom.Vec2"/>
				<c path="nape.phys.Material"/>
				<c path="nape.dynamics.InteractionFilter"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct a new Circle
     *
     * @param radius The radius of the circle, this value must be positive.
     * @param localCOM The local offset for the circle. (default &#40;0,0&#41;)
     * @param material The material for this circle. (default new Material&#40;&#41;)
     * @param filter The interaction filter for this circle.
     *               (default new InteractionFilter&#40;&#41;)
     * @return The constructed Circle
     * @throws # If radius is not strictly positive
     * @throws # If localCOM is non-null, but has been disposed of.]]></haxe_doc>
		</new>
		<haxe_doc>* Shape subtype representing a Circle</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.Edge" params="" file="libSrc/napeLib/nape/shape/Edge.hx">
		<toString public="1" set="method" line="321">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<get_worldVertex2 get="inline" set="null" line="311"><f a=""><c path="nape.geom.Vec2"/></f></get_worldVertex2>
		<worldVertex2 public="1" get="get_worldVertex2" set="null"><c path="nape.geom.Vec2"/></worldVertex2>
		<get_worldVertex1 get="inline" set="null" line="299"><f a=""><c path="nape.geom.Vec2"/></f></get_worldVertex1>
		<worldVertex1 public="1" get="get_worldVertex1" set="null"><c path="nape.geom.Vec2"/></worldVertex1>
		<get_localVertex2 get="inline" set="null" line="287"><f a=""><c path="nape.geom.Vec2"/></f></get_localVertex2>
		<localVertex2 public="1" get="get_localVertex2" set="null"><c path="nape.geom.Vec2"/></localVertex2>
		<get_localVertex1 get="inline" set="null" line="275"><f a=""><c path="nape.geom.Vec2"/></f></get_localVertex1>
		<localVertex1 public="1" get="get_localVertex1" set="null"><c path="nape.geom.Vec2"/></localVertex1>
		<get_worldProjection get="inline" set="null" line="262"><f a=""><x path="Float"/></f></get_worldProjection>
		<worldProjection public="1" get="get_worldProjection" set="null"><x path="Float"/></worldProjection>
		<get_localProjection get="inline" set="null" line="248"><f a=""><x path="Float"/></f></get_localProjection>
		<localProjection public="1" get="get_localProjection" set="null"><x path="Float"/></localProjection>
		<get_length get="inline" set="null" line="236"><f a=""><x path="Float"/></f></get_length>
		<length public="1" get="get_length" set="null"><x path="Float"/></length>
		<get_worldNormal get="inline" set="null" line="224"><f a=""><c path="nape.geom.Vec2"/></f></get_worldNormal>
		<worldNormal public="1" get="get_worldNormal" set="null"><c path="nape.geom.Vec2"/></worldNormal>
		<get_localNormal get="inline" set="null" line="208"><f a=""><c path="nape.geom.Vec2"/></f></get_localNormal>
		<localNormal public="1" get="get_localNormal" set="null"><c path="nape.geom.Vec2"/></localNormal>
		<get_polygon get="inline" set="null" line="195"><f a=""><c path="nape.shape.Polygon"/></f></get_polygon>
		<polygon public="1" get="get_polygon" set="null"><c path="nape.shape.Polygon"/></polygon>
		<zpp_inner public="1">
			<c path="zpp_nape.shape.ZPP_Edge"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="185">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Edge class providing internal details of Polygon.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.EdgeIterator" params="" file="libSrc/napeLib/nape/shape/EdgeIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.shape.EdgeIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1"><f a="list">
	<c path="nape.shape.EdgeList"/>
	<c path="nape.shape.EdgeIterator"/>
</f></get>
		<next public="1" get="inline" set="null" line="264"><f a=""><c path="nape.shape.Edge"/></f></next>
		<hasNext public="1" get="inline" set="null" line="240"><f a=""><x path="Bool"/></f></hasNext>
		<zpp_next public="1">
			<c path="nape.shape.EdgeIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.shape.EdgeList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.EdgeList" params="" file="libSrc/napeLib/nape/shape/EdgeList.hx">
		<fromArray public="1" set="method" line="304" static="1"><f a="array">
	<c path="Array"><c path="nape.shape.Edge"/></c>
	<c path="nape.shape.EdgeList"/>
</f></fromArray>
		<fromVector public="1" set="method" line="328" static="1"><f a="vector">
	<c path="flash.Vector"><c path="nape.shape.Edge"/></c>
	<c path="nape.shape.EdgeList"/>
</f></fromVector>
		<filter public="1" set="method" line="779"><f a="lambda">
	<f a="">
		<c path="nape.shape.Edge"/>
		<x path="Bool"/>
	</f>
	<c path="nape.shape.EdgeList"/>
</f></filter>
		<foreach public="1" get="inline" set="null" line="732"><f a="lambda">
	<f a="">
		<c path="nape.shape.Edge"/>
		<x path="Void"/>
	</f>
	<c path="nape.shape.EdgeList"/>
</f></foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<merge public="1" set="method" line="684"><f a="xs">
	<c path="nape.shape.EdgeList"/>
	<x path="Void"/>
</f></merge>
		<copy public="1" set="method" line="662"><f a="?deep">
	<x path="Bool"/>
	<c path="nape.shape.EdgeList"/>
</f></copy>
		<iterator public="1" get="inline" set="null" line="647"><f a=""><c path="nape.shape.EdgeIterator"/></f></iterator>
		<empty public="1" get="inline" set="null" line="631"><f a=""><x path="Bool"/></f></empty>
		<clear public="1" set="method" line="614"><f a=""><x path="Void"/></f></clear>
		<remove public="1" set="method" line="576"><f a="obj">
	<c path="nape.shape.Edge"/>
	<x path="Bool"/>
</f></remove>
		<add public="1" get="inline" set="null" line="563"><f a="obj">
	<c path="nape.shape.Edge"/>
	<x path="Bool"/>
</f></add>
		<shift public="1" set="method" line="519"><f a=""><c path="nape.shape.Edge"/></f></shift>
		<pop public="1" set="method" line="478"><f a=""><c path="nape.shape.Edge"/></f></pop>
		<unshift public="1" set="method" line="447"><f a="obj">
	<c path="nape.shape.Edge"/>
	<x path="Bool"/>
</f></unshift>
		<push public="1" set="method" line="416"><f a="obj">
	<c path="nape.shape.Edge"/>
	<x path="Bool"/>
</f></push>
		<at public="1" set="method" line="363"><f a="index">
	<x path="Int"/>
	<c path="nape.shape.Edge"/>
</f></at>
		<has public="1" set="method" line="346"><f a="obj">
	<c path="nape.shape.Edge"/>
	<x path="Bool"/>
</f></has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="get_length" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_EdgeList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* Nape list of Edge type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Edge = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Edge = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Edge = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.Polygon" params="" file="libSrc/napeLib/nape/shape/Polygon.hx">
		<extends path="nape.shape.Shape"/>
		<rect public="1" set="method" line="209" static="1">
			<f a="x:y:width:height:?weak">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><c path="nape.geom.Vec2"/></c>
			</f>
			<haxe_doc><![CDATA[* Construct a polygon representing a rectangle.
     * <br/><br/>
     * For a dynamic object, you may consider use of the box method instead
     * as dynamic bodies will only respond as expected if their centre of mass
     * is equal to the origin.
     * <br/><br/>
     * The generate polygon will have coordinates equal to:
     * <pre>
     * (x, y) -> (x + width, y + height)
     * </pre>
     * Negative values of width/height are permitted so that the given x/y values
     * may not necessarigly be the top-left corner of rectangle.
     *
     * @param x The x coordinate of rectangle.
     * @param y The y coordinate of rectangle.
     * @param width The width of the ractangle. This value may be negative.
     * @param height The height of the rectangle This value may be negative.
     * @param weak If true, the generated list of vertices will be allocated as
     *             weak Vec2s so that when this list is passed to a Nape function
     *             these Vec2s will be automatically sent back to object pool.
     *             (default false)
     * @return An array of Vec2 representing the given rectangle.]]></haxe_doc>
		</rect>
		<box public="1" set="method" line="231" static="1"><f a="width:height:?weak">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="Array"><c path="nape.geom.Vec2"/></c>
</f></box>
		<regular public="1" set="method" line="257" static="1"><f a="xRadius:yRadius:edgeCount:?angleOffset:?weak">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="Array"><c path="nape.geom.Vec2"/></c>
</f></regular>
		<validity public="1" set="method" line="312"><f a=""><c path="nape.shape.ValidationResult"/></f></validity>
		<get_edges get="inline" set="null" line="304"><f a=""><c path="nape.shape.EdgeList"/></f></get_edges>
		<edges public="1" get="get_edges" set="null"><c path="nape.shape.EdgeList"/></edges>
		<get_worldVerts get="inline" set="null" line="293"><f a=""><c path="nape.geom.Vec2List"/></f></get_worldVerts>
		<worldVerts public="1" get="get_worldVerts" set="null"><c path="nape.geom.Vec2List"/></worldVerts>
		<get_localVerts get="inline" set="null" line="279"><f a=""><c path="nape.geom.Vec2List"/></f></get_localVerts>
		<localVerts public="1" get="get_localVerts" set="null"><c path="nape.geom.Vec2List"/></localVerts>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.shape.ZPP_Polygon"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="331"><f a="localVerts:?material:?filter">
	<d/>
	<c path="nape.phys.Material"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* Polygon subtype of Shape.
 * <br/><br/>
 * Can be used to simulate any convex polygon.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.ShapeIterator" params="" file="libSrc/napeLib/nape/shape/ShapeIterator.hx">
		<zpp_pool public="1" line="194" static="1">
			<c path="nape.shape.ShapeIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_pool>
		<get public="1" set="method" line="217" static="1"><f a="list">
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeIterator"/>
</f></get>
		<next public="1" get="inline" set="null" line="264"><f a=""><c path="nape.shape.Shape"/></f></next>
		<hasNext public="1" get="inline" set="null" line="240"><f a=""><x path="Bool"/></f></hasNext>
		<zpp_next public="1">
			<c path="nape.shape.ShapeIterator"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_next>
		<zpp_critical public="1">
			<x path="Bool"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_critical>
		<zpp_i public="1">
			<x path="Int"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_i>
		<zpp_inner public="1">
			<c path="nape.shape.ShapeList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="202">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Haxe Iterator<T> compatible iterator over Nape list.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.ShapeList" params="" file="libSrc/napeLib/nape/shape/ShapeList.hx">
		<fromArray public="1" set="method" line="304" static="1"><f a="array">
	<c path="Array"><c path="nape.shape.Shape"/></c>
	<c path="nape.shape.ShapeList"/>
</f></fromArray>
		<fromVector public="1" set="method" line="328" static="1"><f a="vector">
	<c path="flash.Vector"><c path="nape.shape.Shape"/></c>
	<c path="nape.shape.ShapeList"/>
</f></fromVector>
		<filter public="1" set="method" line="779"><f a="lambda">
	<f a="">
		<c path="nape.shape.Shape"/>
		<x path="Bool"/>
	</f>
	<c path="nape.shape.ShapeList"/>
</f></filter>
		<foreach public="1" get="inline" set="null" line="732"><f a="lambda">
	<f a="">
		<c path="nape.shape.Shape"/>
		<x path="Void"/>
	</f>
	<c path="nape.shape.ShapeList"/>
</f></foreach>
		<toString public="1" set="method" line="702">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<merge public="1" set="method" line="684"><f a="xs">
	<c path="nape.shape.ShapeList"/>
	<x path="Void"/>
</f></merge>
		<copy public="1" set="method" line="662"><f a="?deep">
	<x path="Bool"/>
	<c path="nape.shape.ShapeList"/>
</f></copy>
		<iterator public="1" get="inline" set="null" line="647"><f a=""><c path="nape.shape.ShapeIterator"/></f></iterator>
		<empty public="1" get="inline" set="null" line="631"><f a=""><x path="Bool"/></f></empty>
		<clear public="1" set="method" line="614"><f a=""><x path="Void"/></f></clear>
		<remove public="1" set="method" line="576"><f a="obj">
	<c path="nape.shape.Shape"/>
	<x path="Bool"/>
</f></remove>
		<add public="1" get="inline" set="null" line="563"><f a="obj">
	<c path="nape.shape.Shape"/>
	<x path="Bool"/>
</f></add>
		<shift public="1" set="method" line="519"><f a=""><c path="nape.shape.Shape"/></f></shift>
		<pop public="1" set="method" line="478"><f a=""><c path="nape.shape.Shape"/></f></pop>
		<unshift public="1" set="method" line="447"><f a="obj">
	<c path="nape.shape.Shape"/>
	<x path="Bool"/>
</f></unshift>
		<push public="1" set="method" line="416"><f a="obj">
	<c path="nape.shape.Shape"/>
	<x path="Bool"/>
</f></push>
		<at public="1" set="method" line="363"><f a="index">
	<x path="Int"/>
	<c path="nape.shape.Shape"/>
</f></at>
		<has public="1" set="method" line="346"><f a="obj">
	<c path="nape.shape.Shape"/>
	<x path="Bool"/>
</f></has>
		<get_length get="inline" set="null" line="244"><f a=""><x path="Int"/></f></get_length>
		<length public="1" get="get_length" set="null">
			<x path="Int"/>
			<haxe_doc>* Length of list.</haxe_doc>
		</length>
		<zpp_inner public="1">
			<c path="zpp_nape.util.ZPP_ShapeList"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="695"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* Nape list of Shape type objects
 * <br/><br/>
 * Internally this list is at present implemented as a linked list with
 * object pooled nodes and iterators with various fast paths made for
 * standard access patterns (For instance accessing successive elements
 * runs in constant time when using random access functions)
 * <br/><br/>
 * Iteration of this list can be done in various ways, but the preferred
 * way on all targets, is through use of the foreach function:
 * <pre>
 * list.foreach(function (obj) {
 * });
 * </pre>
 * This method is inlined so that in haxe no closure will need to be created.
 * <br/><br/>
 * In AS3, a closure would need to be created in general, so for performance
 * reasons you 'may' choose to use iteration as follows:
 * <pre>
 * for (var i:int = 0; i < list.length; i++) {
 *     var obj:Shape = list.at(i);
 * }
 * </pre>
 * <br/>
 * NOTE: It is 'not' safe to modify a list whilst iterating over it.
 * If you wish to remove elements during an iteration you should use the
 * filter method, for example:
 * <pre>
 * list.filter(function (obj) {
 *     // operate on object.
 *     // ...
 *     return (false if you want object to be removed);
 * });
 * </pre>
 * <br/><br/>
 * In AS3, if you wish to avoid a closure generation, you can perform such
 * an iteration in a safe manner as follows:
 * <pre>
 * var i:int = 0;
 * while (i < list.length) {
 *     var obj:Shape = list.at(i);
 *     // operate on object.
 *     // ...
 *     if (should remove obj) {
 *         list.remove(obj);
 *         continue;
 *     }
 *     else i++;
 * }
 * </pre>
 * Or if you are always clearing the list entirely you could write:
 * <pre>
 * while (!list.empty()) {
 *     var obj:Shape = list.pop();
 *     // operate on object.
 *     // ...
 * }
 * </pre>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.ShapeType" params="" file="libSrc/napeLib/nape/shape/ShapeType.hx">
		<CIRCLE public="1" get="get_CIRCLE" set="null" static="1"><c path="nape.shape.ShapeType"/></CIRCLE>
		<get_CIRCLE get="inline" set="null" line="201" static="1"><f a=""><c path="nape.shape.ShapeType"/></f></get_CIRCLE>
		<POLYGON public="1" get="get_POLYGON" set="null" static="1"><c path="nape.shape.ShapeType"/></POLYGON>
		<get_POLYGON get="inline" set="null" line="214" static="1"><f a=""><c path="nape.shape.ShapeType"/></f></get_POLYGON>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of Nape Shape types.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.shape.ValidationResult" params="" file="libSrc/napeLib/nape/shape/ValidationResult.hx">
		<VALID public="1" get="get_VALID" set="null" static="1"><c path="nape.shape.ValidationResult"/></VALID>
		<get_VALID get="inline" set="null" line="203" static="1"><f a=""><c path="nape.shape.ValidationResult"/></f></get_VALID>
		<DEGENERATE public="1" get="get_DEGENERATE" set="null" static="1"><c path="nape.shape.ValidationResult"/></DEGENERATE>
		<get_DEGENERATE get="inline" set="null" line="216" static="1"><f a=""><c path="nape.shape.ValidationResult"/></f></get_DEGENERATE>
		<CONCAVE public="1" get="get_CONCAVE" set="null" static="1"><c path="nape.shape.ValidationResult"/></CONCAVE>
		<get_CONCAVE get="inline" set="null" line="229" static="1"><f a=""><c path="nape.shape.ValidationResult"/></f></get_CONCAVE>
		<SELF_INTERSECTING public="1" get="get_SELF_INTERSECTING" set="null" static="1"><c path="nape.shape.ValidationResult"/></SELF_INTERSECTING>
		<get_SELF_INTERSECTING get="inline" set="null" line="242" static="1"><f a=""><c path="nape.shape.ValidationResult"/></f></get_SELF_INTERSECTING>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of validation results for a Polygon.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.space.Broadphase" params="" file="libSrc/napeLib/nape/space/Broadphase.hx">
		<DYNAMIC_AABB_TREE public="1" get="get_DYNAMIC_AABB_TREE" set="null" static="1"><c path="nape.space.Broadphase"/></DYNAMIC_AABB_TREE>
		<get_DYNAMIC_AABB_TREE get="inline" set="null" line="210" static="1"><f a=""><c path="nape.space.Broadphase"/></f></get_DYNAMIC_AABB_TREE>
		<SWEEP_AND_PRUNE public="1" get="get_SWEEP_AND_PRUNE" set="null" static="1"><c path="nape.space.Broadphase"/></SWEEP_AND_PRUNE>
		<get_SWEEP_AND_PRUNE get="inline" set="null" line="238" static="1"><f a=""><c path="nape.space.Broadphase"/></f></get_SWEEP_AND_PRUNE>
		<toString public="1" set="method" line="189">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="181">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Enumeration of available broadphase collision types that Spaces may use.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.space.Space" params="" file="libSrc/napeLib/nape/space/Space.hx">
		<rayMultiCast public="1" set="method" line="1048"><f a="ray:?inner:?filter:?output">
	<c path="nape.geom.Ray"/>
	<x path="Bool"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<c path="nape.geom.RayResultList"/>
	<c path="nape.geom.RayResultList"/>
</f></rayMultiCast>
		<rayCast public="1" set="method" line="1023"><f a="ray:?inner:?filter">
	<c path="nape.geom.Ray"/>
	<x path="Bool"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<t path="Null"><c path="nape.geom.RayResult"/></t>
</f></rayCast>
		<convexMultiCast public="1" set="method" line="992"><f a="shape:deltaTime:?liveSweep:?filter:output">
	<c path="nape.shape.Shape"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<c path="nape.geom.ConvexResultList"/>
	<c path="nape.geom.ConvexResultList"/>
</f></convexMultiCast>
		<convexCast public="1" set="method" line="957"><f a="shape:deltaTime:?liveSweep:?filter">
	<c path="nape.shape.Shape"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<t path="Null"><c path="nape.geom.ConvexResult"/></t>
</f></convexCast>
		<bodiesInBody public="1" set="method" line="924"><f a="body:?filter:?output">
	<c path="nape.phys.Body"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInBody>
		<shapesInBody public="1" set="method" line="898"><f a="body:?filter:?output">
	<c path="nape.phys.Body"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInBody>
		<bodiesInShape public="1" set="method" line="870"><f a="shape:?containment:?filter:?output">
	<c path="nape.shape.Shape"/>
	<x path="Bool"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInShape>
		<shapesInShape public="1" set="method" line="838"><f a="shape:?containment:?filter:?output">
	<c path="nape.shape.Shape"/>
	<x path="Bool"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInShape>
		<bodiesInCircle public="1" set="method" line="791"><f a="position:radius:?containment:?filter:?output">
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInCircle>
		<shapesInCircle public="1" set="method" line="744"><f a="position:radius:?containment:?filter:?output">
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInCircle>
		<bodiesInAABB public="1" set="method" line="718"><f a="aabb:?containment:?strict:?filter:?output">
	<c path="nape.geom.AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInAABB>
		<shapesInAABB public="1" set="method" line="690"><f a="aabb:?containment:?strict:?filter:?output">
	<c path="nape.geom.AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInAABB>
		<bodiesUnderPoint public="1" set="method" line="647"><f a="point:?filter:?output">
	<c path="nape.geom.Vec2"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesUnderPoint>
		<shapesUnderPoint public="1" set="method" line="610"><f a="point:?filter:?output">
	<c path="nape.geom.Vec2"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesUnderPoint>
		<interactionType public="1" set="method" line="578"><f a="shape1:shape2">
	<c path="nape.shape.Shape"/>
	<c path="nape.shape.Shape"/>
	<t path="Null"><c path="nape.callbacks.InteractionType"/></t>
</f></interactionType>
		<get_elapsedTime get="inline" set="null" line="527"><f a=""><x path="Float"/></f></get_elapsedTime>
		<elapsedTime public="1" get="get_elapsedTime" set="null"><x path="Float"/></elapsedTime>
		<get_timeStamp get="inline" set="null" line="517"><f a=""><x path="Int"/></f></get_timeStamp>
		<timeStamp public="1" get="get_timeStamp" set="null"><x path="Int"/></timeStamp>
		<step public="1" set="method" line="501"><f a="deltaTime:?velocityIterations:?positionIterations">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></step>
		<clear public="1" set="method" line="475"><f a=""><x path="Void"/></f></clear>
		<get_listeners get="inline" set="null" line="462"><f a=""><c path="nape.callbacks.ListenerList"/></f></get_listeners>
		<listeners public="1" get="get_listeners" set="null"><c path="nape.callbacks.ListenerList"/></listeners>
		<get_arbiters get="inline" set="null" line="446"><f a=""><c path="nape.dynamics.ArbiterList"/></f></get_arbiters>
		<arbiters public="1" get="get_arbiters" set="null"><c path="nape.dynamics.ArbiterList"/></arbiters>
		<get_world get="inline" set="null" line="436"><f a=""><c path="nape.phys.Body"/></f></get_world>
		<world public="1" get="get_world" set="null"><c path="nape.phys.Body"/></world>
		<visitCompounds public="1" set="method" line="415"><f a="lambda">
	<f a="">
		<c path="nape.phys.Compound"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></visitCompounds>
		<visitConstraints public="1" set="method" line="399"><f a="lambda">
	<f a="">
		<c path="nape.constraint.Constraint"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></visitConstraints>
		<visitBodies public="1" set="method" line="383"><f a="lambda">
	<f a="">
		<c path="nape.phys.Body"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></visitBodies>
		<get_liveConstraints get="inline" set="null" line="371"><f a=""><c path="nape.constraint.ConstraintList"/></f></get_liveConstraints>
		<liveConstraints public="1" get="get_liveConstraints" set="null"><c path="nape.constraint.ConstraintList"/></liveConstraints>
		<get_constraints get="inline" set="null" line="359"><f a=""><c path="nape.constraint.ConstraintList"/></f></get_constraints>
		<constraints public="1" get="get_constraints" set="null"><c path="nape.constraint.ConstraintList"/></constraints>
		<get_liveBodies get="inline" set="null" line="345"><f a=""><c path="nape.phys.BodyList"/></f></get_liveBodies>
		<liveBodies public="1" get="get_liveBodies" set="null"><c path="nape.phys.BodyList"/></liveBodies>
		<get_bodies get="inline" set="null" line="333"><f a=""><c path="nape.phys.BodyList"/></f></get_bodies>
		<bodies public="1" get="get_bodies" set="null"><c path="nape.phys.BodyList"/></bodies>
		<get_compounds get="inline" set="null" line="319"><f a=""><c path="nape.phys.CompoundList"/></f></get_compounds>
		<compounds public="1" get="get_compounds" set="null"><c path="nape.phys.CompoundList"/></compounds>
		<set_worldLinearDrag get="inline" set="null" line="298"><f a="worldLinearDrag">
	<x path="Float"/>
	<x path="Float"/>
</f></set_worldLinearDrag>
		<get_worldLinearDrag get="inline" set="null" line="295"><f a=""><x path="Float"/></f></get_worldLinearDrag>
		<worldLinearDrag public="1" get="get_worldLinearDrag" set="set_worldLinearDrag"><x path="Float"/></worldLinearDrag>
		<set_worldAngularDrag get="inline" set="null" line="275"><f a="worldAngularDrag">
	<x path="Float"/>
	<x path="Float"/>
</f></set_worldAngularDrag>
		<get_worldAngularDrag get="inline" set="null" line="272"><f a=""><x path="Float"/></f></get_worldAngularDrag>
		<worldAngularDrag public="1" get="get_worldAngularDrag" set="set_worldAngularDrag"><x path="Float"/></worldAngularDrag>
		<set_sortContacts get="inline" set="null" line="256"><f a="sortContacts">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_sortContacts>
		<get_sortContacts get="inline" set="null" line="253"><f a=""><x path="Bool"/></f></get_sortContacts>
		<sortContacts public="1" get="get_sortContacts" set="set_sortContacts"><x path="Bool"/></sortContacts>
		<get_broadphase get="inline" set="null" line="232"><f a=""><c path="nape.space.Broadphase"/></f></get_broadphase>
		<broadphase public="1" get="get_broadphase" set="null"><c path="nape.space.Broadphase"/></broadphase>
		<set_gravity get="inline" set="null" line="213"><f a="gravity">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
</f></set_gravity>
		<get_gravity get="inline" set="null" line="209"><f a=""><c path="nape.geom.Vec2"/></f></get_gravity>
		<gravity public="1" get="get_gravity" set="set_gravity"><c path="nape.geom.Vec2"/></gravity>
		<get_userData get="inline" set="null" line="195"><f a=""><d><d/></d></f></get_userData>
		<userData public="1" get="get_userData" set="null">
			<d><d/></d>
			<haxe_doc><![CDATA[* Dynamic object for user to store additional data.
     * <br/><br/>
     * This object cannot be set, only its dynamically created
     * properties may be set. In AS3 the type of this property is &#42
     * <br/><br/>
     * This object will be lazily constructed so that until accessed
     * for the first time, will be null internally.
     *
     * @default {}]]></haxe_doc>
		</userData>
		<zpp_inner public="1">
			<c path="zpp_nape.space.ZPP_Space"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner>
		<new public="1" set="method" line="538"><f a="?gravity:?broadphase">
	<c path="nape.geom.Vec2"/>
	<c path="nape.space.Broadphase"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* The heart of all Nape simulations.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.util.Debug" params="" file="libSrc/napeLib/nape/util/Debug.hx">
		<version public="1" set="method" line="183" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Query Nape version</haxe_doc>
		</version>
		<clearObjectPools public="1" set="method" line="189" static="1"><f a=""><x path="Void"/></f></clearObjectPools>
		<createGraphic public="1" set="method" line="1091" static="1"><f a="body">
	<c path="nape.phys.Body"/>
	<c path="flash.display.Shape"/>
</f></createGraphic>
		<drawSpring public="1" set="method" line="1423"><f a="start:end:colour:?coils:?radius">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawSpring>
		<drawFilledPolygon public="1" set="method" line="1409"><f a="polygon:colour">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawFilledPolygon>
		<drawPolygon public="1" set="method" line="1395"><f a="polygon:colour">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawPolygon>
		<drawFilledCircle public="1" set="method" line="1381"><f a="position:radius:colour">
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawFilledCircle>
		<drawFilledTriangle public="1" set="method" line="1368"><f a="p0:p1:p2:colour">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawFilledTriangle>
		<drawAABB public="1" set="method" line="1356"><f a="aabb:colour">
	<c path="nape.geom.AABB"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawAABB>
		<drawCircle public="1" set="method" line="1346"><f a="position:radius:colour">
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawCircle>
		<drawCurve public="1" set="method" line="1333"><f a="start:control:end:colour">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawCurve>
		<drawLine public="1" set="method" line="1321"><f a="start:end:colour">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawLine>
		<draw public="1" set="method" line="1310"><f a="object">
	<d/>
	<x path="Void"/>
</f></draw>
		<flush public="1" set="method" line="1295"><f a=""><x path="Void"/></f></flush>
		<clear public="1" set="method" line="1289"><f a=""><x path="Void"/></f></clear>
		<set_transform get="inline" set="null" line="1277"><f a="transform">
	<c path="nape.geom.Mat23"/>
	<c path="nape.geom.Mat23"/>
</f></set_transform>
		<get_transform get="inline" set="null" line="1273"><f a=""><c path="nape.geom.Mat23"/></f></get_transform>
		<transform public="1" get="get_transform" set="set_transform">
			<c path="nape.geom.Mat23"/>
			<haxe_doc><![CDATA[* Transformation to apply to all debug draw operations.
     * <br/><br/>
     * This transform can be used to 'move' the debug draw screen through your
     * world as well as rotating and zooming in etc.
     * <br/><br/>
     * This transform effects 'all' debug draw operations and optimisation is in
     * place to not perform any transformation if matrix is the identity matrix.
     *
     * @default new Mat23()]]></haxe_doc>
		</transform>
		<cullingEnabled public="1"><x path="Bool"/></cullingEnabled>
		<get_display get="inline" set="null" line="1239"><f a=""><c path="flash.display.DisplayObject"/></f></get_display>
		<display public="1" get="get_display" set="null"><c path="flash.display.DisplayObject"/></display>
		<colour public="1"><t path="Null"><f a="">
	<x path="Int"/>
	<x path="Int"/>
</f></t></colour>
		<set_bgColour get="inline" set="null" line="1194"><f a="bgColour">
	<x path="Int"/>
	<x path="Int"/>
</f></set_bgColour>
		<get_bgColour get="inline" set="null" line="1191"><f a=""><x path="Int"/></f></get_bgColour>
		<bgColour public="1" get="get_bgColour" set="set_bgColour">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Background colour for debug draw display.
     * <br/><br/>
     * This value does not have much use for ShapeDebug, or for
     * a transparent BitmapDebug but will still be used in tinting
     * object colours to better fit an idealised background colour.]]></haxe_doc>
		</bgColour>
		<drawConstraints public="1">
			<x path="Bool"/>
			<haxe_doc>* If true, then representations of the active constraints will be drawn.
     * @default false</haxe_doc>
		</drawConstraints>
		<drawShapeAngleIndicators public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* If true, then indicators of the shapes rotation will be drawn.
     * <br/><br/>
     * This will only have an effect if drawBodies is true.
     * @default true]]></haxe_doc>
		</drawShapeAngleIndicators>
		<drawShapeDetail public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* If true, then things like shape centre of mass and bounding box will be drawn.
     * <br/><br/>
     * This will only have an effect if drawBodies is true.
     * @default false]]></haxe_doc>
		</drawShapeDetail>
		<drawBodyDetail public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* If true, then things like the body centre of mass, and bouncing box will be drawn.
     * <br/><br/>
     * This will only have an effect if drawBodies is true.
     * @default false]]></haxe_doc>
		</drawBodyDetail>
		<drawBodies public="1">
			<x path="Bool"/>
			<haxe_doc>* If true, then all bodies in the space (whether active or not) will be drawn.
     * @default true</haxe_doc>
		</drawBodies>
		<drawSensorArbiters public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* If true, a representation of sensor interactions will be drawn.
     * <br/><br/>
     * Only active arbiters are drawn.
     * @default false]]></haxe_doc>
		</drawSensorArbiters>
		<drawFluidArbiters public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* If true, a representation of centres of buoyancy and overlap will be drawn.
     * <br/><br/>
     * Only active arbiters are drawn.
     * @default false]]></haxe_doc>
		</drawFluidArbiters>
		<drawCollisionArbiters public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* If true, a representation of contact patches will be drawn.
     * <br/><br/>
     * Only active arbiters are drawn.
     * @default false]]></haxe_doc>
		</drawCollisionArbiters>
		<zpp_inner public="1"><c path="zpp_nape.util.ZPP_Debug"/></zpp_inner>
		<new public="1" set="method" line="1217">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Debug class providing general utilities
 * <br/><br/>
 * Also serves as the base type for Debug draws.]]></haxe_doc>
	</class>
	<class path="nape.util.BitmapDebug" params="" file="libSrc/napeLib/nape/util/BitmapDebug.hx">
		<extends path="nape.util.Debug"/>
		<drawSpring public="1" set="method" line="1111" override="1"><f a="start:end:colour:?coils:?radius">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawSpring>
		<draw public="1" set="method" line="1078" override="1"><f a="object">
	<d/>
	<x path="Void"/>
</f></draw>
		<drawFilledPolygon public="1" set="method" line="831" override="1"><f a="polygon:colour">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawFilledPolygon>
		<drawPolygon public="1" set="method" line="564" override="1"><f a="polygon:colour">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawPolygon>
		<drawFilledCircle public="1" set="method" line="522" override="1"><f a="position:radius:colour">
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawFilledCircle>
		<drawFilledTriangle public="1" set="method" line="462" override="1"><f a="p0:p1:p2:colour">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawFilledTriangle>
		<drawAABB public="1" set="method" line="425" override="1"><f a="aabb:colour">
	<c path="nape.geom.AABB"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawAABB>
		<drawCircle public="1" set="method" line="383" override="1"><f a="position:radius:colour">
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawCircle>
		<drawCurve public="1" set="method" line="310" override="1"><f a="start:control:end:colour">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawCurve>
		<drawLine public="1" set="method" line="248" override="1"><f a="start:end:colour">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawLine>
		<prepare public="1" set="method" line="242"><f a=""><x path="Void"/></f></prepare>
		<flush public="1" set="method" line="232" override="1"><f a=""><x path="Void"/></f></flush>
		<clear public="1" set="method" line="226" override="1"><f a=""><x path="Void"/></f></clear>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.util.ZPP_BitmapDebug"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="204">
			<f a="width:height:?bgColour:?transparent">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Construct new BitmapDebug object.
     *
     * @param width The width of Debug draw viewport.
     * @param height The height of Debug draw viewport.
     * @param bgColour The background colour for debug draw. (default 0x333333)
     * @param transparent If true, then the debug draw will use an ARGB bitmap
     *                    with a transparent background. This will be slower.
     *                    (default false)
     * @return The constructed BitmapDebug.
     * @throws # If width or height are not strictly positive.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* BitmapDebug available on flash10+ only.
 * <br/><br/>
 * This debug draw makes use of Alchemy opcodes so you may wish to forgo it
 * if you do not want to be subjcet to Adobe licensing rules should you also
 * be using Stage3D.
 * <br/><br/>
 * This debug draw draws things pixel by pixel into alchemy memory, flushing
 * to a BitmapData object. Believe it or not, this is in almost all cases
 * 'faster' than flash's built in graphics API.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="nape.util.ShapeDebug" params="" file="libSrc/napeLib/nape/util/ShapeDebug.hx">
		<extends path="nape.util.Debug"/>
		<drawSpring public="1" set="method" line="1223" override="1"><f a="start:end:colour:?coils:?radius">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawSpring>
		<draw public="1" set="method" line="1190" override="1"><f a="object">
	<d/>
	<x path="Void"/>
</f></draw>
		<drawFilledPolygon public="1" set="method" line="874" override="1"><f a="polygon:colour">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawFilledPolygon>
		<drawPolygon public="1" set="method" line="560" override="1"><f a="polygon:colour">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawPolygon>
		<drawFilledCircle public="1" set="method" line="520" override="1"><f a="position:radius:colour">
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawFilledCircle>
		<drawFilledTriangle public="1" set="method" line="441" override="1"><f a="p0:p1:p2:colour">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawFilledTriangle>
		<drawAABB public="1" set="method" line="410" override="1"><f a="aabb:colour">
	<c path="nape.geom.AABB"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawAABB>
		<drawCircle public="1" set="method" line="372" override="1"><f a="position:radius:colour">
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawCircle>
		<drawCurve public="1" set="method" line="295" override="1"><f a="start:control:end:colour">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawCurve>
		<drawLine public="1" set="method" line="237" override="1"><f a="start:end:colour">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawLine>
		<clear public="1" set="method" line="231" override="1"><f a=""><x path="Void"/></f></clear>
		<thickness public="1">
			<x path="Float"/>
			<haxe_doc>* Thickness to draw lines with.
     * @default 0.1</haxe_doc>
		</thickness>
		<zpp_inner_zn public="1">
			<c path="zpp_nape.util.ZPP_ShapeDebug"/>
			<haxe_doc>* @private</haxe_doc>
		</zpp_inner_zn>
		<new public="1" set="method" line="207">
			<f a="width:height:?bgColour">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Construct new ShapeDebug with given viewport size and backgruond.
     * <br/><br/>
     * Background colour does not have much weight for a ShapeDebug which
     * always has a transparent background, but serves to bias the colours
     * chosen for drawing objects.
     *
     * @param width The width of Debug draw viewport.
     * @param height The height of Debug draw viewport.
     * @param bgColour the background colour for debug draw. (default 0x333333)
     * @return The constructed ShapeDebug.
     * @throws # If width or height are not strictly positive.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Implementation of nape debug draw using flash/nme graphics API.
 * <br/><br/>
 * This debug draw is slower than BitmapDebug which is available in flash10+
 * however the BitmapDebug draw makes use of Alchemy opcodes so you may wish
 * not to use it if you are also using Stage3D and do not wish to be subject
 * to Adobe licensing.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="starling.animation.DelayedCall" params="" file="lib/starling.swc@starling.animation.DelayedCall" extern="1">
		<extends path="starling.events.EventDispatcher"/>
		<implements path="starling.animation.IAnimatable"/>
		<reset public="1" set="method"><f a="call:delay:?args">
	<t path="flash.utils.Function"/>
	<x path="Float"/>
	<c path="Array"><d/></c>
	<c path="starling.animation.DelayedCall"/>
</f></reset>
		<advanceTime public="1" set="method"><f a="time">
	<x path="Float"/>
	<x path="Void"/>
</f></advanceTime>
		<currentTime public="1" set="null"><x path="Float"/></currentTime>
		<isComplete public="1" set="null"><x path="Bool"/></isComplete>
		<repeatCount public="1"><x path="Int"/></repeatCount>
		<totalTime public="1" set="null"><x path="Float"/></totalTime>
		<new public="1" set="method"><f a="call:delay:?args">
	<d/>
	<x path="Float"/>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></new>
	</class>
	<class path="starling.animation.Juggler" params="" file="lib/starling.swc@starling.animation.Juggler" extern="1">
		<implements path="starling.animation.IAnimatable"/>
		<add public="1" set="method"><f a="object">
	<c path="starling.animation.IAnimatable"/>
	<x path="Void"/>
</f></add>
		<contains public="1" set="method"><f a="object">
	<c path="starling.animation.IAnimatable"/>
	<x path="Bool"/>
</f></contains>
		<remove public="1" set="method"><f a="object">
	<c path="starling.animation.IAnimatable"/>
	<x path="Void"/>
</f></remove>
		<removeTweens public="1" set="method"><f a="target">
	<t path="flash.utils.Object"/>
	<x path="Void"/>
</f></removeTweens>
		<containsTweens public="1" set="method"><f a="target">
	<t path="flash.utils.Object"/>
	<x path="Bool"/>
</f></containsTweens>
		<purge public="1" set="method"><f a=""><x path="Void"/></f></purge>
		<delayCall public="1" set="method"><f a="call:delay:?p1:?p2:?p3:?p4:?p5">
	<t path="flash.utils.Function"/>
	<x path="Float"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="starling.animation.DelayedCall"/>
</f></delayCall>
		<tween public="1" set="method"><f a="target:time:properties">
	<t path="flash.utils.Object"/>
	<x path="Float"/>
	<t path="flash.utils.Object"/>
	<x path="Void"/>
</f></tween>
		<advanceTime public="1" set="method"><f a="time">
	<x path="Float"/>
	<x path="Void"/>
</f></advanceTime>
		<elapsedTime public="1" set="null"><x path="Float"/></elapsedTime>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="starling.core.RenderSupport" params="" file="lib/starling.swc@starling.core.RenderSupport" extern="1">
		<assembleAgal public="1" set="method" static="1"><f a="vertexShader:fragmentShader:?resultProgram">
	<c path="String"/>
	<c path="String"/>
	<c path="flash.display3D.Program3D"/>
	<c path="flash.display3D.Program3D"/>
</f></assembleAgal>
		<clear public="1" set="method" static="1">
			<f a="?rgb:?alpha">
				<x path="UInt"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":defParam">
					<e>"alpha"</e>
					<e>0.</e>
				</m>
				<m n=":defParam">
					<e>"rgb"</e>
					<e>0</e>
				</m>
			</meta>
		</clear>
		<setBlendFactors public="1" set="method" static="1"><f a="premultipliedAlpha:?blendMode">
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></setBlendFactors>
		<setDefaultBlendFactors public="1" set="method" static="1"><f a="premultipliedAlpha">
	<x path="Bool"/>
	<x path="Void"/>
</f></setDefaultBlendFactors>
		<transformMatrixForObject public="1" set="method" static="1"><f a="matrix:object">
	<c path="flash.geom.Matrix"/>
	<c path="starling.display.DisplayObject"/>
	<x path="Void"/>
</f></transformMatrixForObject>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<setOrthographicProjection public="1" set="method"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setOrthographicProjection>
		<loadIdentity public="1" set="method"><f a=""><x path="Void"/></f></loadIdentity>
		<translateMatrix public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translateMatrix>
		<rotateMatrix public="1" set="method"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></rotateMatrix>
		<scaleMatrix public="1" set="method"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scaleMatrix>
		<prependMatrix public="1" set="method"><f a="matrix">
	<c path="flash.geom.Matrix"/>
	<x path="Void"/>
</f></prependMatrix>
		<transformMatrix public="1" set="method"><f a="object">
	<c path="starling.display.DisplayObject"/>
	<x path="Void"/>
</f></transformMatrix>
		<pushMatrix public="1" set="method"><f a=""><x path="Void"/></f></pushMatrix>
		<popMatrix public="1" set="method"><f a=""><x path="Void"/></f></popMatrix>
		<resetMatrix public="1" set="method"><f a=""><x path="Void"/></f></resetMatrix>
		<applyBlendMode public="1" set="method"><f a="premultipliedAlpha">
	<x path="Bool"/>
	<x path="Void"/>
</f></applyBlendMode>
		<configureBackBuffer public="1" set="method">
			<f a="width:height:antiAlias:enableDepthAndStencil:?wantsBestResolution">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":defParam">
	<e>"wantsBestResolution"</e>
	<e>false</e>
</m></meta>
		</configureBackBuffer>
		<pushClipRect public="1" set="method"><f a="rectangle">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></pushClipRect>
		<popClipRect public="1" set="method"><f a=""><x path="Void"/></f></popClipRect>
		<applyClipRect public="1" set="method"><f a=""><x path="Void"/></f></applyClipRect>
		<batchQuad public="1" set="method"><f a="quad:parentAlpha:?texture:?smoothing">
	<c path="starling.display.Quad"/>
	<x path="Float"/>
	<c path="starling.textures.Texture"/>
	<c path="String"/>
	<x path="Void"/>
</f></batchQuad>
		<finishQuadBatch public="1" set="method"><f a=""><x path="Void"/></f></finishQuadBatch>
		<nextFrame public="1" set="method"><f a=""><x path="Void"/></f></nextFrame>
		<raiseDrawCount public="1" set="method">
			<f a="?value">
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":defParam">
	<e>"value"</e>
	<e>1</e>
</m></meta>
		</raiseDrawCount>
		<mvpMatrix public="1" set="null"><c path="flash.geom.Matrix"/></mvpMatrix>
		<renderTarget public="1"><c path="starling.textures.Texture"/></renderTarget>
		<projectionMatrix public="1"><c path="flash.geom.Matrix"/></projectionMatrix>
		<backBufferHeight public="1"><x path="Int"/></backBufferHeight>
		<modelViewMatrix public="1" set="null"><c path="flash.geom.Matrix"/></modelViewMatrix>
		<mvpMatrix3D public="1" set="null"><c path="flash.geom.Matrix3D"/></mvpMatrix3D>
		<drawCount public="1" set="null"><x path="Int"/></drawCount>
		<backBufferWidth public="1"><x path="Int"/></backBufferWidth>
		<blendMode public="1"><c path="String"/></blendMode>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="starling.core.Starling" params="" file="lib/starling.swc@starling.core.Starling" extern="1">
		<extends path="starling.events.EventDispatcher"/>
		<context public="1" set="null" static="1"><c path="flash.display3D.Context3D"/></context>
		<current public="1" set="null" static="1"><c path="starling.core.Starling"/></current>
		<contentScaleFactor public="1" set="null" static="1"><x path="Float"/></contentScaleFactor>
		<juggler public="1" set="null" static="1"><c path="starling.animation.Juggler"/></juggler>
		<handleLostContext public="1" static="1"><x path="Bool"/></handleLostContext>
		<multitouchEnabled public="1" static="1"><x path="Bool"/></multitouchEnabled>
		<VERSION public="1" static="1"><c path="String"/></VERSION>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<nextFrame public="1" set="method"><f a=""><x path="Void"/></f></nextFrame>
		<advanceTime public="1" set="method"><f a="passedTime">
	<x path="Float"/>
	<x path="Void"/>
</f></advanceTime>
		<render public="1" set="method"><f a=""><x path="Void"/></f></render>
		<makeCurrent public="1" set="method"><f a=""><x path="Void"/></f></makeCurrent>
		<start public="1" set="method"><f a=""><x path="Void"/></f></start>
		<stop public="1" set="method"><f a=""><x path="Void"/></f></stop>
		<registerProgram public="1" set="method"><f a="name:vertexProgram:fragmentProgram">
	<c path="String"/>
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
	<c path="flash.display3D.Program3D"/>
</f></registerProgram>
		<deleteProgram public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></deleteProgram>
		<getProgram public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="flash.display3D.Program3D"/>
</f></getProgram>
		<hasProgram public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasProgram>
		<showStatsAt public="1" set="method">
			<f a="?hAlign:?vAlign:?scale">
				<c path="String"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":defParam">
	<e>"scale"</e>
	<e>1</e>
</m></meta>
		</showStatsAt>
		<isStarted public="1" set="null"><x path="Bool"/></isStarted>
		<nativeStage public="1" set="null"><c path="flash.display.Stage"/></nativeStage>
		<stage3D public="1" set="null"><c path="flash.display.Stage3D"/></stage3D>
		<antiAliasing public="1"><x path="Int"/></antiAliasing>
		<nativeOverlay public="1" set="null"><c path="flash.display.Sprite"/></nativeOverlay>
		<root public="1" set="null"><c path="starling.display.DisplayObject"/></root>
		<supportHighResolutions public="1"><x path="Bool"/></supportHighResolutions>
		<stage public="1" set="null"><c path="starling.display.Stage"/></stage>
		<simulateMultitouch public="1"><x path="Bool"/></simulateMultitouch>
		<contextData public="1" set="null"><c path="flash.utils.Dictionary"/></contextData>
		<enableErrorChecking public="1"><x path="Bool"/></enableErrorChecking>
		<profile public="1" set="null"><c path="String"/></profile>
		<showStats public="1"><x path="Bool"/></showStats>
		<viewPort public="1"><c path="flash.geom.Rectangle"/></viewPort>
		<shareContext public="1"><x path="Bool"/></shareContext>
		<new public="1" set="method"><f a="rootClass:stage:?viewPort:?stage3D:?renderMode:?profile">
	<x path="Class"><d/></x>
	<c path="flash.display.Stage"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.display.Stage3D"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="starling.display.Quad" params="" file="lib/starling.swc@starling.display.Quad" extern="1">
		<extends path="starling.display.DisplayObject"/>
		<mVertexData>
			<c path="starling.utils.VertexData"/>
			<meta><m n=":protected"/></meta>
		</mVertexData>
		<onVertexDataChanged set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</onVertexDataChanged>
		<getVertexColor public="1" set="method"><f a="vertexID">
	<x path="Int"/>
	<x path="UInt"/>
</f></getVertexColor>
		<setVertexColor public="1" set="method"><f a="vertexID:color">
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setVertexColor>
		<getVertexAlpha public="1" set="method"><f a="vertexID">
	<x path="Int"/>
	<x path="Float"/>
</f></getVertexAlpha>
		<setVertexAlpha public="1" set="method"><f a="vertexID:alpha">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVertexAlpha>
		<copyVertexDataTo public="1" set="method">
			<f a="targetData:?targetVertexID">
				<c path="starling.utils.VertexData"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":defParam">
	<e>"targetVertexID"</e>
	<e>0</e>
</m></meta>
		</copyVertexDataTo>
		<premultipliedAlpha public="1" set="null"><x path="Bool"/></premultipliedAlpha>
		<tinted public="1" set="null"><x path="Bool"/></tinted>
		<color public="1"><x path="UInt"/></color>
		<new public="1" set="method">
			<f a="width:height:?color:?premultipliedAlpha">
				<x path="Float"/>
				<x path="Float"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":defParam">
					<e>"premultipliedAlpha"</e>
					<e>true</e>
				</m>
				<m n=":defParam">
					<e>"color"</e>
					<e>16777215</e>
				</m>
			</meta>
		</new>
	</class>
	<class path="starling.display.Image" params="" file="lib/starling.swc@starling.display.Image" extern="1">
		<extends path="starling.display.Quad"/>
		<fromBitmap public="1" set="method" static="1">
			<f a="bitmap:?generateMipMaps:?scale">
				<c path="flash.display.Bitmap"/>
				<x path="Bool"/>
				<x path="Float"/>
				<c path="starling.display.Image"/>
			</f>
			<meta>
				<m n=":defParam">
					<e>"scale"</e>
					<e>1</e>
				</m>
				<m n=":defParam">
					<e>"generateMipMaps"</e>
					<e>true</e>
				</m>
			</meta>
		</fromBitmap>
		<readjustSize public="1" set="method"><f a=""><x path="Void"/></f></readjustSize>
		<setTexCoords public="1" set="method"><f a="vertexID:coords">
	<x path="Int"/>
	<c path="flash.geom.Point"/>
	<x path="Void"/>
</f></setTexCoords>
		<getTexCoords public="1" set="method"><f a="vertexID:?resultPoint">
	<x path="Int"/>
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></getTexCoords>
		<smoothing public="1"><c path="String"/></smoothing>
		<texture public="1"><c path="starling.textures.Texture"/></texture>
		<new public="1" set="method"><f a="texture">
	<c path="starling.textures.Texture"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="starling.display.QuadBatch" params="" file="lib/starling.swc@starling.display.QuadBatch" extern="1">
		<extends path="starling.display.DisplayObject"/>
		<compile public="1" set="method" static="1"><f a="object:quadBatches">
	<c path="starling.display.DisplayObject"/>
	<c path="flash.Vector"><c path="starling.display.QuadBatch"/></c>
	<x path="Void"/>
</f></compile>
		<clone public="1" set="method"><f a=""><c path="starling.display.QuadBatch"/></f></clone>
		<renderCustom public="1" set="method">
			<f a="mvpMatrix:?parentAlpha:?blendMode">
				<c path="flash.geom.Matrix"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":defParam">
	<e>"parentAlpha"</e>
	<e>1.</e>
</m></meta>
		</renderCustom>
		<reset public="1" set="method"><f a=""><x path="Void"/></f></reset>
		<addImage public="1" set="method">
			<f a="image:?parentAlpha:?modelViewMatrix:?blendMode">
				<c path="starling.display.Image"/>
				<x path="Float"/>
				<c path="flash.geom.Matrix"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":defParam">
	<e>"parentAlpha"</e>
	<e>1.</e>
</m></meta>
		</addImage>
		<addQuad public="1" set="method">
			<f a="quad:?parentAlpha:?texture:?smoothing:?modelViewMatrix:?blendMode">
				<c path="starling.display.Quad"/>
				<x path="Float"/>
				<c path="starling.textures.Texture"/>
				<c path="String"/>
				<c path="flash.geom.Matrix"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":defParam">
	<e>"parentAlpha"</e>
	<e>1.</e>
</m></meta>
		</addQuad>
		<addQuadBatch public="1" set="method">
			<f a="quadBatch:?parentAlpha:?modelViewMatrix:?blendMode">
				<c path="starling.display.QuadBatch"/>
				<x path="Float"/>
				<c path="flash.geom.Matrix"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":defParam">
	<e>"parentAlpha"</e>
	<e>1.</e>
</m></meta>
		</addQuadBatch>
		<isStateChange public="1" set="method">
			<f a="tinted:parentAlpha:texture:smoothing:blendMode:?numQuads">
				<x path="Bool"/>
				<x path="Float"/>
				<c path="starling.textures.Texture"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":defParam">
	<e>"numQuads"</e>
	<e>1</e>
</m></meta>
		</isStateChange>
		<premultipliedAlpha public="1" set="null"><x path="Bool"/></premultipliedAlpha>
		<smoothing public="1" set="null"><c path="String"/></smoothing>
		<texture public="1" set="null"><c path="starling.textures.Texture"/></texture>
		<tinted public="1" set="null"><x path="Bool"/></tinted>
		<numQuads public="1" set="null"><x path="Int"/></numQuads>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="starling.display.Stage" params="" file="lib/starling.swc@starling.display.Stage" extern="1">
		<extends path="starling.display.DisplayObjectContainer"/>
		<advanceTime public="1" set="method"><f a="passedTime">
	<x path="Float"/>
	<x path="Void"/>
</f></advanceTime>
		<stageWidth public="1"><x path="Int"/></stageWidth>
		<color public="1"><x path="UInt"/></color>
		<stageHeight public="1"><x path="Int"/></stageHeight>
		<new public="1" set="method">
			<f a="width:height:?color">
				<x path="Int"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":defParam">
	<e>"color"</e>
	<e>0</e>
</m></meta>
		</new>
	</class>
	<class path="starling.events.Event" params="" file="lib/starling.swc@starling.events.Event" extern="1">
		<toPool public="1" set="method" static="1"><f a="event">
	<c path="starling.events.Event"/>
	<x path="Void"/>
</f></toPool>
		<fromPool public="1" set="method" static="1">
			<f a="type:?bubbles:?data">
				<c path="String"/>
				<x path="Bool"/>
				<d/>
				<c path="starling.events.Event"/>
			</f>
			<meta><m n=":defParam">
	<e>"bubbles"</e>
	<e>false</e>
</m></meta>
		</fromPool>
		<SELECT public="1" static="1"><c path="String"/></SELECT>
		<CLOSE public="1" static="1"><c path="String"/></CLOSE>
		<OPEN public="1" static="1"><c path="String"/></OPEN>
		<SCROLL public="1" static="1"><c path="String"/></SCROLL>
		<CANCEL public="1" static="1"><c path="String"/></CANCEL>
		<CHANGE public="1" static="1"><c path="String"/></CHANGE>
		<REMOVE_FROM_JUGGLER public="1" static="1"><c path="String"/></REMOVE_FROM_JUGGLER>
		<ROOT_CREATED public="1" static="1"><c path="String"/></ROOT_CREATED>
		<CONTEXT3D_CREATE public="1" static="1"><c path="String"/></CONTEXT3D_CREATE>
		<COMPLETE public="1" static="1"><c path="String"/></COMPLETE>
		<RESIZE public="1" static="1"><c path="String"/></RESIZE>
		<FLATTEN public="1" static="1"><c path="String"/></FLATTEN>
		<TRIGGERED public="1" static="1"><c path="String"/></TRIGGERED>
		<REMOVED_FROM_STAGE public="1" static="1"><c path="String"/></REMOVED_FROM_STAGE>
		<REMOVED public="1" static="1"><c path="String"/></REMOVED>
		<ENTER_FRAME public="1" static="1"><c path="String"/></ENTER_FRAME>
		<ADDED_TO_STAGE public="1" static="1"><c path="String"/></ADDED_TO_STAGE>
		<ADDED public="1" static="1"><c path="String"/></ADDED>
		<stopPropagation public="1" set="method"><f a=""><x path="Void"/></f></stopPropagation>
		<stopImmediatePropagation public="1" set="method"><f a=""><x path="Void"/></f></stopImmediatePropagation>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<setTarget public="1" set="method"><f a="value">
	<c path="starling.events.EventDispatcher"/>
	<x path="Void"/>
</f></setTarget>
		<setCurrentTarget public="1" set="method"><f a="value">
	<c path="starling.events.EventDispatcher"/>
	<x path="Void"/>
</f></setCurrentTarget>
		<setData public="1" set="method"><f a="value">
	<t path="flash.utils.Object"/>
	<x path="Void"/>
</f></setData>
		<reset public="1" set="method">
			<f a="type:?bubbles:?data">
				<c path="String"/>
				<x path="Bool"/>
				<t path="flash.utils.Object"/>
				<c path="starling.events.Event"/>
			</f>
			<meta><m n=":defParam">
	<e>"bubbles"</e>
	<e>false</e>
</m></meta>
		</reset>
		<stopsPropagation public="1" set="null"><x path="Bool"/></stopsPropagation>
		<type public="1" set="null"><c path="String"/></type>
		<stopsImmediatePropagation public="1" set="null"><x path="Bool"/></stopsImmediatePropagation>
		<target public="1" set="null"><c path="starling.events.EventDispatcher"/></target>
		<currentTarget public="1" set="null"><c path="starling.events.EventDispatcher"/></currentTarget>
		<data public="1" set="null"><d/></data>
		<bubbles public="1" set="null"><x path="Bool"/></bubbles>
		<new public="1" set="method">
			<f a="type:?bubbles:?data">
				<c path="String"/>
				<x path="Bool"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":defParam">
	<e>"bubbles"</e>
	<e>false</e>
</m></meta>
		</new>
	</class>
	<class path="starling.filters.FragmentFilter" params="" file="lib/starling.swc@starling.filters.FragmentFilter" extern="1">
		<PMA>
			<x path="Bool"/>
			<meta><m n=":protected"/></meta>
		</PMA>
		<STD_VERTEX_SHADER>
			<c path="String"/>
			<meta><m n=":protected"/></meta>
		</STD_VERTEX_SHADER>
		<STD_FRAGMENT_SHADER>
			<c path="String"/>
			<meta><m n=":protected"/></meta>
		</STD_FRAGMENT_SHADER>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<render public="1" set="method"><f a="object:support:parentAlpha">
	<c path="starling.display.DisplayObject"/>
	<c path="starling.core.RenderSupport"/>
	<x path="Float"/>
	<x path="Void"/>
</f></render>
		<createPrograms set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":protected"/></meta>
		</createPrograms>
		<activate set="method">
			<f a="pass:context:texture">
				<x path="Int"/>
				<c path="flash.display3D.Context3D"/>
				<c path="starling.textures.Texture"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</activate>
		<deactivate set="method">
			<f a="pass:context:texture">
				<x path="Int"/>
				<c path="flash.display3D.Context3D"/>
				<c path="starling.textures.Texture"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</deactivate>
		<assembleAgal set="method">
			<f a="?fragmentShader:?vertexShader">
				<c path="String"/>
				<c path="String"/>
				<c path="flash.display3D.Program3D"/>
			</f>
			<meta><m n=":protected"/></meta>
		</assembleAgal>
		<cache public="1" set="method"><f a=""><x path="Void"/></f></cache>
		<clearCache public="1" set="method"><f a=""><x path="Void"/></f></clearCache>
		<compile public="1" set="method"><f a="object">
	<c path="starling.display.DisplayObject"/>
	<c path="starling.display.QuadBatch"/>
</f></compile>
		<baseTextureID public="1"><x path="Int"/></baseTextureID>
		<vertexPosAtID public="1"><x path="Int"/></vertexPosAtID>
		<mvpConstantID public="1"><x path="Int"/></mvpConstantID>
		<marginX public="1"><x path="Float"/></marginX>
		<isCached public="1" set="null"><x path="Bool"/></isCached>
		<texCoordsAtID public="1"><x path="Int"/></texCoordsAtID>
		<marginY public="1"><x path="Float"/></marginY>
		<numPasses public="1"><x path="Int"/></numPasses>
		<offsetX public="1"><x path="Float"/></offsetX>
		<mode public="1"><c path="String"/></mode>
		<resolution public="1"><x path="Float"/></resolution>
		<offsetY public="1"><x path="Float"/></offsetY>
		<new public="1" set="method">
			<f a="?numPasses:?resolution">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":defParam">
					<e>"resolution"</e>
					<e>1.</e>
				</m>
				<m n=":defParam">
					<e>"numPasses"</e>
					<e>1</e>
				</m>
			</meta>
		</new>
	</class>
	<class path="starling.text.BitmapChar" params="" file="lib/starling.swc@starling.text.BitmapChar" extern="1">
		<addKerning public="1" set="method"><f a="charID:amount">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addKerning>
		<getKerning public="1" set="method"><f a="charID">
	<x path="Int"/>
	<x path="Float"/>
</f></getKerning>
		<createImage public="1" set="method"><f a=""><c path="starling.display.Image"/></f></createImage>
		<height public="1" set="null"><x path="Float"/></height>
		<xAdvance public="1" set="null"><x path="Float"/></xAdvance>
		<xOffset public="1" set="null"><x path="Float"/></xOffset>
		<charID public="1" set="null"><x path="Int"/></charID>
		<yOffset public="1" set="null"><x path="Float"/></yOffset>
		<texture public="1" set="null"><c path="starling.textures.Texture"/></texture>
		<width public="1" set="null"><x path="Float"/></width>
		<new public="1" set="method"><f a="id:texture:xOffset:yOffset:xAdvance">
	<x path="Int"/>
	<c path="starling.textures.Texture"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="starling.text.BitmapFont" params="" file="lib/starling.swc@starling.text.BitmapFont" extern="1">
		<MINI public="1" static="1"><c path="String"/></MINI>
		<NATIVE_SIZE public="1" static="1"><x path="Int"/></NATIVE_SIZE>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<getChar public="1" set="method"><f a="charID">
	<x path="Int"/>
	<c path="starling.text.BitmapChar"/>
</f></getChar>
		<addChar public="1" set="method"><f a="charID:bitmapChar">
	<x path="Int"/>
	<c path="starling.text.BitmapChar"/>
	<x path="Void"/>
</f></addChar>
		<createSprite public="1" set="method">
			<f a="width:height:text:?fontSize:?color:?hAlign:?vAlign:?autoScale:?kerning">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="UInt"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="starling.display.Sprite"/>
			</f>
			<meta>
				<m n=":defParam">
					<e>"kerning"</e>
					<e>true</e>
				</m>
				<m n=":defParam">
					<e>"autoScale"</e>
					<e>true</e>
				</m>
				<m n=":defParam">
					<e>"color"</e>
					<e>16777215</e>
				</m>
				<m n=":defParam">
					<e>"fontSize"</e>
					<e>-1</e>
				</m>
			</meta>
		</createSprite>
		<fillQuadBatch public="1" set="method">
			<f a="quadBatch:width:height:text:?fontSize:?color:?hAlign:?vAlign:?autoScale:?kerning">
				<c path="starling.display.QuadBatch"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="UInt"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":defParam">
					<e>"kerning"</e>
					<e>true</e>
				</m>
				<m n=":defParam">
					<e>"autoScale"</e>
					<e>true</e>
				</m>
				<m n=":defParam">
					<e>"color"</e>
					<e>16777215</e>
				</m>
				<m n=":defParam">
					<e>"fontSize"</e>
					<e>-1</e>
				</m>
			</meta>
		</fillQuadBatch>
		<smoothing public="1"><c path="String"/></smoothing>
		<name public="1" set="null"><c path="String"/></name>
		<lineHeight public="1"><x path="Float"/></lineHeight>
		<baseline public="1" set="null"><x path="Float"/></baseline>
		<size public="1" set="null"><x path="Float"/></size>
		<new public="1" set="method"><f a="?texture:?fontXml">
	<c path="starling.textures.Texture"/>
	<c path="flash.xml.XML"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="starling.text.TextField" params="" file="lib/starling.swc@starling.text.TextField" extern="1">
		<extends path="starling.display.DisplayObjectContainer"/>
		<getBitmapFont public="1" set="method" static="1"><f a="name">
	<c path="String"/>
	<c path="starling.text.BitmapFont"/>
</f></getBitmapFont>
		<unregisterBitmapFont public="1" set="method" static="1">
			<f a="name:?dispose">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":defParam">
	<e>"dispose"</e>
	<e>true</e>
</m></meta>
		</unregisterBitmapFont>
		<registerBitmapFont public="1" set="method" static="1"><f a="bitmapFont:?name">
	<c path="starling.text.BitmapFont"/>
	<c path="String"/>
	<c path="String"/>
</f></registerBitmapFont>
		<redraw public="1" set="method"><f a=""><x path="Void"/></f></redraw>
		<formatText set="method">
			<f a="textField:textFormat">
				<c path="flash.text.TextField"/>
				<c path="flash.text.TextFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</formatText>
		<bold public="1"><x path="Bool"/></bold>
		<fontSize public="1"><x path="Float"/></fontSize>
		<kerning public="1"><x path="Bool"/></kerning>
		<textBounds public="1" set="null"><c path="flash.geom.Rectangle"/></textBounds>
		<border public="1"><x path="Bool"/></border>
		<underline public="1"><x path="Bool"/></underline>
		<autoScale public="1"><x path="Bool"/></autoScale>
		<text public="1"><c path="String"/></text>
		<italic public="1"><x path="Bool"/></italic>
		<vAlign public="1"><c path="String"/></vAlign>
		<autoSize public="1"><c path="String"/></autoSize>
		<color public="1"><x path="UInt"/></color>
		<hAlign public="1"><c path="String"/></hAlign>
		<nativeFilters public="1"><c path="Array"><d/></c></nativeFilters>
		<fontName public="1"><c path="String"/></fontName>
		<new public="1" set="method">
			<f a="width:height:text:?fontName:?fontSize:?color:?bold">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":defParam">
					<e>"bold"</e>
					<e>false</e>
				</m>
				<m n=":defParam">
					<e>"color"</e>
					<e>0</e>
				</m>
				<m n=":defParam">
					<e>"fontSize"</e>
					<e>12</e>
				</m>
			</meta>
		</new>
	</class>
	<class path="starling.textures.Texture" params="" file="lib/starling.swc@starling.textures.Texture" extern="1">
		<uploadAtfData public="1" set="method" static="1">
			<f a="nativeTexture:data:?offset:?async">
				<c path="flash.display3D.textures.Texture"/>
				<c path="flash.utils.ByteArray"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":defParam">
					<e>"async"</e>
					<e>false</e>
				</m>
				<m n=":defParam">
					<e>"offset"</e>
					<e>0</e>
				</m>
			</meta>
		</uploadAtfData>
		<uploadBitmapData public="1" set="method" static="1"><f a="nativeTexture:data:generateMipmaps">
	<c path="flash.display3D.textures.Texture"/>
	<c path="flash.display.BitmapData"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></uploadBitmapData>
		<fromTexture public="1" set="method" static="1"><f a="texture:?region:?frame">
	<c path="starling.textures.Texture"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
	<c path="starling.textures.Texture"/>
</f></fromTexture>
		<empty public="1" set="method" static="1">
			<f a="?width:?height:?premultipliedAlpha:?optimizeForRenderToTexture:?scale">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Float"/>
				<c path="starling.textures.Texture"/>
			</f>
			<meta>
				<m n=":defParam">
					<e>"scale"</e>
					<e>-1</e>
				</m>
				<m n=":defParam">
					<e>"optimizeForRenderToTexture"</e>
					<e>true</e>
				</m>
				<m n=":defParam">
					<e>"premultipliedAlpha"</e>
					<e>false</e>
				</m>
				<m n=":defParam">
					<e>"height"</e>
					<e>64</e>
				</m>
				<m n=":defParam">
					<e>"width"</e>
					<e>64</e>
				</m>
			</meta>
		</empty>
		<fromColor public="1" set="method" static="1">
			<f a="width:height:?color:?optimizeForRenderToTexture:?scale">
				<x path="Int"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Float"/>
				<c path="starling.textures.Texture"/>
			</f>
			<meta>
				<m n=":defParam">
					<e>"scale"</e>
					<e>-1</e>
				</m>
				<m n=":defParam">
					<e>"optimizeForRenderToTexture"</e>
					<e>false</e>
				</m>
				<m n=":defParam">
					<e>"color"</e>
					<e>4294967295.</e>
				</m>
			</meta>
		</fromColor>
		<fromAtfData public="1" set="method" static="1">
			<f a="data:?scale:?useMipMaps:?loadAsync">
				<c path="flash.utils.ByteArray"/>
				<x path="Float"/>
				<x path="Bool"/>
				<d/>
				<c path="starling.textures.Texture"/>
			</f>
			<meta>
				<m n=":defParam">
					<e>"useMipMaps"</e>
					<e>true</e>
				</m>
				<m n=":defParam">
					<e>"scale"</e>
					<e>1</e>
				</m>
			</meta>
		</fromAtfData>
		<fromBitmapData public="1" set="method" static="1">
			<f a="data:?generateMipMaps:?optimizeForRenderToTexture:?scale">
				<c path="flash.display.BitmapData"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Float"/>
				<c path="starling.textures.Texture"/>
			</f>
			<meta>
				<m n=":defParam">
					<e>"scale"</e>
					<e>1</e>
				</m>
				<m n=":defParam">
					<e>"optimizeForRenderToTexture"</e>
					<e>false</e>
				</m>
				<m n=":defParam">
					<e>"generateMipMaps"</e>
					<e>true</e>
				</m>
			</meta>
		</fromBitmapData>
		<fromBitmap public="1" set="method" static="1">
			<f a="data:?generateMipMaps:?optimizeForRenderToTexture:?scale">
				<c path="flash.display.Bitmap"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Float"/>
				<c path="starling.textures.Texture"/>
			</f>
			<meta>
				<m n=":defParam">
					<e>"scale"</e>
					<e>1</e>
				</m>
				<m n=":defParam">
					<e>"optimizeForRenderToTexture"</e>
					<e>false</e>
				</m>
				<m n=":defParam">
					<e>"generateMipMaps"</e>
					<e>true</e>
				</m>
			</meta>
		</fromBitmap>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<adjustVertexData public="1" set="method"><f a="vertexData:vertexID:count">
	<c path="starling.utils.VertexData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></adjustVertexData>
		<root public="1" set="null"><c path="starling.textures.ConcreteTexture"/></root>
		<base public="1" set="null"><c path="flash.display3D.textures.TextureBase"/></base>
		<nativeHeight public="1" set="null"><x path="Float"/></nativeHeight>
		<height public="1" set="null"><x path="Float"/></height>
		<format public="1" set="null"><c path="String"/></format>
		<repeat public="1"><x path="Bool"/></repeat>
		<nativeWidth public="1" set="null"><x path="Float"/></nativeWidth>
		<mipMapping public="1" set="null"><x path="Bool"/></mipMapping>
		<frame public="1" set="null"><c path="flash.geom.Rectangle"/></frame>
		<scale public="1" set="null"><x path="Float"/></scale>
		<premultipliedAlpha public="1" set="null"><x path="Bool"/></premultipliedAlpha>
		<width public="1" set="null"><x path="Float"/></width>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="starling.textures.ConcreteTexture" params="" file="lib/starling.swc@starling.textures.ConcreteTexture" extern="1">
		<extends path="starling.textures.Texture"/>
		<restoreOnLostContext public="1" set="method"><f a="data">
	<t path="flash.utils.Object"/>
	<x path="Void"/>
</f></restoreOnLostContext>
		<optimizedForRenderTexture public="1" set="null"><x path="Bool"/></optimizedForRenderTexture>
		<new public="1" set="method">
			<f a="base:format:width:height:mipMapping:premultipliedAlpha:?optimizedForRenderTexture:?scale">
				<c path="flash.display3D.textures.TextureBase"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":defParam">
					<e>"scale"</e>
					<e>1</e>
				</m>
				<m n=":defParam">
					<e>"optimizedForRenderTexture"</e>
					<e>false</e>
				</m>
			</meta>
		</new>
	</class>
	<class path="starling.textures.TextureAtlas" params="" file="lib/starling.swc@starling.textures.TextureAtlas" extern="1">
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<parseAtlasXml set="method">
			<f a="atlasXml">
				<c path="flash.xml.XML"/>
				<x path="Void"/>
			</f>
			<meta><m n=":protected"/></meta>
		</parseAtlasXml>
		<getTexture public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="starling.textures.Texture"/>
</f></getTexture>
		<getTextures public="1" set="method"><f a="?prefix:?result">
	<c path="String"/>
	<c path="flash.Vector"><c path="starling.textures.Texture"/></c>
	<c path="flash.Vector"><c path="starling.textures.Texture"/></c>
</f></getTextures>
		<getNames public="1" set="method"><f a="?prefix:?result">
	<c path="String"/>
	<c path="flash.Vector"><c path="String"/></c>
	<c path="flash.Vector"><c path="String"/></c>
</f></getNames>
		<getRegion public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="flash.geom.Rectangle"/>
</f></getRegion>
		<getFrame public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="flash.geom.Rectangle"/>
</f></getFrame>
		<addRegion public="1" set="method"><f a="name:region:?frame">
	<c path="String"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></addRegion>
		<removeRegion public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></removeRegion>
		<texture public="1" set="null"><c path="starling.textures.Texture"/></texture>
		<new public="1" set="method"><f a="texture:?atlasXml">
	<c path="starling.textures.Texture"/>
	<c path="flash.xml.XML"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="starling.utils.Color" params="" file="lib/starling.swc@starling.utils.Color" extern="1">
		<argb public="1" set="method" static="1"><f a="alpha:red:green:blue">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
</f></argb>
		<rgb public="1" set="method" static="1"><f a="red:green:blue">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
</f></rgb>
		<getBlue public="1" set="method" static="1"><f a="color">
	<x path="UInt"/>
	<x path="Int"/>
</f></getBlue>
		<getGreen public="1" set="method" static="1"><f a="color">
	<x path="UInt"/>
	<x path="Int"/>
</f></getGreen>
		<getRed public="1" set="method" static="1"><f a="color">
	<x path="UInt"/>
	<x path="Int"/>
</f></getRed>
		<getAlpha public="1" set="method" static="1"><f a="color">
	<x path="UInt"/>
	<x path="Int"/>
</f></getAlpha>
		<PURPLE public="1" static="1"><x path="UInt"/></PURPLE>
		<FUCHSIA public="1" static="1"><x path="UInt"/></FUCHSIA>
		<NAVY public="1" static="1"><x path="UInt"/></NAVY>
		<BLUE public="1" static="1"><x path="UInt"/></BLUE>
		<TEAL public="1" static="1"><x path="UInt"/></TEAL>
		<AQUA public="1" static="1"><x path="UInt"/></AQUA>
		<GREEN public="1" static="1"><x path="UInt"/></GREEN>
		<LIME public="1" static="1"><x path="UInt"/></LIME>
		<OLIVE public="1" static="1"><x path="UInt"/></OLIVE>
		<YELLOW public="1" static="1"><x path="UInt"/></YELLOW>
		<MAROON public="1" static="1"><x path="UInt"/></MAROON>
		<RED public="1" static="1"><x path="UInt"/></RED>
		<BLACK public="1" static="1"><x path="UInt"/></BLACK>
		<GRAY public="1" static="1"><x path="UInt"/></GRAY>
		<SILVER public="1" static="1"><x path="UInt"/></SILVER>
		<WHITE public="1" static="1"><x path="UInt"/></WHITE>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="starling.utils.VertexData" params="" file="lib/starling.swc@starling.utils.VertexData" extern="1">
		<TEXCOORD_OFFSET public="1" static="1"><x path="Int"/></TEXCOORD_OFFSET>
		<COLOR_OFFSET public="1" static="1"><x path="Int"/></COLOR_OFFSET>
		<POSITION_OFFSET public="1" static="1"><x path="Int"/></POSITION_OFFSET>
		<ELEMENTS_PER_VERTEX public="1" static="1"><x path="Int"/></ELEMENTS_PER_VERTEX>
		<clone public="1" set="method">
			<f a="?vertexID:?numVertices">
				<x path="Int"/>
				<x path="Int"/>
				<c path="starling.utils.VertexData"/>
			</f>
			<meta>
				<m n=":defParam">
					<e>"numVertices"</e>
					<e>-1</e>
				</m>
				<m n=":defParam">
					<e>"vertexID"</e>
					<e>0</e>
				</m>
			</meta>
		</clone>
		<copyTo public="1" set="method">
			<f a="targetData:?targetVertexID:?vertexID:?numVertices">
				<c path="starling.utils.VertexData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":defParam">
					<e>"numVertices"</e>
					<e>-1</e>
				</m>
				<m n=":defParam">
					<e>"vertexID"</e>
					<e>0</e>
				</m>
				<m n=":defParam">
					<e>"targetVertexID"</e>
					<e>0</e>
				</m>
			</meta>
		</copyTo>
		<append public="1" set="method"><f a="data">
	<c path="starling.utils.VertexData"/>
	<x path="Void"/>
</f></append>
		<setPosition public="1" set="method"><f a="vertexID:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPosition>
		<getPosition public="1" set="method"><f a="vertexID:position">
	<x path="Int"/>
	<c path="flash.geom.Point"/>
	<x path="Void"/>
</f></getPosition>
		<setColor public="1" set="method"><f a="vertexID:color">
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setColor>
		<getColor public="1" set="method"><f a="vertexID">
	<x path="Int"/>
	<x path="UInt"/>
</f></getColor>
		<setAlpha public="1" set="method"><f a="vertexID:alpha">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setAlpha>
		<getAlpha public="1" set="method"><f a="vertexID">
	<x path="Int"/>
	<x path="Float"/>
</f></getAlpha>
		<setTexCoords public="1" set="method"><f a="vertexID:u:v">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTexCoords>
		<getTexCoords public="1" set="method"><f a="vertexID:texCoords">
	<x path="Int"/>
	<c path="flash.geom.Point"/>
	<x path="Void"/>
</f></getTexCoords>
		<translateVertex public="1" set="method"><f a="vertexID:deltaX:deltaY">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translateVertex>
		<transformVertex public="1" set="method">
			<f a="vertexID:matrix:?numVertices">
				<x path="Int"/>
				<c path="flash.geom.Matrix"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":defParam">
	<e>"numVertices"</e>
	<e>1</e>
</m></meta>
		</transformVertex>
		<setUniformColor public="1" set="method"><f a="color">
	<x path="UInt"/>
	<x path="Void"/>
</f></setUniformColor>
		<setUniformAlpha public="1" set="method"><f a="alpha">
	<x path="Float"/>
	<x path="Void"/>
</f></setUniformAlpha>
		<scaleAlpha public="1" set="method">
			<f a="vertexID:alpha:?numVertices">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":defParam">
	<e>"numVertices"</e>
	<e>1</e>
</m></meta>
		</scaleAlpha>
		<getBounds public="1" set="method">
			<f a="?transformationMatrix:?vertexID:?numVertices:?resultRect">
				<c path="flash.geom.Matrix"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Rectangle"/>
			</f>
			<meta>
				<m n=":defParam">
					<e>"numVertices"</e>
					<e>-1</e>
				</m>
				<m n=":defParam">
					<e>"vertexID"</e>
					<e>0</e>
				</m>
			</meta>
		</getBounds>
		<setPremultipliedAlpha public="1" set="method">
			<f a="value:?updateData">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":defParam">
	<e>"updateData"</e>
	<e>true</e>
</m></meta>
		</setPremultipliedAlpha>
		<numVertices public="1"><x path="Int"/></numVertices>
		<premultipliedAlpha public="1" set="null"><x path="Bool"/></premultipliedAlpha>
		<tinted public="1" set="null"><x path="Bool"/></tinted>
		<rawData public="1" set="null"><c path="flash.Vector"><x path="Float"/></c></rawData>
		<new public="1" set="method">
			<f a="numVertices:?premultipliedAlpha">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":defParam">
	<e>"premultipliedAlpha"</e>
	<e>false</e>
</m></meta>
		</new>
	</class>
	<class path="systems.GridRenderN" params="" file="src/systems/GridRenderS.hx" module="systems.GridRenderS">
		<extends path="ash.core.Node"><c path="systems.GridRenderN"/></extends>
		<_components static="1"><t path="ash.ObjectMap">
	<x path="Class"><d/></x>
	<c path="String"/>
</t></_components>
		<_getComponents public="1" get="inline" set="null" line="5" static="1"><f a=""><t path="ash.ObjectMap">
	<x path="Class"><d/></x>
	<c path="String"/>
</t></f></_getComponents>
		<grid public="1"><t path="Grid"/></grid>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="systems.GridRenderS" params="" file="src/systems/GridRenderS.hx">
		<extends path="ash.tools.ListIteratingSystem"><c path="systems.GridRenderN"/></extends>
		<updateN set="method" line="29"><f a="node:time">
	<c path="systems.GridRenderN"/>
	<x path="Float"/>
	<x path="Void"/>
</f></updateN>
		<remove set="method" line="25"><f a="node">
	<c path="systems.GridRenderN"/>
	<x path="Void"/>
</f></remove>
		<add set="method" line="18"><f a="node">
	<c path="systems.GridRenderN"/>
	<x path="Void"/>
</f></add>
		<container><t path="DisplayObjectContainer"/></container>
		<creator><c path="EntityCreator"/></creator>
		<new public="1" set="method" line="13"><f a="container">
	<t path="DisplayObjectContainer"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="systems.GridN" params="" file="src/systems/GridS.hx" module="systems.GridS">
		<extends path="ash.core.Node"><c path="systems.GridN"/></extends>
		<_components static="1"><t path="ash.ObjectMap">
	<x path="Class"><d/></x>
	<c path="String"/>
</t></_components>
		<_getComponents public="1" get="inline" set="null" line="5" static="1"><f a=""><t path="ash.ObjectMap">
	<x path="Class"><d/></x>
	<c path="String"/>
</t></f></_getComponents>
		<grid public="1"><t path="Grid"/></grid>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="systems.GridS" params="" file="src/systems/GridS.hx">
		<extends path="ash.tools.ListIteratingSystem"><c path="systems.GridN"/></extends>
		<updateN set="method" line="19"><f a="node:time">
	<c path="systems.GridN"/>
	<x path="Float"/>
	<x path="Void"/>
</f></updateN>
		<mouseInput><c path="MouseInput"/></mouseInput>
		<creator><c path="EntityCreator"/></creator>
		<new public="1" set="method" line="13"><f a="creator:mouseInput">
	<c path="EntityCreator"/>
	<c path="MouseInput"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="systems.RenderN" params="" file="src/systems/RenderS.hx" module="systems.RenderS">
		<extends path="ash.core.Node"><c path="systems.RenderN"/></extends>
		<_components static="1"><t path="ash.ObjectMap">
	<x path="Class"><d/></x>
	<c path="String"/>
</t></_components>
		<_getComponents public="1" get="inline" set="null" line="5" static="1"><f a=""><t path="ash.ObjectMap">
	<x path="Class"><d/></x>
	<c path="String"/>
</t></f></_getComponents>
		<transform public="1"><t path="Transform"/></transform>
		<display public="1"><t path="Display"/></display>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="systems.RenderS" params="" file="src/systems/RenderS.hx">
		<extends path="ash.tools.ListIteratingSystem"><c path="systems.RenderN"/></extends>
		<updateN set="method" line="43"><f a="node:time">
	<c path="systems.RenderN"/>
	<x path="Float"/>
	<x path="Void"/>
</f></updateN>
		<remove set="method" line="39"><f a="node">
	<c path="systems.RenderN"/>
	<x path="Void"/>
</f></remove>
		<add set="method" line="35"><f a="node">
	<c path="systems.RenderN"/>
	<x path="Void"/>
</f></add>
		<update public="1" set="method" line="26" override="1"><f a="time">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<depth><x path="Int"/></depth>
		<addToEngine public="1" set="method" line="20" override="1"><f a="engine">
	<t path="Engine"/>
	<x path="Void"/>
</f></addToEngine>
		<list><t path="NodeList"><c path="systems.RenderN"/></t></list>
		<container><t path="DisplayObjectContainer"/></container>
		<new public="1" set="method" line="15"><f a="container">
	<t path="DisplayObjectContainer"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.ZPP_Const" params="" file="libSrc/napeLib/zpp_nape/Const.hx" module="zpp_nape.Const">
		<POSINF public="1" get="inline" set="null" line="176" static="1"><f a=""><x path="Float"/></f></POSINF>
		<NEGINF public="1" get="inline" set="null" line="180" static="1"><f a=""><x path="Float"/></f></NEGINF>
		<FMAX public="1" get="inline" set="null" line="193" static="1"><x path="Float"/></FMAX>
		<vec2vector public="1" line="194" static="1"><x path="Class"><c path="flash.Vector"><c path="nape.geom.Vec2"/></c></x></vec2vector>
		<cbtypevector public="1" line="195" static="1"><x path="Class"><c path="flash.Vector"><c path="nape.callbacks.CbType"/></c></x></cbtypevector>
		<optiontypevector public="1" line="196" static="1"><x path="Class"><c path="flash.Vector"><c path="nape.callbacks.OptionType"/></c></x></optiontypevector>
	</class>
	<class path="zpp_nape.ZPP_ID" params="" file="libSrc/napeLib/zpp_nape/ID.hx" module="zpp_nape.ID">
		<_Constraint public="1" line="176" static="1"><x path="Int"/></_Constraint>
		<Constraint public="1" set="method" line="177" static="1"><f a=""><x path="Int"/></f></Constraint>
		<_Interactor public="1" line="180" static="1"><x path="Int"/></_Interactor>
		<Interactor public="1" set="method" line="181" static="1"><f a=""><x path="Int"/></f></Interactor>
		<_CbType public="1" line="184" static="1"><x path="Int"/></_CbType>
		<CbType public="1" set="method" line="185" static="1"><f a=""><x path="Int"/></f></CbType>
		<_CbSet public="1" line="188" static="1"><x path="Int"/></_CbSet>
		<CbSet public="1" set="method" line="189" static="1"><f a=""><x path="Int"/></f></CbSet>
		<_Listener public="1" line="192" static="1"><x path="Int"/></_Listener>
		<Listener public="1" set="method" line="193" static="1"><f a=""><x path="Int"/></f></Listener>
		<_ZPP_SimpleVert public="1" line="196" static="1"><x path="Int"/></_ZPP_SimpleVert>
		<ZPP_SimpleVert public="1" set="method" line="197" static="1"><f a=""><x path="Int"/></f></ZPP_SimpleVert>
		<_ZPP_SimpleSeg public="1" line="200" static="1"><x path="Int"/></_ZPP_SimpleSeg>
		<ZPP_SimpleSeg public="1" set="method" line="201" static="1"><f a=""><x path="Int"/></f></ZPP_SimpleSeg>
		<_Space public="1" line="204" static="1"><x path="Int"/></_Space>
		<Space public="1" set="method" line="205" static="1"><f a=""><x path="Int"/></f></Space>
		<_InteractionGroup public="1" line="208" static="1"><x path="Int"/></_InteractionGroup>
		<InteractionGroup public="1" set="method" line="209" static="1"><f a=""><x path="Int"/></f></InteractionGroup>
	</class>
	<class path="zpp_nape.callbacks.ZPP_Callback" params="" file="libSrc/napeLib/zpp_nape/callbacks/Callback.hx" module="zpp_nape.callbacks.Callback">
		<internal public="1" line="179" static="1"><x path="Bool"/></internal>
		<zpp_pool public="1" line="369" static="1"><c path="zpp_nape.callbacks.ZPP_Callback"/></zpp_pool>
		<constraint public="1"><c path="zpp_nape.constraint.ZPP_Constraint"/></constraint>
		<body public="1"><c path="zpp_nape.phys.ZPP_Body"/></body>
		<genarbs public="1" get="inline" set="null" line="416"><f a=""><x path="Void"/></f></genarbs>
		<pre_swapped public="1"><x path="Bool"/></pre_swapped>
		<pre_arbiter public="1"><c path="zpp_nape.dynamics.ZPP_Arbiter"/></pre_arbiter>
		<wrap_arbiters public="1"><c path="nape.dynamics.ArbiterList"/></wrap_arbiters>
		<set public="1"><c path="zpp_nape.space.ZPP_CallbackSet"/></set>
		<int2 public="1"><c path="zpp_nape.phys.ZPP_Interactor"/></int2>
		<int1 public="1"><c path="zpp_nape.phys.ZPP_Interactor"/></int1>
		<alloc public="1" get="inline" set="null" line="407"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="395"><f a=""><x path="Void"/></f></free>
		<rev_at public="1" set="method" line="356"><f a="i">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
</f></rev_at>
		<at public="1" set="method" line="343"><f a="i">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
</f></at>
		<cyclePrev public="1" set="method" line="331"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
</f></cyclePrev>
		<cycleNext public="1" set="method" line="319"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
</f></cycleNext>
		<rotateR public="1" set="method" line="316"><f a=""><x path="Void"/></f></rotateR>
		<rotateL public="1" set="method" line="313"><f a=""><x path="Void"/></f></rotateL>
		<splice public="1" set="method" line="298"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
</f></splice>
		<clear public="1" set="method" line="295"><f a=""><x path="Void"/></f></clear>
		<empty public="1" set="method" line="292"><f a=""><x path="Bool"/></f></empty>
		<pop_rev public="1" set="method" line="276"><f a=""><c path="zpp_nape.callbacks.ZPP_Callback"/></f></pop_rev>
		<pop public="1" set="method" line="260"><f a=""><c path="zpp_nape.callbacks.ZPP_Callback"/></f></pop>
		<push_rev public="1" set="method" line="244"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
	<x path="Void"/>
</f></push_rev>
		<push public="1" set="method" line="228"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
	<x path="Void"/>
</f></push>
		<length public="1"><x path="Int"/></length>
		<prev public="1"><c path="zpp_nape.callbacks.ZPP_Callback"/></prev>
		<next public="1"><c path="zpp_nape.callbacks.ZPP_Callback"/></next>
		<index public="1"><x path="Int"/></index>
		<space public="1"><c path="zpp_nape.space.ZPP_Space"/></space>
		<listener public="1"><c path="zpp_nape.callbacks.ZPP_Listener"/></listener>
		<event public="1"><x path="Int"/></event>
		<wrapper_int public="1" set="method" line="207"><f a=""><t path="Null"><c path="nape.callbacks.InteractionCallback"/></t></f></wrapper_int>
		<wrapper_con public="1" set="method" line="194"><f a=""><t path="Null"><c path="nape.callbacks.ConstraintCallback"/></t></f></wrapper_con>
		<wrapper_body public="1" set="method" line="181"><f a=""><t path="Null"><c path="nape.callbacks.BodyCallback"/></t></f></wrapper_body>
		<outer_int public="1"><t path="Null"><c path="nape.callbacks.InteractionCallback"/></t></outer_int>
		<outer_con public="1"><t path="Null"><c path="nape.callbacks.ConstraintCallback"/></t></outer_con>
		<outer_body public="1"><t path="Null"><c path="nape.callbacks.BodyCallback"/></t></outer_body>
		<new public="1" set="method" line="436"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.callbacks.ZPP_CbSet" params="" file="libSrc/napeLib/zpp_nape/callbacks/CbSet.hx" module="zpp_nape.callbacks.CbSet">
		<zpp_pool public="1" line="178" static="1"><c path="zpp_nape.callbacks.ZPP_CbSet"/></zpp_pool>
		<setlt public="1" set="method" line="440" static="1"><f a="a:b">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></setlt>
		<get public="1" set="method" line="545" static="1"><f a="cbTypes">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
</f></get>
		<compatible get="inline" set="null" line="581" static="1"><f a="i:a:b">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></compatible>
		<empty_intersection public="1" get="inline" set="null" line="585" static="1"><f a="a:b">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></empty_intersection>
		<single_intersection public="1" set="method" line="588" static="1"><f a="a:b:i">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Bool"/>
</f></single_intersection>
		<find_all public="1" get="inline" set="null" line="592" static="1"><f a="a:b:event:cb">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Int"/>
	<f a="">
		<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></find_all>
		<alloc public="1" get="inline" set="null" line="520"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="471"><f a=""><x path="Void"/></f></free>
		<remInteractor public="1" get="inline" set="null" line="437"><f a="intx">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></remInteractor>
		<remConstraint public="1" get="inline" set="null" line="432"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></remConstraint>
		<addInteractor public="1" get="inline" set="null" line="427"><f a="intx">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></addInteractor>
		<addConstraint public="1" get="inline" set="null" line="422"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></addConstraint>
		<wrap_constraints public="1"><c path="nape.constraint.ConstraintList"/></wrap_constraints>
		<constraints public="1"><c path="zpp_nape.util.ZNPList_ZPP_Constraint"/></constraints>
		<wrap_interactors public="1"><c path="nape.phys.InteractorList"/></wrap_interactors>
		<interactors public="1"><c path="zpp_nape.util.ZNPList_ZPP_Interactor"/></interactors>
		<validate public="1" set="method" line="410"><f a=""><x path="Void"/></f></validate>
		<realvalidate_conlisteners public="1" set="method" line="368"><f a=""><x path="Void"/></f></realvalidate_conlisteners>
		<validate_conlisteners public="1" get="inline" set="null" line="362"><f a=""><x path="Void"/></f></validate_conlisteners>
		<invalidate_conlisteners public="1" get="inline" set="null" line="355"><f a=""><x path="Void"/></f></invalidate_conlisteners>
		<zip_conlisteners public="1"><x path="Bool"/></zip_conlisteners>
		<conlisteners public="1"><c path="zpp_nape.util.ZNPList_ZPP_ConstraintListener"/></conlisteners>
		<realvalidate_bodylisteners public="1" set="method" line="309"><f a=""><x path="Void"/></f></realvalidate_bodylisteners>
		<validate_bodylisteners public="1" get="inline" set="null" line="303"><f a=""><x path="Void"/></f></validate_bodylisteners>
		<invalidate_bodylisteners public="1" get="inline" set="null" line="296"><f a=""><x path="Void"/></f></invalidate_bodylisteners>
		<zip_bodylisteners public="1"><x path="Bool"/></zip_bodylisteners>
		<bodylisteners public="1"><c path="zpp_nape.util.ZNPList_ZPP_BodyListener"/></bodylisteners>
		<realvalidate_listeners public="1" set="method" line="250"><f a=""><x path="Void"/></f></realvalidate_listeners>
		<validate_listeners public="1" get="inline" set="null" line="244"><f a=""><x path="Void"/></f></validate_listeners>
		<invalidate_listeners public="1" get="inline" set="null" line="237"><f a=""><x path="Void"/></f></invalidate_listeners>
		<zip_listeners public="1"><x path="Bool"/></zip_listeners>
		<listeners public="1"><c path="zpp_nape.util.ZNPList_ZPP_InteractionListener"/></listeners>
		<invalidate_pairs public="1" set="method" line="223"><f a=""><x path="Void"/></f></invalidate_pairs>
		<decrement public="1" get="inline" set="null" line="212"><f a=""><x path="Bool"/></f></decrement>
		<increment public="1" get="inline" set="null" line="207"><f a=""><x path="Void"/></f></increment>
		<cbpairs public="1"><c path="zpp_nape.util.ZNPList_ZPP_CbSetPair"/></cbpairs>
		<manager public="1"><c path="zpp_nape.space.ZPP_CbSetManager"/></manager>
		<id public="1"><x path="Int"/></id>
		<next public="1"><c path="zpp_nape.callbacks.ZPP_CbSet"/></next>
		<count public="1"><x path="Int"/></count>
		<cbTypes public="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></cbTypes>
		<new public="1" set="method" line="455"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.callbacks.ZPP_CbSetPair" params="" file="libSrc/napeLib/zpp_nape/callbacks/CbSetPair.hx" module="zpp_nape.callbacks.CbSetPair">
		<zpp_pool public="1" line="178" static="1"><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></zpp_pool>
		<get public="1" get="inline" set="null" line="217" static="1"><f a="a:b">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
</f></get>
		<setlt public="1" get="inline" set="null" line="247" static="1"><f a="x:y">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></setlt>
		<forall public="1" get="inline" set="null" line="341"><f a="event:cb">
	<x path="Int"/>
	<f a="">
		<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></forall>
		<single_intersection public="1" get="inline" set="null" line="327"><f a="i">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Bool"/>
</f></single_intersection>
		<empty_intersection public="1" get="inline" set="null" line="314"><f a=""><x path="Bool"/></f></empty_intersection>
		<__validate public="1" set="method" line="278"><f a=""><x path="Void"/></f></__validate>
		<validate public="1" get="inline" set="null" line="272"><f a=""><x path="Void"/></f></validate>
		<invalidate public="1" get="inline" set="null" line="267"><f a=""><x path="Void"/></f></invalidate>
		<listeners public="1"><c path="zpp_nape.util.ZNPList_ZPP_InteractionListener"/></listeners>
		<zip_listeners public="1"><x path="Bool"/></zip_listeners>
		<compatible get="inline" set="null" line="260"><f a="i">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Bool"/>
</f></compatible>
		<alloc public="1" get="inline" set="null" line="210"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="204"><f a=""><x path="Void"/></f></free>
		<next public="1"><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></next>
		<b public="1"><c path="zpp_nape.callbacks.ZPP_CbSet"/></b>
		<a public="1"><c path="zpp_nape.callbacks.ZPP_CbSet"/></a>
		<new public="1" set="method" line="213"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_InteractionListener" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="3080"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
</f></at>
		<iterator_at public="1" set="method" line="3067"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
</f></iterator_at>
		<back public="1" set="method" line="3058"><f a=""><c path="zpp_nape.callbacks.ZPP_InteractionListener"/></f></back>
		<front public="1" get="inline" set="null" line="3055"><f a=""><c path="zpp_nape.callbacks.ZPP_InteractionListener"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="3025"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="3020"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="3017"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="3012"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="2997"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="2991"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="2986"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="2982"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="2936"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
</f></inlined_erase>
		<erase public="1" set="method" line="2931"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="2908"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="2895"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="2870"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="2859"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="2846"><f a=""><c path="zpp_nape.callbacks.ZPP_InteractionListener"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="2841"><f a=""><c path="zpp_nape.callbacks.ZPP_InteractionListener"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="2808"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="2803"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="2760"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
</f></inlined_insert>
		<insert public="1" set="method" line="2755"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
</f></insert>
		<addAll public="1" set="method" line="2737"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_InteractionListener"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="2700"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
</f></inlined_add>
		<add public="1" set="method" line="2695"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="2690"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="2682"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/></head>
		<new public="1" set="method" line="2679"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_BodyListener" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="4748"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
</f></at>
		<iterator_at public="1" set="method" line="4735"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
</f></iterator_at>
		<back public="1" set="method" line="4726"><f a=""><c path="zpp_nape.callbacks.ZPP_BodyListener"/></f></back>
		<front public="1" get="inline" set="null" line="4723"><f a=""><c path="zpp_nape.callbacks.ZPP_BodyListener"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="4693"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="4688"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="4685"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="4680"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="4665"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="4659"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="4654"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="4650"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="4604"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
</f></inlined_erase>
		<erase public="1" set="method" line="4599"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="4576"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="4563"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="4538"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="4527"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="4514"><f a=""><c path="zpp_nape.callbacks.ZPP_BodyListener"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="4509"><f a=""><c path="zpp_nape.callbacks.ZPP_BodyListener"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="4476"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="4471"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="4428"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
</f></inlined_insert>
		<insert public="1" set="method" line="4423"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
</f></insert>
		<addAll public="1" set="method" line="4405"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_BodyListener"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="4368"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
</f></inlined_add>
		<add public="1" set="method" line="4363"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="4358"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="4350"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/></head>
		<new public="1" set="method" line="4347"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_ConstraintListener" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="5165"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
</f></at>
		<iterator_at public="1" set="method" line="5152"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
</f></iterator_at>
		<back public="1" set="method" line="5143"><f a=""><c path="zpp_nape.callbacks.ZPP_ConstraintListener"/></f></back>
		<front public="1" get="inline" set="null" line="5140"><f a=""><c path="zpp_nape.callbacks.ZPP_ConstraintListener"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="5110"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="5105"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="5102"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="5097"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="5082"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="5076"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="5071"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="5067"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="5021"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
</f></inlined_erase>
		<erase public="1" set="method" line="5016"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="4993"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="4980"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="4955"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="4944"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="4931"><f a=""><c path="zpp_nape.callbacks.ZPP_ConstraintListener"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="4926"><f a=""><c path="zpp_nape.callbacks.ZPP_ConstraintListener"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="4893"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="4888"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="4845"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
</f></inlined_insert>
		<insert public="1" set="method" line="4840"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
</f></insert>
		<addAll public="1" set="method" line="4822"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_ConstraintListener"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="4785"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
</f></inlined_add>
		<add public="1" set="method" line="4780"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="4775"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="4767"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/></head>
		<new public="1" set="method" line="4764"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Constraint" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="2246"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
</f></at>
		<iterator_at public="1" set="method" line="2233"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
</f></iterator_at>
		<back public="1" set="method" line="2224"><f a=""><c path="zpp_nape.constraint.ZPP_Constraint"/></f></back>
		<front public="1" get="inline" set="null" line="2221"><f a=""><c path="zpp_nape.constraint.ZPP_Constraint"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="2191"><f a="obj">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="2186"><f a="obj">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="2183"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="2178"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="2163"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="2157"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="2152"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="2148"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="2102"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
</f></inlined_erase>
		<erase public="1" set="method" line="2097"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="2074"><f a="obj">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="2061"><f a="obj">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="2036"><f a="obj">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="2025"><f a="obj">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="2012"><f a=""><c path="zpp_nape.constraint.ZPP_Constraint"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="2007"><f a=""><c path="zpp_nape.constraint.ZPP_Constraint"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="1974"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="1969"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="1926"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
</f></inlined_insert>
		<insert public="1" set="method" line="1921"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
</f></insert>
		<addAll public="1" set="method" line="1903"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Constraint"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="1866"><f a="o">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
</f></inlined_add>
		<add public="1" set="method" line="1861"><f a="o">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="1856"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="1848"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/></head>
		<new public="1" set="method" line="1845"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Interactor" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="4331"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
</f></at>
		<iterator_at public="1" set="method" line="4318"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
</f></iterator_at>
		<back public="1" set="method" line="4309"><f a=""><c path="zpp_nape.phys.ZPP_Interactor"/></f></back>
		<front public="1" get="inline" set="null" line="4306"><f a=""><c path="zpp_nape.phys.ZPP_Interactor"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="4276"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="4271"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="4268"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="4263"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="4248"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="4242"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="4237"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="4233"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="4187"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
</f></inlined_erase>
		<erase public="1" set="method" line="4182"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="4159"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="4146"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="4121"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="4110"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="4097"><f a=""><c path="zpp_nape.phys.ZPP_Interactor"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="4092"><f a=""><c path="zpp_nape.phys.ZPP_Interactor"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="4059"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="4054"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="4011"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
</f></inlined_insert>
		<insert public="1" set="method" line="4006"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
</f></insert>
		<addAll public="1" set="method" line="3988"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Interactor"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="3951"><f a="o">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
</f></inlined_add>
		<add public="1" set="method" line="3946"><f a="o">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="3941"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="3933"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/></head>
		<new public="1" set="method" line="3930"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_CbSet" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="3497"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
</f></at>
		<iterator_at public="1" set="method" line="3484"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
</f></iterator_at>
		<back public="1" set="method" line="3475"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSet"/></f></back>
		<front public="1" get="inline" set="null" line="3472"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSet"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="3442"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="3437"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="3434"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="3429"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="3414"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="3408"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="3403"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="3399"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="3353"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
</f></inlined_erase>
		<erase public="1" set="method" line="3348"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="3325"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="3312"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="3287"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="3276"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="3263"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSet"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="3258"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSet"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="3225"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="3220"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="3177"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
</f></inlined_insert>
		<insert public="1" set="method" line="3172"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
</f></insert>
		<addAll public="1" set="method" line="3154"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_CbSet"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="3117"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
</f></inlined_add>
		<add public="1" set="method" line="3112"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="3107"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="3099"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/></head>
		<new public="1" set="method" line="3096"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.callbacks.ZPP_CbType" params="" file="libSrc/napeLib/zpp_nape/callbacks/CbType.hx" module="zpp_nape.callbacks.CbType">
		<setlt public="1" get="inline" set="null" line="180" static="1"><f a="a:b">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
</f></setlt>
		<ANY_SHAPE public="1" line="348" static="1"><c path="nape.callbacks.CbType"/></ANY_SHAPE>
		<ANY_BODY public="1" line="349" static="1"><c path="nape.callbacks.CbType"/></ANY_BODY>
		<ANY_COMPOUND public="1" line="350" static="1"><c path="nape.callbacks.CbType"/></ANY_COMPOUND>
		<ANY_CONSTRAINT public="1" line="351" static="1"><c path="nape.callbacks.CbType"/></ANY_CONSTRAINT>
		<invalidateconstraint public="1" get="inline" set="null" line="338"><f a=""><x path="Void"/></f></invalidateconstraint>
		<removeconstraint public="1" get="inline" set="null" line="332"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<x path="Void"/>
</f></removeconstraint>
		<addconstraint public="1" get="inline" set="null" line="304"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_ConstraintListener"/>
	<x path="Void"/>
</f></addconstraint>
		<conlisteners public="1"><c path="zpp_nape.util.ZNPList_ZPP_ConstraintListener"/></conlisteners>
		<invalidatebody public="1" get="inline" set="null" line="291"><f a=""><x path="Void"/></f></invalidatebody>
		<removebody public="1" get="inline" set="null" line="285"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<x path="Void"/>
</f></removebody>
		<addbody public="1" get="inline" set="null" line="257"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_BodyListener"/>
	<x path="Void"/>
</f></addbody>
		<bodylisteners public="1"><c path="zpp_nape.util.ZNPList_ZPP_BodyListener"/></bodylisteners>
		<invalidateint public="1" get="inline" set="null" line="244"><f a=""><x path="Void"/></f></invalidateint>
		<removeint public="1" get="inline" set="null" line="238"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Void"/>
</f></removeint>
		<addint public="1" get="inline" set="null" line="210"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Void"/>
</f></addint>
		<listeners public="1"><c path="zpp_nape.util.ZNPList_ZPP_InteractionListener"/></listeners>
		<remInteractor public="1" get="inline" set="null" line="204"><f a="intx">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></remInteractor>
		<remConstraint public="1" get="inline" set="null" line="199"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></remConstraint>
		<addInteractor public="1" get="inline" set="null" line="194"><f a="intx">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></addInteractor>
		<addConstraint public="1" get="inline" set="null" line="189"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></addConstraint>
		<wrap_constraints public="1"><c path="nape.constraint.ConstraintList"/></wrap_constraints>
		<constraints public="1"><c path="zpp_nape.util.ZNPList_ZPP_Constraint"/></constraints>
		<wrap_interactors public="1"><c path="nape.phys.InteractorList"/></wrap_interactors>
		<interactors public="1"><c path="zpp_nape.util.ZNPList_ZPP_Interactor"/></interactors>
		<cbsets public="1"><c path="zpp_nape.util.ZNPList_ZPP_CbSet"/></cbsets>
		<id public="1"><x path="Int"/></id>
		<userData public="1"><d><d/></d></userData>
		<outer public="1"><c path="nape.callbacks.CbType"/></outer>
		<new public="1" set="method" line="352"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.callbacks.ZPP_Listener" params="" file="libSrc/napeLib/zpp_nape/callbacks/Listener.hx" module="zpp_nape.callbacks.Listener">
		<internal public="1" line="177" static="1"><x path="Bool"/></internal>
		<setlt public="1" get="inline" set="null" line="191" static="1"><f a="a:b">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Bool"/>
</f></setlt>
		<removedFromSpace public="1" set="method" line="197"><f a=""><x path="Void"/></f></removedFromSpace>
		<addedToSpace public="1" set="method" line="196"><f a=""><x path="Void"/></f></addedToSpace>
		<invalidate_precedence public="1" set="method" line="195"><f a=""><x path="Void"/></f></invalidate_precedence>
		<swapEvent public="1" set="method" line="194"><f a="event">
	<x path="Int"/>
	<x path="Void"/>
</f></swapEvent>
		<space public="1"><t path="Null"><c path="zpp_nape.space.ZPP_Space"/></t></space>
		<interaction public="1"><t path="Null"><c path="zpp_nape.callbacks.ZPP_InteractionListener"/></t></interaction>
		<constraint public="1"><t path="Null"><c path="zpp_nape.callbacks.ZPP_ConstraintListener"/></t></constraint>
		<body public="1"><t path="Null"><c path="zpp_nape.callbacks.ZPP_BodyListener"/></t></body>
		<precedence public="1"><x path="Int"/></precedence>
		<event public="1"><x path="Int"/></event>
		<type public="1"><x path="Int"/></type>
		<id public="1"><x path="Int"/></id>
		<outer public="1"><c path="nape.callbacks.Listener"/></outer>
		<new set="method" line="187"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.callbacks.ZPP_BodyListener" params="" file="libSrc/napeLib/zpp_nape/callbacks/Listener.hx" module="zpp_nape.callbacks.Listener">
		<extends path="zpp_nape.callbacks.ZPP_Listener"/>
		<swapEvent public="1" set="method" line="256" override="1"><f a="newev">
	<x path="Int"/>
	<x path="Void"/>
</f></swapEvent>
		<invalidate_precedence public="1" set="method" line="250" override="1"><f a=""><x path="Void"/></f></invalidate_precedence>
		<cbtype_change set="method" line="245"><f a="cb:included:added">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></cbtype_change>
		<removedFromSpace public="1" set="method" line="232" override="1"><f a=""><x path="Void"/></f></removedFromSpace>
		<addedToSpace public="1" set="method" line="219" override="1"><f a=""><x path="Void"/></f></addedToSpace>
		<immutable_options set="method" line="205"><f a=""><x path="Void"/></f></immutable_options>
		<handler public="1"><f a="">
	<c path="nape.callbacks.BodyCallback"/>
	<x path="Void"/>
</f></handler>
		<options public="1"><c path="zpp_nape.callbacks.ZPP_OptionType"/></options>
		<outer_zn public="1"><c path="nape.callbacks.BodyListener"/></outer_zn>
		<new public="1" set="method" line="211"><f a="options:event:handler">
	<c path="nape.callbacks.OptionType"/>
	<x path="Int"/>
	<f a="">
		<c path="nape.callbacks.BodyCallback"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.callbacks.ZPP_ConstraintListener" params="" file="libSrc/napeLib/zpp_nape/callbacks/Listener.hx" module="zpp_nape.callbacks.Listener">
		<extends path="zpp_nape.callbacks.ZPP_Listener"/>
		<swapEvent public="1" set="method" line="324" override="1"><f a="newev">
	<x path="Int"/>
	<x path="Void"/>
</f></swapEvent>
		<invalidate_precedence public="1" set="method" line="318" override="1"><f a=""><x path="Void"/></f></invalidate_precedence>
		<cbtype_change set="method" line="313"><f a="cb:included:added">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></cbtype_change>
		<removedFromSpace public="1" set="method" line="300" override="1"><f a=""><x path="Void"/></f></removedFromSpace>
		<addedToSpace public="1" set="method" line="287" override="1"><f a=""><x path="Void"/></f></addedToSpace>
		<immutable_options set="method" line="273"><f a=""><x path="Void"/></f></immutable_options>
		<handler public="1"><f a="">
	<c path="nape.callbacks.ConstraintCallback"/>
	<x path="Void"/>
</f></handler>
		<options public="1"><c path="zpp_nape.callbacks.ZPP_OptionType"/></options>
		<outer_zn public="1"><c path="nape.callbacks.ConstraintListener"/></outer_zn>
		<new public="1" set="method" line="279"><f a="options:event:handler">
	<c path="nape.callbacks.OptionType"/>
	<x path="Int"/>
	<f a="">
		<c path="nape.callbacks.ConstraintCallback"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_CbType" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="578"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
</f></at>
		<iterator_at public="1" set="method" line="565"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
</f></iterator_at>
		<back public="1" set="method" line="556"><f a=""><c path="zpp_nape.callbacks.ZPP_CbType"/></f></back>
		<front public="1" get="inline" set="null" line="553"><f a=""><c path="zpp_nape.callbacks.ZPP_CbType"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="523"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="518"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="515"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="510"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="495"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="489"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="484"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="480"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="434"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
</f></inlined_erase>
		<erase public="1" set="method" line="429"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="406"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="393"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="368"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="357"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="344"><f a=""><c path="zpp_nape.callbacks.ZPP_CbType"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="339"><f a=""><c path="zpp_nape.callbacks.ZPP_CbType"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="306"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="301"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="258"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
</f></inlined_insert>
		<insert public="1" set="method" line="253"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
</f></insert>
		<addAll public="1" set="method" line="235"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="198"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
</f></inlined_add>
		<add public="1" set="method" line="193"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="188"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbType"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="180"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_CbType"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbType"/></head>
		<new public="1" set="method" line="177"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.callbacks.ZPP_InteractionListener" params="" file="libSrc/napeLib/zpp_nape/callbacks/Listener.hx" module="zpp_nape.callbacks.Listener">
		<extends path="zpp_nape.callbacks.ZPP_Listener"/>
		<UCbSet line="383" static="1"><c path="zpp_nape.util.ZNPList_ZPP_CbSet"/></UCbSet>
		<VCbSet line="384" static="1"><c path="zpp_nape.util.ZNPList_ZPP_CbSet"/></VCbSet>
		<WCbSet line="385" static="1"><c path="zpp_nape.util.ZNPList_ZPP_CbSet"/></WCbSet>
		<UCbType line="462" static="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></UCbType>
		<VCbType line="463" static="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></VCbType>
		<WCbType line="464" static="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></WCbType>
		<swapEvent public="1" set="method" line="710" override="1"><f a="newev">
	<x path="Int"/>
	<x path="Void"/>
</f></swapEvent>
		<cbtype_change set="method" line="703"><f a="options:cb:included:added">
	<c path="zpp_nape.callbacks.ZPP_OptionType"/>
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></cbtype_change>
		<cbtype_change2 set="method" line="700"><f a="cb:included:added">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></cbtype_change2>
		<cbtype_change1 set="method" line="697"><f a="cb:included:added">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></cbtype_change1>
		<invalidate_precedence public="1" set="method" line="678" override="1"><f a=""><x path="Void"/></f></invalidate_precedence>
		<removedFromSpace public="1" set="method" line="659" override="1"><f a=""><x path="Void"/></f></removedFromSpace>
		<addedToSpace public="1" set="method" line="640" override="1"><f a=""><x path="Void"/></f></addedToSpace>
		<with_union get="inline" set="null" line="611"><f a="lambda">
	<f a="">
		<c path="zpp_nape.callbacks.ZPP_CbType"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></with_union>
		<with_uniquesets set="method" line="541"><f a="fresh">
	<x path="Bool"/>
	<x path="Void"/>
</f></with_uniquesets>
		<CbTypeset get="inline" set="null" line="467"><f a="A:B:lambda">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<f a=":">
		<c path="zpp_nape.callbacks.ZPP_CbType"/>
		<c path="zpp_nape.callbacks.ZPP_CbType"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></CbTypeset>
		<CbSetset get="inline" set="null" line="388"><f a="A:B:lambda">
	<c path="zpp_nape.util.ZNPList_ZPP_CbSet"/>
	<c path="zpp_nape.util.ZNPList_ZPP_CbSet"/>
	<f a=":">
		<c path="zpp_nape.callbacks.ZPP_CbSet"/>
		<c path="zpp_nape.callbacks.ZPP_CbSet"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></CbSetset>
		<wake public="1" set="method" line="360"><f a=""><x path="Void"/></f></wake>
		<setInteractionType public="1" get="inline" set="null" line="348"><f a="itype">
	<x path="Int"/>
	<x path="Void"/>
</f></setInteractionType>
		<handlerp public="1"><t path="Null"><f a="">
	<c path="nape.callbacks.PreCallback"/>
	<t path="Null"><c path="nape.callbacks.PreFlag"/></t>
</f></t></handlerp>
		<pure public="1"><x path="Bool"/></pure>
		<allowSleepingCallbacks public="1"><x path="Bool"/></allowSleepingCallbacks>
		<handleri public="1"><t path="Null"><f a="">
	<c path="nape.callbacks.InteractionCallback"/>
	<x path="Void"/>
</f></t></handleri>
		<options2 public="1"><c path="zpp_nape.callbacks.ZPP_OptionType"/></options2>
		<options1 public="1"><c path="zpp_nape.callbacks.ZPP_OptionType"/></options1>
		<itype public="1"><x path="Int"/></itype>
		<outer_znp public="1"><t path="Null"><c path="nape.callbacks.PreListener"/></t></outer_znp>
		<outer_zni public="1"><t path="Null"><c path="nape.callbacks.InteractionListener"/></t></outer_zni>
		<new public="1" set="method" line="351"><f a="options1:options2:event:type">
	<c path="nape.callbacks.OptionType"/>
	<c path="nape.callbacks.OptionType"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.callbacks.ZPP_OptionType" params="" file="libSrc/napeLib/zpp_nape/callbacks/OptionType.hx" module="zpp_nape.callbacks.OptionType">
		<argument public="1" set="method" line="350" static="1"><f a="val">
	<d/>
	<c path="nape.callbacks.OptionType"/>
</f></argument>
		<append public="1" set="method" line="312"><f a="list:val">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<d/>
	<x path="Void"/>
</f></append>
		<set public="1" set="method" line="289"><f a="options">
	<c path="zpp_nape.callbacks.ZPP_OptionType"/>
	<c path="zpp_nape.callbacks.ZPP_OptionType"/>
</f></set>
		<append_type set="method" line="263"><f a="list:val">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Void"/>
</f></append_type>
		<effect_change public="1" get="inline" set="null" line="225"><f a="val:included:added">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></effect_change>
		<nonemptyintersection public="1" set="method" line="203"><f a="xs:ys">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<x path="Bool"/>
</f></nonemptyintersection>
		<compatible public="1" get="inline" set="null" line="200"><f a="xs">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<x path="Bool"/>
</f></compatible>
		<included public="1" get="inline" set="null" line="196"><f a="xs">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<x path="Bool"/>
</f></included>
		<excluded public="1" get="inline" set="null" line="192"><f a="xs">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<x path="Bool"/>
</f></excluded>
		<setup_excludes public="1" set="method" line="188"><f a=""><x path="Void"/></f></setup_excludes>
		<setup_includes public="1" set="method" line="185"><f a=""><x path="Void"/></f></setup_includes>
		<wrap_excludes public="1"><c path="nape.callbacks.CbTypeList"/></wrap_excludes>
		<wrap_includes public="1"><c path="nape.callbacks.CbTypeList"/></wrap_includes>
		<excludes public="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></excludes>
		<includes public="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></includes>
		<handler public="1"><t path="Null"><f a="::">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></t></handler>
		<outer public="1"><c path="nape.callbacks.OptionType"/></outer>
		<new public="1" set="method" line="179"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_Constraint" params="" file="libSrc/napeLib/zpp_nape/constraint/Constraint.hx" module="zpp_nape.constraint.Constraint">
		<copyto public="1" set="method" line="539"><f a="ret">
	<c path="nape.constraint.Constraint"/>
	<x path="Void"/>
</f></copyto>
		<copy public="1" set="method" line="536"><f a="?dict:?todo">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<draw public="1" set="method" line="535"><f a="g">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></draw>
		<wake public="1" set="method" line="532"><f a=""><x path="Void"/></f></wake>
		<applyImpulsePos public="1" set="method" line="521"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<applyImpulseVel public="1" set="method" line="509"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<preStep public="1" set="method" line="497"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<pre_dt public="1"><x path="Float"/></pre_dt>
		<warmStart public="1" set="method" line="485"><f a=""><x path="Void"/></f></warmStart>
		<broken public="1" set="method" line="483"><f a=""><x path="Void"/></f></broken>
		<pair_exists public="1" set="method" line="471"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<forest public="1" set="method" line="460"><f a=""><x path="Void"/></f></forest>
		<wake_connected public="1" set="method" line="449"><f a=""><x path="Void"/></f></wake_connected>
		<validate public="1" set="method" line="438"><f a=""><x path="Void"/></f></validate>
		<clearcache public="1" set="method" line="427"><f a=""><x path="Void"/></f></clearcache>
		<inactiveBodies public="1" set="method" line="416"><f a=""><x path="Void"/></f></inactiveBodies>
		<activeBodies public="1" set="method" line="405"><f a=""><x path="Void"/></f></activeBodies>
		<inactiveOrOutSpace public="1" set="method" line="383"><f a=""><x path="Void"/></f></inactiveOrOutSpace>
		<activeInSpace public="1" set="method" line="353"><f a=""><x path="Void"/></f></activeInSpace>
		<removedFromSpace public="1" set="method" line="341"><f a=""><x path="Void"/></f></removedFromSpace>
		<addedToSpace public="1" set="method" line="329"><f a=""><x path="Void"/></f></addedToSpace>
		<deactivate public="1" set="method" line="326"><f a=""><x path="Void"/></f></deactivate>
		<activate public="1" set="method" line="323"><f a=""><x path="Void"/></f></activate>
		<dealloc_cbSet public="1" set="method" line="289"><f a=""><x path="Void"/></f></dealloc_cbSet>
		<alloc_cbSet public="1" set="method" line="275"><f a=""><x path="Void"/></f></alloc_cbSet>
		<insert_cbtype public="1" set="method" line="248"><f a="cb">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Void"/>
</f></insert_cbtype>
		<wrap_cbTypes_adder set="method" line="244"><f a="cb">
	<c path="nape.callbacks.CbType"/>
	<x path="Bool"/>
</f></wrap_cbTypes_adder>
		<wrap_cbTypes_subber set="method" line="230"><f a="pcb">
	<c path="nape.callbacks.CbType"/>
	<x path="Void"/>
</f></wrap_cbTypes_subber>
		<immutable_cbTypes set="method" line="226"><f a=""><x path="Void"/></f></immutable_cbTypes>
		<setupcbTypes public="1" set="method" line="216"><f a=""><x path="Void"/></f></setupcbTypes>
		<wrap_cbTypes public="1"><c path="nape.callbacks.CbTypeList"/></wrap_cbTypes>
		<cbSet public="1"><c path="zpp_nape.callbacks.ZPP_CbSet"/></cbSet>
		<cbTypes public="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></cbTypes>
		<immutable_midstep public="1" set="method" line="208"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></immutable_midstep>
		<__velocity public="1"><x path="Bool"/></__velocity>
		<ignore public="1"><x path="Bool"/></ignore>
		<component public="1"><c path="zpp_nape.space.ZPP_Component"/></component>
		<removeOnBreak public="1"><x path="Bool"/></removeOnBreak>
		<breakUnderError public="1"><x path="Bool"/></breakUnderError>
		<breakUnderForce public="1"><x path="Bool"/></breakUnderForce>
		<maxError public="1"><x path="Float"/></maxError>
		<maxForce public="1"><x path="Float"/></maxForce>
		<damping public="1"><x path="Float"/></damping>
		<frequency public="1"><x path="Float"/></frequency>
		<stiff public="1"><x path="Bool"/></stiff>
		<active public="1"><x path="Bool"/></active>
		<space public="1"><c path="zpp_nape.space.ZPP_Space"/></space>
		<compound public="1"><c path="zpp_nape.phys.ZPP_Compound"/></compound>
		<userData public="1"><d><d/></d></userData>
		<id public="1"><x path="Int"/></id>
		<clear public="1" set="method" line="176"><f a=""><x path="Void"/></f></clear>
		<outer public="1"><c path="nape.constraint.Constraint"/></outer>
		<new public="1" set="method" line="193"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_AngleJoint" params="" file="libSrc/napeLib/zpp_nape/constraint/AngleJoint.hx" module="zpp_nape.constraint.AngleJoint">
		<extends path="zpp_nape.constraint.ZPP_Constraint"/>
		<draw public="1" set="method" line="579" override="1"><f a="g">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></draw>
		<applyImpulsePos public="1" set="method" line="532" override="1"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<applyImpulseVel public="1" set="method" line="493" override="1"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<warmStart public="1" set="method" line="481" override="1"><f a=""><x path="Void"/></f></warmStart>
		<preStep public="1" set="method" line="417" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<clearcache public="1" set="method" line="412" override="1"><f a=""><x path="Void"/></f></clearcache>
		<pair_exists public="1" set="method" line="409" override="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<forest public="1" set="method" line="311" override="1"><f a=""><x path="Void"/></f></forest>
		<wake_connected public="1" set="method" line="307" override="1"><f a=""><x path="Void"/></f></wake_connected>
		<validate public="1" set="method" line="300" override="1"><f a=""><x path="Void"/></f></validate>
		<copy public="1" set="method" line="245" override="1"><f a="?dict:?todo">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<stepped public="1"><x path="Bool"/></stepped>
		<bias public="1"><x path="Float"/></bias>
		<gamma public="1"><x path="Float"/></gamma>
		<jMax public="1"><x path="Float"/></jMax>
		<jAcc public="1"><x path="Float"/></jAcc>
		<kMass public="1"><x path="Float"/></kMass>
		<b2 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b2>
		<b1 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b1>
		<inactiveBodies public="1" set="method" line="229" override="1"><f a=""><x path="Void"/></f></inactiveBodies>
		<activeBodies public="1" set="method" line="221" override="1"><f a=""><x path="Void"/></f></activeBodies>
		<bodyImpulse public="1" set="method" line="214"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<is_slack public="1" get="inline" set="null" line="184"><f a=""><x path="Bool"/></f></is_slack>
		<scale public="1"><x path="Float"/></scale>
		<equal public="1"><x path="Bool"/></equal>
		<slack public="1"><x path="Bool"/></slack>
		<jointMax public="1"><x path="Float"/></jointMax>
		<jointMin public="1"><x path="Float"/></jointMin>
		<ratio public="1"><x path="Float"/></ratio>
		<outer_zn public="1"><c path="nape.constraint.AngleJoint"/></outer_zn>
		<new public="1" set="method" line="292"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_AngleDraw" params="" file="libSrc/napeLib/zpp_nape/constraint/AngleJoint.hx" module="zpp_nape.constraint.AngleJoint">
		<indicator public="1" set="method" line="652" static="1"><f a="g:c:ang:rad:col">
	<c path="nape.util.Debug"/>
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></indicator>
		<maxarc line="657" static="1"><x path="Float"/></maxarc>
		<drawSpiralSpring public="1" set="method" line="658" static="1"><f a="g:c:a0:a1:r0:r1:col:?coils">
	<c path="nape.util.Debug"/>
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawSpiralSpring>
		<drawSpiral public="1" set="method" line="736" static="1"><f a="g:c:a0:a1:r0:r1:col">
	<c path="nape.util.Debug"/>
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawSpiral>
	</class>
	<class path="zpp_nape.constraint.ZPP_CopyHelper" params="" file="libSrc/napeLib/zpp_nape/constraint/Constraint.hx" module="zpp_nape.constraint.Constraint">
		<dict public="1" set="method" line="560" static="1"><f a="id:bc">
	<x path="Int"/>
	<c path="nape.phys.Body"/>
	<c path="zpp_nape.constraint.ZPP_CopyHelper"/>
</f></dict>
		<todo public="1" set="method" line="566" static="1"><f a="id:cb">
	<x path="Int"/>
	<f a="">
		<c path="nape.phys.Body"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.constraint.ZPP_CopyHelper"/>
</f></todo>
		<cb public="1"><f a="">
	<c path="nape.phys.Body"/>
	<x path="Void"/>
</f></cb>
		<bc public="1"><c path="nape.phys.Body"/></bc>
		<id public="1"><x path="Int"/></id>
		<new set="method" line="559"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_DistanceJoint" params="" file="libSrc/napeLib/zpp_nape/constraint/DistanceJoint.hx" module="zpp_nape.constraint.DistanceJoint">
		<extends path="zpp_nape.constraint.ZPP_Constraint"/>
		<draw public="1" set="method" line="1288" override="1"><f a="g">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></draw>
		<applyImpulsePos public="1" set="method" line="977" override="1"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<applyImpulseVel public="1" set="method" line="887" override="1"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<warmStart public="1" set="method" line="823" override="1"><f a=""><x path="Void"/></f></warmStart>
		<preStep public="1" set="method" line="687" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<clearcache public="1" set="method" line="683" override="1"><f a=""><x path="Void"/></f></clearcache>
		<pair_exists public="1" set="method" line="680" override="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<forest public="1" set="method" line="582" override="1"><f a=""><x path="Void"/></f></forest>
		<wake_connected public="1" set="method" line="578" override="1"><f a=""><x path="Void"/></f></wake_connected>
		<validate public="1" set="method" line="571" override="1"><f a=""><x path="Void"/></f></validate>
		<copy public="1" set="method" line="433" override="1"><f a="?dict:?todo">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<stepped public="1"><x path="Bool"/></stepped>
		<bias public="1"><x path="Float"/></bias>
		<gamma public="1"><x path="Float"/></gamma>
		<jMax public="1"><x path="Float"/></jMax>
		<jAcc public="1"><x path="Float"/></jAcc>
		<kMass public="1"><x path="Float"/></kMass>
		<wrap_a2 public="1"><c path="nape.geom.Vec2"/></wrap_a2>
		<setup_a2 public="1" set="method" line="420"><f a=""><x path="Void"/></f></setup_a2>
		<invalidate_a2 set="method" line="396"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a2>
		<validate_a2 set="method" line="374"><f a=""><x path="Void"/></f></validate_a2>
		<a2rely public="1"><x path="Float"/></a2rely>
		<a2relx public="1"><x path="Float"/></a2relx>
		<a2localy public="1"><x path="Float"/></a2localy>
		<a2localx public="1"><x path="Float"/></a2localx>
		<b2 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b2>
		<wrap_a1 public="1"><c path="nape.geom.Vec2"/></wrap_a1>
		<setup_a1 public="1" set="method" line="362"><f a=""><x path="Void"/></f></setup_a1>
		<invalidate_a1 set="method" line="338"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a1>
		<validate_a1 set="method" line="316"><f a=""><x path="Void"/></f></validate_a1>
		<a1rely public="1"><x path="Float"/></a1rely>
		<a1relx public="1"><x path="Float"/></a1relx>
		<a1localy public="1"><x path="Float"/></a1localy>
		<a1localx public="1"><x path="Float"/></a1localx>
		<b1 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b1>
		<inactiveBodies public="1" set="method" line="303" override="1"><f a=""><x path="Void"/></f></inactiveBodies>
		<activeBodies public="1" set="method" line="295" override="1"><f a=""><x path="Void"/></f></activeBodies>
		<bodyImpulse public="1" set="method" line="288"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<cx2 public="1"><x path="Float"/></cx2>
		<cx1 public="1"><x path="Float"/></cx1>
		<ny public="1"><x path="Float"/></ny>
		<nx public="1"><x path="Float"/></nx>
		<is_slack public="1" get="inline" set="null" line="182"><f a=""><x path="Bool"/></f></is_slack>
		<equal public="1"><x path="Bool"/></equal>
		<slack public="1"><x path="Bool"/></slack>
		<jointMax public="1"><x path="Float"/></jointMax>
		<jointMin public="1"><x path="Float"/></jointMin>
		<outer_zn public="1"><c path="nape.constraint.DistanceJoint"/></outer_zn>
		<new public="1" set="method" line="480"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_LineJoint" params="" file="libSrc/napeLib/zpp_nape/constraint/LineJoint.hx" module="zpp_nape.constraint.LineJoint">
		<extends path="zpp_nape.constraint.ZPP_Constraint"/>
		<draw public="1" set="method" line="1545" override="1"><f a="g">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></draw>
		<applyImpulsePos public="1" set="method" line="1279" override="1"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<applyImpulseVel public="1" set="method" line="1076" override="1"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<warmStart public="1" set="method" line="994" override="1"><f a=""><x path="Void"/></f></warmStart>
		<preStep public="1" set="method" line="778" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<clearcache public="1" set="method" line="755" override="1"><f a=""><x path="Void"/></f></clearcache>
		<pair_exists public="1" set="method" line="752" override="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<forest public="1" set="method" line="654" override="1"><f a=""><x path="Void"/></f></forest>
		<wake_connected public="1" set="method" line="650" override="1"><f a=""><x path="Void"/></f></wake_connected>
		<validate public="1" set="method" line="642" override="1"><f a=""><x path="Void"/></f></validate>
		<copy public="1" set="method" line="442" override="1"><f a="?dict:?todo">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<stepped public="1"><x path="Bool"/></stepped>
		<biasy public="1"><x path="Float"/></biasy>
		<biasx public="1"><x path="Float"/></biasx>
		<gamma public="1"><x path="Float"/></gamma>
		<jMax public="1"><x path="Float"/></jMax>
		<jAccy public="1"><x path="Float"/></jAccy>
		<jAccx public="1"><x path="Float"/></jAccx>
		<kMassc public="1"><x path="Float"/></kMassc>
		<kMassb public="1"><x path="Float"/></kMassb>
		<kMassa public="1"><x path="Float"/></kMassa>
		<validate_norm public="1" set="method" line="402"><f a=""><x path="Void"/></f></validate_norm>
		<wrap_n public="1"><c path="nape.geom.Vec2"/></wrap_n>
		<setup_n public="1" set="method" line="395"><f a=""><x path="Void"/></f></setup_n>
		<invalidate_n set="method" line="368"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_n>
		<validate_n set="method" line="346"><f a=""><x path="Void"/></f></validate_n>
		<nrely public="1"><x path="Float"/></nrely>
		<nrelx public="1"><x path="Float"/></nrelx>
		<nlocaly public="1"><x path="Float"/></nlocaly>
		<nlocalx public="1"><x path="Float"/></nlocalx>
		<zip_n public="1"><x path="Bool"/></zip_n>
		<wrap_a2 public="1"><c path="nape.geom.Vec2"/></wrap_a2>
		<setup_a2 public="1" set="method" line="334"><f a=""><x path="Void"/></f></setup_a2>
		<invalidate_a2 set="method" line="310"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a2>
		<validate_a2 set="method" line="288"><f a=""><x path="Void"/></f></validate_a2>
		<a2rely public="1"><x path="Float"/></a2rely>
		<a2relx public="1"><x path="Float"/></a2relx>
		<a2localy public="1"><x path="Float"/></a2localy>
		<a2localx public="1"><x path="Float"/></a2localx>
		<b2 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b2>
		<wrap_a1 public="1"><c path="nape.geom.Vec2"/></wrap_a1>
		<setup_a1 public="1" set="method" line="276"><f a=""><x path="Void"/></f></setup_a1>
		<invalidate_a1 set="method" line="252"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a1>
		<validate_a1 set="method" line="230"><f a=""><x path="Void"/></f></validate_a1>
		<a1rely public="1"><x path="Float"/></a1rely>
		<a1relx public="1"><x path="Float"/></a1relx>
		<a1localy public="1"><x path="Float"/></a1localy>
		<a1localx public="1"><x path="Float"/></a1localx>
		<b1 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b1>
		<inactiveBodies public="1" set="method" line="217" override="1"><f a=""><x path="Void"/></f></inactiveBodies>
		<activeBodies public="1" set="method" line="209" override="1"><f a=""><x path="Void"/></f></activeBodies>
		<bodyImpulse public="1" set="method" line="184"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<cx2 public="1"><x path="Float"/></cx2>
		<cx1 public="1"><x path="Float"/></cx1>
		<dot2 public="1"><x path="Float"/></dot2>
		<dot1 public="1"><x path="Float"/></dot1>
		<equal public="1"><x path="Bool"/></equal>
		<jointMax public="1"><x path="Float"/></jointMax>
		<jointMin public="1"><x path="Float"/></jointMin>
		<scale public="1"><x path="Float"/></scale>
		<outer_zn public="1"><c path="nape.constraint.LineJoint"/></outer_zn>
		<new public="1" set="method" line="489"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_MotorJoint" params="" file="libSrc/napeLib/zpp_nape/constraint/MotorJoint.hx" module="zpp_nape.constraint.MotorJoint">
		<extends path="zpp_nape.constraint.ZPP_Constraint"/>
		<applyImpulsePos public="1" set="method" line="435" override="1"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<applyImpulseVel public="1" set="method" line="402" override="1"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<warmStart public="1" set="method" line="396" override="1"><f a=""><x path="Void"/></f></warmStart>
		<preStep public="1" set="method" line="375" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<clearcache public="1" set="method" line="371" override="1"><f a=""><x path="Void"/></f></clearcache>
		<pair_exists public="1" set="method" line="368" override="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<forest public="1" set="method" line="270" override="1"><f a=""><x path="Void"/></f></forest>
		<wake_connected public="1" set="method" line="266" override="1"><f a=""><x path="Void"/></f></wake_connected>
		<validate public="1" set="method" line="260" override="1"><f a=""><x path="Void"/></f></validate>
		<copy public="1" set="method" line="207" override="1"><f a="?dict:?todo">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<stepped public="1"><x path="Bool"/></stepped>
		<jMax public="1"><x path="Float"/></jMax>
		<jAcc public="1"><x path="Float"/></jAcc>
		<kMass public="1"><x path="Float"/></kMass>
		<b2 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b2>
		<b1 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b1>
		<inactiveBodies public="1" set="method" line="193" override="1"><f a=""><x path="Void"/></f></inactiveBodies>
		<activeBodies public="1" set="method" line="185" override="1"><f a=""><x path="Void"/></f></activeBodies>
		<bodyImpulse public="1" set="method" line="178"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<rate public="1"><x path="Float"/></rate>
		<ratio public="1"><x path="Float"/></ratio>
		<outer_zn public="1"><c path="nape.constraint.MotorJoint"/></outer_zn>
		<new public="1" set="method" line="254"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_PivotJoint" params="" file="libSrc/napeLib/zpp_nape/constraint/PivotJoint.hx" module="zpp_nape.constraint.PivotJoint">
		<extends path="zpp_nape.constraint.ZPP_Constraint"/>
		<draw public="1" set="method" line="1342" override="1"><f a="g">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></draw>
		<applyImpulsePos public="1" set="method" line="1034" override="1"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<applyImpulseVel public="1" set="method" line="858" override="1"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<warmStart public="1" set="method" line="794" override="1"><f a=""><x path="Void"/></f></warmStart>
		<preStep public="1" set="method" line="615" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<clearcache public="1" set="method" line="592" override="1"><f a=""><x path="Void"/></f></clearcache>
		<pair_exists public="1" set="method" line="589" override="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<forest public="1" set="method" line="491" override="1"><f a=""><x path="Void"/></f></forest>
		<wake_connected public="1" set="method" line="487" override="1"><f a=""><x path="Void"/></f></wake_connected>
		<validate public="1" set="method" line="481" override="1"><f a=""><x path="Void"/></f></validate>
		<copy public="1" set="method" line="325" override="1"><f a="?dict:?todo">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<stepped public="1"><x path="Bool"/></stepped>
		<biasy public="1"><x path="Float"/></biasy>
		<biasx public="1"><x path="Float"/></biasx>
		<gamma public="1"><x path="Float"/></gamma>
		<jMax public="1"><x path="Float"/></jMax>
		<jAccy public="1"><x path="Float"/></jAccy>
		<jAccx public="1"><x path="Float"/></jAccx>
		<kMassc public="1"><x path="Float"/></kMassc>
		<kMassb public="1"><x path="Float"/></kMassb>
		<kMassa public="1"><x path="Float"/></kMassa>
		<wrap_a2 public="1"><c path="nape.geom.Vec2"/></wrap_a2>
		<setup_a2 public="1" set="method" line="308"><f a=""><x path="Void"/></f></setup_a2>
		<invalidate_a2 set="method" line="284"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a2>
		<validate_a2 set="method" line="262"><f a=""><x path="Void"/></f></validate_a2>
		<a2rely public="1"><x path="Float"/></a2rely>
		<a2relx public="1"><x path="Float"/></a2relx>
		<a2localy public="1"><x path="Float"/></a2localy>
		<a2localx public="1"><x path="Float"/></a2localx>
		<b2 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b2>
		<wrap_a1 public="1"><c path="nape.geom.Vec2"/></wrap_a1>
		<setup_a1 public="1" set="method" line="250"><f a=""><x path="Void"/></f></setup_a1>
		<invalidate_a1 set="method" line="226"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a1>
		<validate_a1 set="method" line="204"><f a=""><x path="Void"/></f></validate_a1>
		<a1rely public="1"><x path="Float"/></a1rely>
		<a1relx public="1"><x path="Float"/></a1relx>
		<a1localy public="1"><x path="Float"/></a1localy>
		<a1localx public="1"><x path="Float"/></a1localx>
		<b1 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b1>
		<inactiveBodies public="1" set="method" line="191" override="1"><f a=""><x path="Void"/></f></inactiveBodies>
		<activeBodies public="1" set="method" line="183" override="1"><f a=""><x path="Void"/></f></activeBodies>
		<bodyImpulse public="1" set="method" line="176"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<outer_zn public="1"><c path="nape.constraint.PivotJoint"/></outer_zn>
		<new public="1" set="method" line="372"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_PulleyJoint" params="" file="libSrc/napeLib/zpp_nape/constraint/PulleyJoint.hx" module="zpp_nape.constraint.PulleyJoint">
		<extends path="zpp_nape.constraint.ZPP_Constraint"/>
		<drawLink public="1" set="method" line="2216"><f a="g:a1:a2:n:nl:bias:scale:ca:cb">
	<c path="nape.util.Debug"/>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawLink>
		<draw public="1" set="method" line="2192" override="1"><f a="g">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></draw>
		<applyImpulsePos public="1" set="method" line="1633" override="1"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<applyImpulseVel public="1" set="method" line="1487" override="1"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<warmStart public="1" set="method" line="1367" override="1"><f a=""><x path="Void"/></f></warmStart>
		<preStep public="1" set="method" line="1165" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<clearcache public="1" set="method" line="1161" override="1"><f a=""><x path="Void"/></f></clearcache>
		<pair_exists public="1" set="method" line="1158" override="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<forest public="1" set="method" line="964" override="1"><f a=""><x path="Void"/></f></forest>
		<wake_connected public="1" set="method" line="958" override="1"><f a=""><x path="Void"/></f></wake_connected>
		<validate public="1" set="method" line="950" override="1"><f a=""><x path="Void"/></f></validate>
		<copy public="1" set="method" line="646" override="1"><f a="?dict:?todo">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<stepped public="1"><x path="Bool"/></stepped>
		<bias public="1"><x path="Float"/></bias>
		<gamma public="1"><x path="Float"/></gamma>
		<jMax public="1"><x path="Float"/></jMax>
		<jAcc public="1"><x path="Float"/></jAcc>
		<kMass public="1"><x path="Float"/></kMass>
		<wrap_a4 public="1"><c path="nape.geom.Vec2"/></wrap_a4>
		<setup_a4 public="1" set="method" line="633"><f a=""><x path="Void"/></f></setup_a4>
		<invalidate_a4 set="method" line="609"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a4>
		<validate_a4 set="method" line="587"><f a=""><x path="Void"/></f></validate_a4>
		<a4rely public="1"><x path="Float"/></a4rely>
		<a4relx public="1"><x path="Float"/></a4relx>
		<a4localy public="1"><x path="Float"/></a4localy>
		<a4localx public="1"><x path="Float"/></a4localx>
		<b4 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b4>
		<wrap_a3 public="1"><c path="nape.geom.Vec2"/></wrap_a3>
		<setup_a3 public="1" set="method" line="575"><f a=""><x path="Void"/></f></setup_a3>
		<invalidate_a3 set="method" line="551"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a3>
		<validate_a3 set="method" line="529"><f a=""><x path="Void"/></f></validate_a3>
		<a3rely public="1"><x path="Float"/></a3rely>
		<a3relx public="1"><x path="Float"/></a3relx>
		<a3localy public="1"><x path="Float"/></a3localy>
		<a3localx public="1"><x path="Float"/></a3localx>
		<b3 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b3>
		<wrap_a2 public="1"><c path="nape.geom.Vec2"/></wrap_a2>
		<setup_a2 public="1" set="method" line="517"><f a=""><x path="Void"/></f></setup_a2>
		<invalidate_a2 set="method" line="493"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a2>
		<validate_a2 set="method" line="471"><f a=""><x path="Void"/></f></validate_a2>
		<a2rely public="1"><x path="Float"/></a2rely>
		<a2relx public="1"><x path="Float"/></a2relx>
		<a2localy public="1"><x path="Float"/></a2localy>
		<a2localx public="1"><x path="Float"/></a2localx>
		<b2 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b2>
		<wrap_a1 public="1"><c path="nape.geom.Vec2"/></wrap_a1>
		<setup_a1 public="1" set="method" line="459"><f a=""><x path="Void"/></f></setup_a1>
		<invalidate_a1 set="method" line="435"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a1>
		<validate_a1 set="method" line="413"><f a=""><x path="Void"/></f></validate_a1>
		<a1rely public="1"><x path="Float"/></a1rely>
		<a1relx public="1"><x path="Float"/></a1relx>
		<a1localy public="1"><x path="Float"/></a1localy>
		<a1localx public="1"><x path="Float"/></a1localx>
		<b1 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b1>
		<inactiveBodies public="1" set="method" line="394" override="1"><f a=""><x path="Void"/></f></inactiveBodies>
		<activeBodies public="1" set="method" line="380" override="1"><f a=""><x path="Void"/></f></activeBodies>
		<bodyImpulse public="1" set="method" line="353"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<cx4 public="1"><x path="Float"/></cx4>
		<cx3 public="1"><x path="Float"/></cx3>
		<cx2 public="1"><x path="Float"/></cx2>
		<cx1 public="1"><x path="Float"/></cx1>
		<n34y public="1"><x path="Float"/></n34y>
		<n34x public="1"><x path="Float"/></n34x>
		<n12y public="1"><x path="Float"/></n12y>
		<n12x public="1"><x path="Float"/></n12x>
		<is_slack public="1" get="inline" set="null" line="183"><f a=""><x path="Bool"/></f></is_slack>
		<equal public="1"><x path="Bool"/></equal>
		<slack public="1"><x path="Bool"/></slack>
		<jointMax public="1"><x path="Float"/></jointMax>
		<jointMin public="1"><x path="Float"/></jointMin>
		<ratio public="1"><x path="Float"/></ratio>
		<outer_zn public="1"><c path="nape.constraint.PulleyJoint"/></outer_zn>
		<new public="1" set="method" line="735"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_UserConstraint" params="" file="libSrc/napeLib/zpp_nape/constraint/UserConstraint.hx" module="zpp_nape.constraint.UserConstraint">
		<extends path="zpp_nape.constraint.ZPP_Constraint"/>
		<draw public="1" set="method" line="564" override="1"><f a="g">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></draw>
		<applyImpulsePos public="1" set="method" line="533" override="1"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<applyImpulseVel public="1" set="method" line="499" override="1"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<jOld><t path="nape.TArray"><x path="Float"/></t></jOld>
		<J><t path="nape.TArray"><x path="Float"/></t></J>
		<warmStart public="1" set="method" line="477" override="1"><f a=""><x path="Void"/></f></warmStart>
		<vec3><c path="nape.geom.Vec3"/></vec3>
		<preStep public="1" set="method" line="441" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<Keff public="1"><t path="nape.TArray"><x path="Float"/></t></Keff>
		<jMax public="1"><x path="Float"/></jMax>
		<velonly public="1"><x path="Bool"/></velonly>
		<gamma public="1"><x path="Float"/></gamma>
		<soft public="1"><x path="Float"/></soft>
		<transform public="1" set="method" line="415"><f a="L:x">
	<t path="nape.TArray"><x path="Float"/></t>
	<t path="nape.TArray"><x path="Float"/></t>
	<x path="Void"/>
</f></transform>
		<y><t path="nape.TArray"><x path="Float"/></t></y>
		<solve public="1" set="method" line="392"><f a="m">
	<t path="nape.TArray"><x path="Float"/></t>
	<t path="nape.TArray"><x path="Float"/></t>
</f></solve>
		<L><t path="nape.TArray"><x path="Float"/></t></L>
		<_clamp public="1" set="method" line="384"><f a="v:max">
	<t path="nape.TArray"><x path="Float"/></t>
	<x path="Float"/>
	<x path="Void"/>
</f></_clamp>
		<lsq public="1" set="method" line="379"><f a="v">
	<t path="nape.TArray"><x path="Float"/></t>
	<x path="Float"/>
</f></lsq>
		<clearcache public="1" set="method" line="375" override="1"><f a=""><x path="Void"/></f></clearcache>
		<broken public="1" set="method" line="372" override="1"><f a=""><x path="Void"/></f></broken>
		<pair_exists public="1" set="method" line="356" override="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<forest public="1" set="method" line="304" override="1"><f a=""><x path="Void"/></f></forest>
		<wake_connected public="1" set="method" line="299" override="1"><f a=""><x path="Void"/></f></wake_connected>
		<validate public="1" set="method" line="295" override="1"><f a=""><x path="Void"/></f></validate>
		<copy public="1" set="method" line="254" override="1"><f a="?dict:?todo">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<stepped public="1"><x path="Bool"/></stepped>
		<inactiveBodies public="1" set="method" line="248" override="1"><f a=""><x path="Void"/></f></inactiveBodies>
		<activeBodies public="1" set="method" line="243" override="1"><f a=""><x path="Void"/></f></activeBodies>
		<bodyImpulse public="1" set="method" line="237"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<remBody public="1" set="method" line="207"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></remBody>
		<addBody public="1" set="method" line="183"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></addBody>
		<bias public="1"><t path="nape.TArray"><x path="Float"/></t></bias>
		<jAcc public="1"><t path="nape.TArray"><x path="Float"/></t></jAcc>
		<dim public="1"><x path="Int"/></dim>
		<bodies public="1"><t path="nape.TArray"><c path="zpp_nape.constraint.ZPP_UserBody"/></t></bodies>
		<bindVec2_invalidate public="1" set="method" line="176"><f a="_">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></bindVec2_invalidate>
		<outer_zn public="1"><c path="nape.constraint.UserConstraint"/></outer_zn>
		<new public="1" set="method" line="260"><f a="dim:velonly">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_UserBody" params="" file="libSrc/napeLib/zpp_nape/constraint/UserConstraint.hx" module="zpp_nape.constraint.UserConstraint">
		<body public="1"><c path="zpp_nape.phys.ZPP_Body"/></body>
		<cnt public="1"><x path="Int"/></cnt>
		<new public="1" set="method" line="572"><f a="cnt:body">
	<x path="Int"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.constraint.ZPP_WeldJoint" params="" file="libSrc/napeLib/zpp_nape/constraint/WeldJoint.hx" module="zpp_nape.constraint.WeldJoint">
		<extends path="zpp_nape.constraint.ZPP_Constraint"/>
		<draw public="1" set="method" line="1531" override="1"><f a="g">
	<c path="nape.util.Debug"/>
	<x path="Void"/>
</f></draw>
		<applyImpulsePos public="1" set="method" line="1143" override="1"><f a=""><x path="Bool"/></f></applyImpulsePos>
		<applyImpulseVel public="1" set="method" line="922" override="1"><f a=""><x path="Bool"/></f></applyImpulseVel>
		<warmStart public="1" set="method" line="858" override="1"><f a=""><x path="Void"/></f></warmStart>
		<preStep public="1" set="method" line="628" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<clearcache public="1" set="method" line="602" override="1"><f a=""><x path="Void"/></f></clearcache>
		<pair_exists public="1" set="method" line="599" override="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></pair_exists>
		<forest public="1" set="method" line="501" override="1"><f a=""><x path="Void"/></f></forest>
		<wake_connected public="1" set="method" line="497" override="1"><f a=""><x path="Void"/></f></wake_connected>
		<validate public="1" set="method" line="491" override="1"><f a=""><x path="Void"/></f></validate>
		<copy public="1" set="method" line="331" override="1"><f a="?dict:?todo">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.constraint.Constraint"/>
</f></copy>
		<stepped public="1"><x path="Bool"/></stepped>
		<biasz public="1"><x path="Float"/></biasz>
		<biasy public="1"><x path="Float"/></biasy>
		<biasx public="1"><x path="Float"/></biasx>
		<gamma public="1"><x path="Float"/></gamma>
		<jMax public="1"><x path="Float"/></jMax>
		<jAccz public="1"><x path="Float"/></jAccz>
		<jAccy public="1"><x path="Float"/></jAccy>
		<jAccx public="1"><x path="Float"/></jAccx>
		<kMassf public="1"><x path="Float"/></kMassf>
		<kMasse public="1"><x path="Float"/></kMasse>
		<kMassc public="1"><x path="Float"/></kMassc>
		<kMassd public="1"><x path="Float"/></kMassd>
		<kMassb public="1"><x path="Float"/></kMassb>
		<kMassa public="1"><x path="Float"/></kMassa>
		<phase public="1"><x path="Float"/></phase>
		<wrap_a2 public="1"><c path="nape.geom.Vec2"/></wrap_a2>
		<setup_a2 public="1" set="method" line="308"><f a=""><x path="Void"/></f></setup_a2>
		<invalidate_a2 set="method" line="284"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a2>
		<validate_a2 set="method" line="262"><f a=""><x path="Void"/></f></validate_a2>
		<a2rely public="1"><x path="Float"/></a2rely>
		<a2relx public="1"><x path="Float"/></a2relx>
		<a2localy public="1"><x path="Float"/></a2localy>
		<a2localx public="1"><x path="Float"/></a2localx>
		<b2 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b2>
		<wrap_a1 public="1"><c path="nape.geom.Vec2"/></wrap_a1>
		<setup_a1 public="1" set="method" line="250"><f a=""><x path="Void"/></f></setup_a1>
		<invalidate_a1 set="method" line="226"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></invalidate_a1>
		<validate_a1 set="method" line="204"><f a=""><x path="Void"/></f></validate_a1>
		<a1rely public="1"><x path="Float"/></a1rely>
		<a1relx public="1"><x path="Float"/></a1relx>
		<a1localy public="1"><x path="Float"/></a1localy>
		<a1localx public="1"><x path="Float"/></a1localx>
		<b1 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b1>
		<inactiveBodies public="1" set="method" line="191" override="1"><f a=""><x path="Void"/></f></inactiveBodies>
		<activeBodies public="1" set="method" line="183" override="1"><f a=""><x path="Void"/></f></activeBodies>
		<bodyImpulse public="1" set="method" line="176"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="nape.geom.Vec3"/>
</f></bodyImpulse>
		<outer_zn public="1"><c path="nape.constraint.WeldJoint"/></outer_zn>
		<new public="1" set="method" line="378"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_Arbiter" params="" file="libSrc/napeLib/zpp_nape/dynamics/Arbiter.hx" module="zpp_nape.dynamics.Arbiter">
		<internal public="1" line="179" static="1"><x path="Bool"/></internal>
		<COL public="1" line="261" static="1"><x path="Int"/></COL>
		<FLUID public="1" line="262" static="1"><x path="Int"/></FLUID>
		<SENSOR public="1" line="263" static="1"><x path="Int"/></SENSOR>
		<sup_retire public="1" get="inline" set="null" line="308"><f a=""><x path="Void"/></f></sup_retire>
		<sup_assign public="1" get="inline" set="null" line="290"><f a="s1:s2:id:di">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sup_assign>
		<lazyRetire public="1" get="inline" set="null" line="269"><f a="s:?b">
	<c path="zpp_nape.space.ZPP_Space"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></lazyRetire>
		<sensorarb public="1"><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></sensorarb>
		<fluidarb public="1"><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></fluidarb>
		<colarb public="1"><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></colarb>
		<type public="1"><x path="Int"/></type>
		<swap_features public="1" get="inline" set="null" line="235"><f a=""><x path="Void"/></f></swap_features>
		<pair public="1"><c path="zpp_nape.space.ZPP_AABBPair"/></pair>
		<ws2 public="1"><c path="zpp_nape.shape.ZPP_Shape"/></ws2>
		<ws1 public="1"><c path="zpp_nape.shape.ZPP_Shape"/></ws1>
		<b2 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b2>
		<b1 public="1"><c path="zpp_nape.phys.ZPP_Body"/></b1>
		<invalidated public="1"><x path="Bool"/></invalidated>
		<acting public="1" get="inline" set="null" line="224"><f a=""><x path="Bool"/></f></acting>
		<immState public="1"><x path="Int"/></immState>
		<fresh public="1"><x path="Bool"/></fresh>
		<continuous public="1"><x path="Bool"/></continuous>
		<presentable public="1"><x path="Bool"/></presentable>
		<intchange public="1"><x path="Bool"/></intchange>
		<present public="1"><x path="Int"/></present>
		<sleeping public="1"><x path="Bool"/></sleeping>
		<cleared public="1"><x path="Bool"/></cleared>
		<active public="1"><x path="Bool"/></active>
		<endGenerated public="1"><x path="Int"/></endGenerated>
		<sleep_stamp public="1"><x path="Int"/></sleep_stamp>
		<up_stamp public="1"><x path="Int"/></up_stamp>
		<stamp public="1"><x path="Int"/></stamp>
		<di public="1"><x path="Int"/></di>
		<id public="1"><x path="Int"/></id>
		<hnext public="1"><c path="zpp_nape.dynamics.ZPP_Arbiter"/></hnext>
		<inactiveme public="1" get="inline" set="null" line="199"><f a=""><x path="Bool"/></f></inactiveme>
		<wrapper public="1" set="method" line="180"><f a=""><c path="nape.dynamics.Arbiter"/></f></wrapper>
		<outer public="1"><c path="nape.dynamics.Arbiter"/></outer>
		<new public="1" set="method" line="203"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_SensorArbiter" params="" file="libSrc/napeLib/zpp_nape/dynamics/Arbiter.hx" module="zpp_nape.dynamics.Arbiter">
		<extends path="zpp_nape.dynamics.ZPP_Arbiter"/>
		<zpp_pool public="1" line="357" static="1"><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></zpp_pool>
		<makeimmutable public="1" get="inline" set="null" line="442"><f a=""><x path="Void"/></f></makeimmutable>
		<makemutable public="1" get="inline" set="null" line="439"><f a=""><x path="Void"/></f></makemutable>
		<retire public="1" get="inline" set="null" line="417"><f a=""><x path="Void"/></f></retire>
		<assign public="1" get="inline" set="null" line="412"><f a="s1:s2:id:di">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></assign>
		<free public="1" get="inline" set="null" line="395"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="383"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></next>
		<new public="1" set="method" line="405"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_FluidArbiter" params="" file="libSrc/napeLib/zpp_nape/dynamics/Arbiter.hx" module="zpp_nape.dynamics.Arbiter">
		<extends path="zpp_nape.dynamics.ZPP_Arbiter"/>
		<zpp_pool public="1" line="448" static="1"><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></zpp_pool>
		<applyImpulseVel public="1" get="inline" set="null" line="1301"><f a=""><x path="Void"/></f></applyImpulseVel>
		<warmStart public="1" get="inline" set="null" line="1267"><f a=""><x path="Void"/></f></warmStart>
		<preStep public="1" get="inline" set="null" line="708"><f a="s:dt">
	<c path="zpp_nape.space.ZPP_Space"/>
	<x path="Float"/>
	<x path="Void"/>
</f></preStep>
		<pre_dt public="1"><x path="Float"/></pre_dt>
		<inject public="1" get="inline" set="null" line="682"><f a="area:cx:cy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></inject>
		<makeimmutable public="1" get="inline" set="null" line="676"><f a=""><x path="Void"/></f></makeimmutable>
		<makemutable public="1" get="inline" set="null" line="670"><f a=""><x path="Void"/></f></makemutable>
		<mutable public="1"><x path="Bool"/></mutable>
		<retire public="1" get="inline" set="null" line="646"><f a=""><x path="Void"/></f></retire>
		<assign public="1" get="inline" set="null" line="600"><f a="s1:s2:id:di">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></assign>
		<getposition public="1" set="method" line="565"><f a=""><x path="Void"/></f></getposition>
		<wrap_position public="1"><c path="nape.geom.Vec2"/></wrap_position>
		<position_invalidate set="method" line="542"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></position_invalidate>
		<position_validate set="method" line="517"><f a=""><x path="Void"/></f></position_validate>
		<buoyy public="1"><x path="Float"/></buoyy>
		<buoyx public="1"><x path="Float"/></buoyx>
		<ny public="1"><x path="Float"/></ny>
		<nx public="1"><x path="Float"/></nx>
		<lgamma public="1"><x path="Float"/></lgamma>
		<dampy public="1"><x path="Float"/></dampy>
		<dampx public="1"><x path="Float"/></dampx>
		<vMassc public="1"><x path="Float"/></vMassc>
		<vMassb public="1"><x path="Float"/></vMassb>
		<vMassa public="1"><x path="Float"/></vMassa>
		<agamma public="1"><x path="Float"/></agamma>
		<adamp public="1"><x path="Float"/></adamp>
		<wMass public="1"><x path="Float"/></wMass>
		<nodrag public="1"><x path="Bool"/></nodrag>
		<r2y public="1"><x path="Float"/></r2y>
		<r2x public="1"><x path="Float"/></r2x>
		<r1y public="1"><x path="Float"/></r1y>
		<r1x public="1"><x path="Float"/></r1x>
		<overlap public="1"><x path="Float"/></overlap>
		<centroidy public="1"><x path="Float"/></centroidy>
		<centroidx public="1"><x path="Float"/></centroidx>
		<free public="1" get="inline" set="null" line="486"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="474"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></next>
		<outer_zn public="1"><c path="nape.dynamics.FluidArbiter"/></outer_zn>
		<new public="1" set="method" line="572"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_ColArbiter" params="" file="libSrc/napeLib/zpp_nape/dynamics/Arbiter.hx" module="zpp_nape.dynamics.Arbiter">
		<extends path="zpp_nape.dynamics.ZPP_Arbiter"/>
		<FACE1 public="1" get="inline" set="null" line="1459" static="1"><x path="Int"/></FACE1>
		<FACE2 public="1" get="inline" set="null" line="1460" static="1"><x path="Int"/></FACE2>
		<CIRCLE public="1" get="inline" set="null" line="1461" static="1"><x path="Int"/></CIRCLE>
		<zpp_pool public="1" line="1479" static="1"><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></zpp_pool>
		<applyImpulsePos public="1" get="inline" set="null" line="2335"><f a=""><x path="Void"/></f></applyImpulsePos>
		<applyImpulseVel public="1" get="inline" set="null" line="2190"><f a=""><x path="Void"/></f></applyImpulseVel>
		<warmStart public="1" get="inline" set="null" line="2120"><f a=""><x path="Void"/></f></warmStart>
		<preStep public="1" get="inline" set="null" line="1875"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></preStep>
		<pre_dt public="1"><x path="Float"/></pre_dt>
		<cleanupContacts public="1" get="inline" set="null" line="1785"><f a=""><x path="Bool"/></f></cleanupContacts>
		<setupcontacts public="1" set="method" line="1776"><f a=""><x path="Void"/></f></setupcontacts>
		<contacts_subber set="method" line="1737"><f a="x">
	<c path="nape.dynamics.Contact"/>
	<x path="Void"/>
</f></contacts_subber>
		<contacts_adder set="method" line="1731"><f a="x">
	<c path="nape.dynamics.Contact"/>
	<x path="Bool"/>
</f></contacts_adder>
		<makeimmutable public="1" get="inline" set="null" line="1726"><f a=""><x path="Void"/></f></makeimmutable>
		<makemutable public="1" get="inline" set="null" line="1719"><f a=""><x path="Void"/></f></makemutable>
		<mutable public="1"><x path="Bool"/></mutable>
		<retire public="1" get="inline" set="null" line="1675"><f a=""><x path="Void"/></f></retire>
		<validate_props public="1" get="inline" set="null" line="1667"><f a=""><x path="Void"/></f></validate_props>
		<calcProperties public="1" get="inline" set="null" line="1647"><f a=""><x path="Void"/></f></calcProperties>
		<assign public="1" get="inline" set="null" line="1639"><f a="s1:s2:id:di">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></assign>
		<injectContact public="1" get="inline" set="null" line="1551"><f a="px:py:nx:ny:dist:hash:?posOnly">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></injectContact>
		<stat public="1"><x path="Bool"/></stat>
		<free public="1" get="inline" set="null" line="1525"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="1513"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></next>
		<hpc2 public="1"><x path="Bool"/></hpc2>
		<hc2 public="1"><x path="Bool"/></hc2>
		<oc2 public="1"><c path="zpp_nape.dynamics.ZPP_Contact"/></oc2>
		<c2 public="1"><c path="zpp_nape.dynamics.ZPP_IContact"/></c2>
		<oc1 public="1"><c path="zpp_nape.dynamics.ZPP_Contact"/></oc1>
		<c1 public="1"><c path="zpp_nape.dynamics.ZPP_IContact"/></c1>
		<__ref_vertex public="1"><x path="Int"/></__ref_vertex>
		<__ref_edge2 public="1"><c path="zpp_nape.shape.ZPP_Edge"/></__ref_edge2>
		<__ref_edge1 public="1"><c path="zpp_nape.shape.ZPP_Edge"/></__ref_edge1>
		<biasCoef><x path="Float"/></biasCoef>
		<rev public="1"><x path="Bool"/></rev>
		<radius public="1"><x path="Float"/></radius>
		<lproj public="1"><x path="Float"/></lproj>
		<lnormy public="1"><x path="Float"/></lnormy>
		<lnormx public="1"><x path="Float"/></lnormx>
		<ptype public="1"><x path="Int"/></ptype>
		<surfacey public="1"><x path="Float"/></surfacey>
		<surfacex public="1"><x path="Float"/></surfacex>
		<k2y><x path="Float"/></k2y>
		<k2x><x path="Float"/></k2x>
		<k1y><x path="Float"/></k1y>
		<k1x><x path="Float"/></k1x>
		<rt2b><x path="Float"/></rt2b>
		<rn2b><x path="Float"/></rn2b>
		<rt2a><x path="Float"/></rt2a>
		<rn2a><x path="Float"/></rn2a>
		<rt1b><x path="Float"/></rt1b>
		<rn1b><x path="Float"/></rn1b>
		<rt1a><x path="Float"/></rt1a>
		<rn1a><x path="Float"/></rn1a>
		<jrAcc public="1"><x path="Float"/></jrAcc>
		<rMass public="1"><x path="Float"/></rMass>
		<Kc><x path="Float"/></Kc>
		<Kb><x path="Float"/></Kb>
		<Ka><x path="Float"/></Ka>
		<kMassc><x path="Float"/></kMassc>
		<kMassb><x path="Float"/></kMassb>
		<kMassa><x path="Float"/></kMassa>
		<getnormal public="1" set="method" line="1431"><f a=""><x path="Void"/></f></getnormal>
		<wrap_normal public="1"><c path="nape.geom.Vec2"/></wrap_normal>
		<normal_validate set="method" line="1407"><f a=""><x path="Void"/></f></normal_validate>
		<ny public="1"><x path="Float"/></ny>
		<nx public="1"><x path="Float"/></nx>
		<innards public="1"><c path="zpp_nape.dynamics.ZPP_IContact"/></innards>
		<wrap_contacts public="1"><c path="nape.dynamics.ContactList"/></wrap_contacts>
		<contacts public="1"><c path="zpp_nape.dynamics.ZPP_Contact"/></contacts>
		<s2 public="1"><c path="zpp_nape.shape.ZPP_Shape"/></s2>
		<s1 public="1"><c path="zpp_nape.shape.ZPP_Shape"/></s1>
		<userdef_rfric public="1"><x path="Bool"/></userdef_rfric>
		<userdef_restitution public="1"><x path="Bool"/></userdef_restitution>
		<userdef_stat_fric public="1"><x path="Bool"/></userdef_stat_fric>
		<userdef_dyn_fric public="1"><x path="Bool"/></userdef_dyn_fric>
		<rfric public="1"><x path="Float"/></rfric>
		<restitution public="1"><x path="Float"/></restitution>
		<stat_fric public="1"><x path="Float"/></stat_fric>
		<dyn_fric public="1"><x path="Float"/></dyn_fric>
		<outer_zn public="1"><c path="nape.dynamics.CollisionArbiter"/></outer_zn>
		<new public="1" set="method" line="1503"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_Contact" params="" file="libSrc/napeLib/zpp_nape/dynamics/Contact.hx" module="zpp_nape.dynamics.Contact">
		<internal public="1" line="176" static="1"><x path="Bool"/></internal>
		<zpp_pool public="1" line="244" static="1"><c path="zpp_nape.dynamics.ZPP_Contact"/></zpp_pool>
		<at public="1" set="method" line="611"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></at>
		<iterator_at public="1" set="method" line="598"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></iterator_at>
		<back public="1" set="method" line="589"><f a=""><c path="zpp_nape.dynamics.ZPP_Contact"/></f></back>
		<front public="1" get="inline" set="null" line="586"><f a=""><c path="zpp_nape.dynamics.ZPP_Contact"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="556"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="551"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="548"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="543"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="528"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="522"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="517"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="513"><f a="pre:n">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="481"><f a="pre">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></inlined_erase>
		<erase public="1" set="method" line="476"><f a="pre">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="453"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="440"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="415"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="404"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="391"><f a=""><c path="zpp_nape.dynamics.ZPP_Contact"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="386"><f a=""><c path="zpp_nape.dynamics.ZPP_Contact"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="367"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="362"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="337"><f a="cur:o">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></inlined_insert>
		<insert public="1" set="method" line="332"><f a="cur:o">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></insert>
		<addAll public="1" set="method" line="314"><f a="x">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="295"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></inlined_add>
		<add public="1" set="method" line="290"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="285"><f a="i">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<_inuse public="1"><x path="Bool"/></_inuse>
		<begin public="1" get="inline" set="null" line="276"><f a=""><c path="zpp_nape.dynamics.ZPP_Contact"/></f></begin>
		<elem public="1" get="inline" set="null" line="271"><f a=""><c path="zpp_nape.dynamics.ZPP_Contact"/></f></elem>
		<next public="1"><c path="zpp_nape.dynamics.ZPP_Contact"/></next>
		<alloc public="1" get="inline" set="null" line="243"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="238"><f a=""><x path="Void"/></f></free>
		<elasticity public="1"><x path="Float"/></elasticity>
		<dist public="1"><x path="Float"/></dist>
		<fresh public="1"><x path="Bool"/></fresh>
		<hash public="1"><x path="Int"/></hash>
		<stamp public="1"><x path="Int"/></stamp>
		<posOnly public="1"><x path="Bool"/></posOnly>
		<active public="1"><x path="Bool"/></active>
		<inner public="1"><c path="zpp_nape.dynamics.ZPP_IContact"/></inner>
		<arbiter public="1"><c path="zpp_nape.dynamics.ZPP_Arbiter"/></arbiter>
		<inactiveme public="1" set="method" line="221"><f a=""><x path="Bool"/></f></inactiveme>
		<getposition public="1" set="method" line="214"><f a=""><x path="Void"/></f></getposition>
		<wrap_position public="1"><c path="nape.geom.Vec2"/></wrap_position>
		<position_validate set="method" line="188"><f a=""><x path="Void"/></f></position_validate>
		<py public="1"><x path="Float"/></py>
		<px public="1"><x path="Float"/></px>
		<wrapper public="1" set="method" line="177"><f a=""><c path="nape.dynamics.Contact"/></f></wrapper>
		<outer public="1"><c path="nape.dynamics.Contact"/></outer>
		<new public="1" set="method" line="233"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_IContact" params="" file="libSrc/napeLib/zpp_nape/dynamics/Contact.hx" module="zpp_nape.dynamics.Contact">
		<at public="1" set="method" line="984"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></at>
		<iterator_at public="1" set="method" line="971"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></iterator_at>
		<back public="1" set="method" line="962"><f a=""><c path="zpp_nape.dynamics.ZPP_IContact"/></f></back>
		<front public="1" get="inline" set="null" line="959"><f a=""><c path="zpp_nape.dynamics.ZPP_IContact"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="929"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="924"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="921"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="916"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="901"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="895"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="890"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="886"><f a="pre:n">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="854"><f a="pre">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></inlined_erase>
		<erase public="1" set="method" line="849"><f a="pre">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="826"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="813"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="788"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="777"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="764"><f a=""><c path="zpp_nape.dynamics.ZPP_IContact"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="759"><f a=""><c path="zpp_nape.dynamics.ZPP_IContact"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="740"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="735"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="710"><f a="cur:o">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></inlined_insert>
		<insert public="1" set="method" line="705"><f a="cur:o">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></insert>
		<addAll public="1" set="method" line="687"><f a="x">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="668"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></inlined_add>
		<add public="1" set="method" line="663"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="658"><f a="i">
	<c path="zpp_nape.dynamics.ZPP_IContact"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<_inuse public="1"><x path="Bool"/></_inuse>
		<begin public="1" get="inline" set="null" line="649"><f a=""><c path="zpp_nape.dynamics.ZPP_IContact"/></f></begin>
		<elem public="1" get="inline" set="null" line="644"><f a=""><c path="zpp_nape.dynamics.ZPP_IContact"/></f></elem>
		<next public="1"><c path="zpp_nape.dynamics.ZPP_IContact"/></next>
		<lr2y public="1"><x path="Float"/></lr2y>
		<lr2x public="1"><x path="Float"/></lr2x>
		<lr1y public="1"><x path="Float"/></lr1y>
		<lr1x public="1"><x path="Float"/></lr1x>
		<jtAcc public="1"><x path="Float"/></jtAcc>
		<jnAcc public="1"><x path="Float"/></jnAcc>
		<friction public="1"><x path="Float"/></friction>
		<bounce public="1"><x path="Float"/></bounce>
		<tMass public="1"><x path="Float"/></tMass>
		<nMass public="1"><x path="Float"/></nMass>
		<r2y public="1"><x path="Float"/></r2y>
		<r2x public="1"><x path="Float"/></r2x>
		<r1y public="1"><x path="Float"/></r1y>
		<r1x public="1"><x path="Float"/></r1x>
		<new public="1" set="method" line="640"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_InteractionFilter" params="" file="libSrc/napeLib/zpp_nape/dynamics/InteractionFilter.hx" module="zpp_nape.dynamics.InteractionFilter">
		<zpp_pool public="1" line="176" static="1"><c path="zpp_nape.dynamics.ZPP_InteractionFilter"/></zpp_pool>
		<invalidate public="1" set="method" line="304"><f a=""><x path="Void"/></f></invalidate>
		<shouldFlow public="1" get="inline" set="null" line="301"><f a="x">
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<x path="Bool"/>
</f></shouldFlow>
		<fluidMask public="1"><x path="Int"/></fluidMask>
		<fluidGroup public="1"><x path="Int"/></fluidGroup>
		<shouldSense public="1" get="inline" set="null" line="294"><f a="x">
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<x path="Bool"/>
</f></shouldSense>
		<sensorMask public="1"><x path="Int"/></sensorMask>
		<sensorGroup public="1"><x path="Int"/></sensorGroup>
		<shouldCollide public="1" get="inline" set="null" line="287"><f a="x">
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<x path="Bool"/>
</f></shouldCollide>
		<collisionMask public="1"><x path="Int"/></collisionMask>
		<collisionGroup public="1"><x path="Int"/></collisionGroup>
		<copy public="1" set="method" line="256"><f a=""><c path="zpp_nape.dynamics.ZPP_InteractionFilter"/></f></copy>
		<remShape public="1" get="inline" set="null" line="248"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></remShape>
		<addShape public="1" get="inline" set="null" line="243"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></addShape>
		<feature_cons public="1" get="inline" set="null" line="238"><f a=""><x path="Void"/></f></feature_cons>
		<wrap_shapes public="1"><c path="nape.shape.ShapeList"/></wrap_shapes>
		<shapes public="1"><c path="zpp_nape.util.ZNPList_ZPP_Shape"/></shapes>
		<alloc public="1" get="inline" set="null" line="233"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="228"><f a=""><x path="Void"/></f></free>
		<wrapper public="1" set="method" line="202"><f a=""><c path="nape.dynamics.InteractionFilter"/></f></wrapper>
		<outer public="1"><c path="nape.dynamics.InteractionFilter"/></outer>
		<userData public="1"><d><d/></d></userData>
		<next public="1"><c path="zpp_nape.dynamics.ZPP_InteractionFilter"/></next>
		<new public="1" set="method" line="251"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_InteractionGroup" params="" file="libSrc/napeLib/zpp_nape/dynamics/InteractionGroup.hx" module="zpp_nape.dynamics.InteractionGroup">
		<SHAPE public="1" line="220" static="1"><x path="Int"/></SHAPE>
		<BODY public="1" line="221" static="1"><x path="Int"/></BODY>
		<remInteractor public="1" get="inline" set="null" line="246"><f a="intx:?flag">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Int"/>
	<x path="Void"/>
</f></remInteractor>
		<addInteractor public="1" get="inline" set="null" line="241"><f a="intx">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></addInteractor>
		<remGroup public="1" get="inline" set="null" line="235"><f a="group">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Void"/>
</f></remGroup>
		<addGroup public="1" get="inline" set="null" line="229"><f a="group">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Void"/>
</f></addGroup>
		<invalidate public="1" set="method" line="197"><f a="?force">
	<x path="Bool"/>
	<x path="Void"/>
</f></invalidate>
		<depth public="1"><x path="Int"/></depth>
		<wrap_interactors public="1"><c path="nape.phys.InteractorList"/></wrap_interactors>
		<interactors public="1"><c path="zpp_nape.util.ZNPList_ZPP_Interactor"/></interactors>
		<wrap_groups public="1"><c path="nape.dynamics.InteractionGroupList"/></wrap_groups>
		<groups public="1"><c path="zpp_nape.util.ZNPList_ZPP_InteractionGroup"/></groups>
		<setGroup public="1" set="method" line="178"><f a="group">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Void"/>
</f></setGroup>
		<group public="1"><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></group>
		<ignore public="1"><x path="Bool"/></ignore>
		<outer public="1"><c path="nape.dynamics.InteractionGroup"/></outer>
		<new public="1" set="method" line="222"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.dynamics.ZPP_SpaceArbiterList" params="" file="libSrc/napeLib/zpp_nape/dynamics/SpaceArbiterList.hx" module="zpp_nape.dynamics.SpaceArbiterList">
		<extends path="nape.dynamics.ArbiterList"/>
		<at public="1" set="method" line="325" override="1"><f a="index">
	<x path="Int"/>
	<c path="nape.dynamics.Arbiter"/>
</f></at>
		<clear public="1" set="method" line="320" override="1"><f a=""><x path="Void"/></f></clear>
		<remove public="1" set="method" line="314" override="1"><f a="obj">
	<c path="nape.dynamics.Arbiter"/>
	<x path="Bool"/>
</f></remove>
		<shift public="1" set="method" line="308" override="1"><f a=""><c path="nape.dynamics.Arbiter"/></f></shift>
		<unshift public="1" set="method" line="302" override="1"><f a="obj">
	<c path="nape.dynamics.Arbiter"/>
	<x path="Bool"/>
</f></unshift>
		<pop public="1" set="method" line="296" override="1"><f a=""><c path="nape.dynamics.Arbiter"/></f></pop>
		<push public="1" set="method" line="290" override="1"><f a="obj">
	<c path="nape.dynamics.Arbiter"/>
	<x path="Bool"/>
</f></push>
		<zpp_vm public="1" set="method" line="261" override="1"><f a=""><x path="Void"/></f></zpp_vm>
		<at_index_3 public="1"><x path="Int"/></at_index_3>
		<at_index_2 public="1"><x path="Int"/></at_index_2>
		<at_index_1 public="1"><x path="Int"/></at_index_1>
		<at_index_0 public="1"><x path="Int"/></at_index_0>
		<ite_3 public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/></ite_3>
		<ite_2 public="1"><c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/></ite_2>
		<ite_1 public="1"><c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/></ite_1>
		<ite_0 public="1"><c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/></ite_0>
		<lengths public="1"><c path="Array"><x path="Int"/></c></lengths>
		<zpp_gl public="1" set="method" line="189" override="1"><f a=""><x path="Int"/></f></zpp_gl>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<_length public="1"><x path="Int"/></_length>
		<space public="1"><c path="zpp_nape.space.ZPP_Space"/></space>
		<new public="1" set="method" line="178"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_AABB" params="" file="libSrc/napeLib/zpp_nape/geom/AABB.hx" module="zpp_nape.geom.AABB">
		<zpp_pool public="1" line="218" static="1"><c path="zpp_nape.geom.ZPP_AABB"/></zpp_pool>
		<get public="1" get="inline" set="null" line="258" static="1"><f a="minx:miny:maxx:maxy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.geom.ZPP_AABB"/>
</f></get>
		<toString public="1" set="method" line="526"><f a=""><c path="String"/></f></toString>
		<setExpandPoint public="1" get="inline" set="null" line="520"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setExpandPoint>
		<setExpand public="1" get="inline" set="null" line="512"><f a="a:fatten">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setExpand>
		<setCombine public="1" get="inline" set="null" line="504"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Void"/>
</f></setCombine>
		<containsPoint public="1" get="inline" set="null" line="499"><f a="v">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></containsPoint>
		<contains public="1" get="inline" set="null" line="494"><f a="x">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
</f></contains>
		<combine public="1" get="inline" set="null" line="486"><f a="x">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Void"/>
</f></combine>
		<intersect public="1" get="inline" set="null" line="481"><f a="x">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
</f></intersect>
		<intersectY public="1" get="inline" set="null" line="476"><f a="x">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
</f></intersectY>
		<intersectX public="1" get="inline" set="null" line="471"><f a="x">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
</f></intersectX>
		<mod_max public="1" set="method" line="444"><f a="max">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></mod_max>
		<dom_max public="1" set="method" line="421"><f a=""><x path="Void"/></f></dom_max>
		<getmax public="1" set="method" line="407"><f a=""><c path="nape.geom.Vec2"/></f></getmax>
		<wrap_max public="1"><t path="Null"><c path="nape.geom.Vec2"/></t></wrap_max>
		<maxy public="1"><x path="Float"/></maxy>
		<maxx public="1"><x path="Float"/></maxx>
		<mod_min public="1" set="method" line="379"><f a="min">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></mod_min>
		<dom_min public="1" set="method" line="356"><f a=""><x path="Void"/></f></dom_min>
		<getmin public="1" set="method" line="342"><f a=""><c path="nape.geom.Vec2"/></f></getmin>
		<wrap_min public="1"><t path="Null"><c path="nape.geom.Vec2"/></t></wrap_min>
		<miny public="1"><x path="Float"/></miny>
		<minx public="1"><x path="Float"/></minx>
		<perimeter public="1" get="inline" set="null" line="336"><f a=""><x path="Float"/></f></perimeter>
		<height public="1" get="inline" set="null" line="331"><f a=""><x path="Float"/></f></height>
		<width public="1" get="inline" set="null" line="326"><f a=""><x path="Float"/></f></width>
		<copy public="1" get="inline" set="null" line="321"><f a=""><c path="zpp_nape.geom.ZPP_AABB"/></f></copy>
		<free public="1" get="inline" set="null" line="247"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="244"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.geom.ZPP_AABB"/></next>
		<wrapper public="1" set="method" line="193"><f a=""><c path="nape.geom.AABB"/></f></wrapper>
		<outer public="1"><t path="Null"><c path="nape.geom.AABB"/></t></outer>
		<invalidate public="1" get="inline" set="null" line="187"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" get="inline" set="null" line="180"><f a=""><x path="Void"/></f></validate>
		<_immutable public="1"><x path="Bool"/></_immutable>
		<_validate public="1"><t path="Null"><f a=""><x path="Void"/></f></t></_validate>
		<_invalidate public="1"><t path="Null"><f a="">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Void"/>
</f></t></_invalidate>
		<new public="1" set="method" line="256"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Vec2" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="9335"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></at>
		<iterator_at public="1" set="method" line="9322"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
</f></iterator_at>
		<back public="1" set="method" line="9313"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></back>
		<front public="1" get="inline" set="null" line="9310"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="9280"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="9275"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="9272"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="9267"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="9252"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="9246"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="9241"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="9237"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="9191"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
</f></inlined_erase>
		<erase public="1" set="method" line="9186"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="9163"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="9150"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="9125"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="9114"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="9101"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="9096"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="9063"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="9058"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="9015"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
</f></inlined_insert>
		<insert public="1" set="method" line="9010"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
</f></insert>
		<addAll public="1" set="method" line="8992"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Vec2"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="8955"><f a="o">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></inlined_add>
		<add public="1" set="method" line="8950"><f a="o">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="8945"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="8937"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/></head>
		<new public="1" set="method" line="8934"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Collide" params="" file="libSrc/napeLib/zpp_nape/geom/Collide.hx" module="zpp_nape.geom.Collide">
		<circleContains public="1" set="method" line="175" static="1"><f a="c:p">
	<c path="zpp_nape.shape.ZPP_Circle"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></circleContains>
		<polyContains public="1" set="method" line="184" static="1"><f a="s:p">
	<c path="zpp_nape.shape.ZPP_Polygon"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></polyContains>
		<shapeContains public="1" set="method" line="210" static="1"><f a="s:p">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></shapeContains>
		<bodyContains public="1" set="method" line="214" static="1"><f a="b:p">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></bodyContains>
		<containTest public="1" set="method" line="234" static="1"><f a="s1:s2">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></containTest>
		<contactCollide public="1" set="method" line="356" static="1"><f a="s1:s2:arb:rev">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></contactCollide>
		<testCollide_safe public="1" set="method" line="1034" static="1"><f a="s1:s2">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></testCollide_safe>
		<testCollide public="1" set="method" line="1042" static="1"><f a="s1:s2">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></testCollide>
		<flowCollide public="1" set="method" line="1171" static="1"><f a="s1:s2:arb">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<x path="Bool"/>
</f></flowCollide>
		<flowpoly public="1" line="2910" static="1"><c path="zpp_nape.util.ZNPList_ZPP_Vec2"/></flowpoly>
		<flowsegs public="1" line="2911" static="1"><c path="zpp_nape.util.ZNPList_ZPP_Vec2"/></flowsegs>
	</class>
	<class path="zpp_nape.geom.ZPP_Convex" params="" file="libSrc/napeLib/zpp_nape/geom/Convex.hx" module="zpp_nape.geom.Convex">
		<isinner set="method" line="175" static="1"><f a="a:b:c">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></isinner>
		<optimise public="1" set="method" line="190" static="1"><f a="P">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<x path="Void"/>
</f></optimise>
	</class>
	<class path="zpp_nape.geom.ZPP_ConvexRayResult" params="" file="libSrc/napeLib/zpp_nape/geom/ConvexRayResult.hx" module="zpp_nape.geom.ConvexRayResult">
		<convexPool line="177" static="1"><c path="zpp_nape.geom.ZPP_ConvexRayResult"/></convexPool>
		<rayPool line="180" static="1"><c path="zpp_nape.geom.ZPP_ConvexRayResult"/></rayPool>
		<internal public="1" line="186" static="1"><x path="Bool"/></internal>
		<getRay public="1" set="method" line="187" static="1"><f a="normal:time:inner:shape">
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="nape.shape.Shape"/>
	<c path="nape.geom.RayResult"/>
</f></getRay>
		<getConvex public="1" set="method" line="209" static="1"><f a="normal:position:toiDistance:shape">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<c path="nape.shape.Shape"/>
	<c path="nape.geom.ConvexResult"/>
</f></getConvex>
		<free public="1" set="method" line="239"><f a=""><x path="Void"/></f></free>
		<disposed public="1" get="inline" set="null" line="234"><f a=""><x path="Void"/></f></disposed>
		<toiDistance public="1"><x path="Float"/></toiDistance>
		<next public="1"><c path="zpp_nape.geom.ZPP_ConvexRayResult"/></next>
		<inner public="1"><x path="Bool"/></inner>
		<ray public="1"><c path="nape.geom.RayResult"/></ray>
		<position public="1"><c path="nape.geom.Vec2"/></position>
		<convex public="1"><c path="nape.geom.ConvexResult"/></convex>
		<shape public="1"><c path="nape.shape.Shape"/></shape>
		<normal public="1"><c path="nape.geom.Vec2"/></normal>
		<new public="1" set="method" line="185"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_CutVert" params="" file="libSrc/napeLib/zpp_nape/geom/Cutter.hx" module="zpp_nape.geom.Cutter">
		<zpp_pool public="1" line="175" static="1"><c path="zpp_nape.geom.ZPP_CutVert"/></zpp_pool>
		<path public="1" get="inline" set="null" line="220" static="1"><f a="poly">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_CutVert"/>
</f></path>
		<free public="1" get="inline" set="null" line="215"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="212"><f a=""><x path="Void"/></f></alloc>
		<used public="1"><x path="Bool"/></used>
		<rank public="1"><x path="Int"/></rank>
		<parent public="1"><c path="zpp_nape.geom.ZPP_CutVert"/></parent>
		<positive public="1"><x path="Bool"/></positive>
		<value public="1"><x path="Float"/></value>
		<vert public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></vert>
		<posy public="1"><x path="Float"/></posy>
		<posx public="1"><x path="Float"/></posx>
		<next public="1"><c path="zpp_nape.geom.ZPP_CutVert"/></next>
		<prev public="1"><c path="zpp_nape.geom.ZPP_CutVert"/></prev>
		<new public="1" set="method" line="209"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_CutInt" params="" file="libSrc/napeLib/zpp_nape/geom/Cutter.hx" module="zpp_nape.geom.Cutter">
		<zpp_pool public="1" line="249" static="1"><c path="zpp_nape.geom.ZPP_CutInt"/></zpp_pool>
		<get public="1" get="inline" set="null" line="291" static="1"><f a="time:?end:?start:?path0:?path1:?virtualint:?vertex">
	<x path="Float"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.geom.ZPP_CutInt"/>
</f></get>
		<free public="1" get="inline" set="null" line="286"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="283"><f a=""><x path="Void"/></f></alloc>
		<path1 public="1"><c path="zpp_nape.geom.ZPP_CutVert"/></path1>
		<start public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></start>
		<end public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></end>
		<path0 public="1"><c path="zpp_nape.geom.ZPP_CutVert"/></path0>
		<vertex public="1"><x path="Bool"/></vertex>
		<virtualint public="1"><x path="Bool"/></virtualint>
		<time public="1"><x path="Float"/></time>
		<next public="1"><c path="zpp_nape.geom.ZPP_CutInt"/></next>
		<new public="1" set="method" line="280"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Cutter" params="" file="libSrc/napeLib/zpp_nape/geom/Cutter.hx" module="zpp_nape.geom.Cutter">
		<ints line="322" static="1"><c path="zpp_nape.util.ZNPList_ZPP_CutInt"/></ints>
		<paths line="323" static="1"><c path="zpp_nape.util.ZNPList_ZPP_CutVert"/></paths>
		<run public="1" set="method" line="324" static="1"><f a="P:_start:_end:bstart:bend:output">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="nape.geom.GeomPolyList"/>
	<c path="nape.geom.GeomPolyList"/>
</f></run>
	</class>
	<class path="zpp_nape.geom.ZPP_Geom" params="" file="libSrc/napeLib/zpp_nape/geom/Geom.hx" module="zpp_nape.geom.Geom"><validateShape public="1" set="method" line="175" static="1"><f a="s">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></validateShape></class>
	<class path="zpp_nape.geom.ZPP_GeomVert" params="" file="libSrc/napeLib/zpp_nape/geom/GeomPoly.hx" module="zpp_nape.geom.GeomPoly">
		<zpp_pool public="1" line="181" static="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></zpp_pool>
		<get public="1" get="inline" set="null" line="275" static="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></get>
		<getwrap public="1" get="inline" set="null" line="252"><f a=""><x path="Void"/></f></getwrap>
		<modwrap public="1" get="inline" set="null" line="229"><f a="n">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></modwrap>
		<wrapper public="1" get="inline" set="null" line="219"><f a=""><c path="nape.geom.Vec2"/></f></wrapper>
		<alloc public="1" get="inline" set="null" line="215"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="206"><f a=""><x path="Void"/></f></free>
		<forced public="1"><x path="Bool"/></forced>
		<wrap public="1"><t path="Null"><c path="nape.geom.Vec2"/></t></wrap>
		<next public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></next>
		<prev public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></prev>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<new public="1" set="method" line="316"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_GeomPoly" params="" file="libSrc/napeLib/zpp_nape/geom/GeomPoly.hx" module="zpp_nape.geom.GeomPoly">
		<vertices public="1"><t path="Null"><c path="zpp_nape.geom.ZPP_GeomVert"/></t></vertices>
		<outer public="1"><c path="nape.geom.GeomPoly"/></outer>
		<new public="1" set="method" line="322"><f a="outer">
	<c path="nape.geom.GeomPoly"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_GeomVertexIterator" params="" file="libSrc/napeLib/zpp_nape/geom/GeomPoly.hx" module="zpp_nape.geom.GeomPoly">
		<zpp_pool public="1" line="334" static="1"><c path="zpp_nape.geom.ZPP_GeomVertexIterator"/></zpp_pool>
		<internal public="1" line="368" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="379" static="1"><f a="poly:forward">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Bool"/>
	<c path="nape.geom.GeomVertexIterator"/>
</f></get>
		<alloc public="1" get="inline" set="null" line="366"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="360"><f a=""><x path="Void"/></f></free>
		<next public="1"><c path="zpp_nape.geom.ZPP_GeomVertexIterator"/></next>
		<outer public="1"><c path="nape.geom.GeomVertexIterator"/></outer>
		<forward public="1"><x path="Bool"/></forward>
		<first public="1"><x path="Bool"/></first>
		<start public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></start>
		<ptr public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></ptr>
		<new set="method" line="370"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_MarchSpan" params="" file="libSrc/napeLib/zpp_nape/geom/MarchingSquares.hx" module="zpp_nape.geom.MarchingSquares">
		<zpp_pool public="1" line="179" static="1"><c path="zpp_nape.geom.ZPP_MarchSpan"/></zpp_pool>
		<alloc public="1" get="inline" set="null" line="210"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="205"><f a=""><x path="Void"/></f></free>
		<next public="1"><c path="zpp_nape.geom.ZPP_MarchSpan"/></next>
		<out public="1"><x path="Bool"/></out>
		<rank public="1"><x path="Int"/></rank>
		<parent public="1"><c path="zpp_nape.geom.ZPP_MarchSpan"/></parent>
		<new public="1" set="method" line="214"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_MarchPair" params="" file="libSrc/napeLib/zpp_nape/geom/MarchingSquares.hx" module="zpp_nape.geom.MarchingSquares">
		<zpp_pool public="1" line="234" static="1"><c path="zpp_nape.geom.ZPP_MarchPair"/></zpp_pool>
		<alloc public="1" get="inline" set="null" line="266"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="260"><f a=""><x path="Void"/></f></free>
		<next public="1"><c path="zpp_nape.geom.ZPP_MarchPair"/></next>
		<spanr public="1"><c path="zpp_nape.geom.ZPP_MarchSpan"/></spanr>
		<span2 public="1"><c path="zpp_nape.geom.ZPP_MarchSpan"/></span2>
		<span1 public="1"><c path="zpp_nape.geom.ZPP_MarchSpan"/></span1>
		<pd public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></pd>
		<okeyr public="1"><x path="Int"/></okeyr>
		<keyr public="1"><x path="Int"/></keyr>
		<pr public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></pr>
		<okey2 public="1"><x path="Int"/></okey2>
		<key2 public="1"><x path="Int"/></key2>
		<p2 public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></p2>
		<okey1 public="1"><x path="Int"/></okey1>
		<key1 public="1"><x path="Int"/></key1>
		<p1 public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></p1>
		<new public="1" set="method" line="267"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_MarchingSquares" params="" file="libSrc/napeLib/zpp_nape/geom/MarchingSquares.hx" module="zpp_nape.geom.MarchingSquares">
		<me line="271" static="1"><c path="zpp_nape.geom.ZPP_MarchingSquares"/></me>
		<isos static="1"><c path="zpp_nape.util.ZNPArray2_Float"/></isos>
		<ints static="1"><c path="zpp_nape.util.ZNPArray2_ZPP_GeomVert"/></ints>
		<map static="1"><c path="zpp_nape.util.ZNPArray2_ZPP_MarchPair"/></map>
		<run public="1" set="method" line="276" static="1"><f a="iso:bx0:by0:bx1:by1:cell:quality:combine:ret">
	<t path="nape.geom.IsoFunctionDef"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="nape.geom.Vec2"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="nape.geom.GeomPolyList"/>
	<x path="Void"/>
</f></run>
		<look_march public="1" line="953" static="1"><c path="Array"><x path="Int"/></c></look_march>
		<ISO get="inline" set="null" line="1928" static="1"><f a="iso:x:y">
	<t path="nape.geom.IsoFunctionDef"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></ISO>
		<ylerp set="method" line="1910"><f a="y0:y1:x:v0:v1:iso:quality">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<t path="nape.geom.IsoFunctionDef"/>
	<x path="Int"/>
	<x path="Float"/>
</f></ylerp>
		<xlerp set="method" line="1893"><f a="x0:x1:y:v0:v1:iso:quality">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<t path="nape.geom.IsoFunctionDef"/>
	<x path="Int"/>
	<x path="Float"/>
</f></xlerp>
		<lerp get="inline" set="null" line="1882"><f a="x0:x1:v0:v1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></lerp>
		<marchSquare set="method" line="954"><f a="iso:isos:ints:x0:y0:x1:y1:xn:yn:fstx:fsty:sndx:sndy:quality">
	<t path="nape.geom.IsoFunctionDef"/>
	<c path="zpp_nape.util.ZNPArray2_Float"/>
	<c path="zpp_nape.util.ZNPArray2_ZPP_GeomVert"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
</f></marchSquare>
		<comb get="inline" set="null" line="946"><f a="flag">
	<x path="Int"/>
	<x path="Bool"/>
</f></comb>
		<combDown get="inline" set="null" line="940"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></combDown>
		<combUp get="inline" set="null" line="934"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></combUp>
		<combRight get="inline" set="null" line="928"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></combRight>
		<combLeft get="inline" set="null" line="922"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></combLeft>
		<combUD_virtual set="method" line="911"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
	<x path="Void"/>
</f></combUD_virtual>
		<combUD set="method" line="864"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
	<x path="Void"/>
</f></combUD>
		<combLR set="method" line="771"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
	<x path="Void"/>
</f></combLR>
		<linkup get="inline" set="null" line="768"><f a="poly:key">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></linkup>
		<linkdown get="inline" set="null" line="763"><f a="poly:key">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></linkdown>
		<linkleft get="inline" set="null" line="758"><f a="poly:key">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></linkleft>
		<linkright get="inline" set="null" line="750"><f a="poly:key">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></linkright>
		<output set="method" line="662"><f a="ret:poly">
	<c path="nape.geom.GeomPolyList"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Void"/>
</f></output>
		<new set="method" line="272"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Mat23" params="" file="libSrc/napeLib/zpp_nape/geom/Mat23.hx" module="zpp_nape.geom.Mat23">
		<zpp_pool public="1" line="248" static="1"><c path="zpp_nape.geom.ZPP_Mat23"/></zpp_pool>
		<get public="1" set="method" line="279" static="1"><f a=""><c path="zpp_nape.geom.ZPP_Mat23"/></f></get>
		<identity public="1" set="method" line="300" static="1"><f a=""><c path="zpp_nape.geom.ZPP_Mat23"/></f></identity>
		<alloc public="1" get="inline" set="null" line="277"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="274"><f a=""><x path="Void"/></f></free>
		<next public="1"><c path="zpp_nape.geom.ZPP_Mat23"/></next>
		<setas public="1" set="method" line="219"><f a="a:b:c:d:tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setas>
		<set public="1" get="inline" set="null" line="216"><f a="m">
	<c path="zpp_nape.geom.ZPP_Mat23"/>
	<x path="Void"/>
</f></set>
		<invalidate public="1" get="inline" set="null" line="209"><f a=""><x path="Void"/></f></invalidate>
		<_invalidate public="1"><t path="Null"><f a=""><x path="Void"/></f></t></_invalidate>
		<ty public="1"><x path="Float"/></ty>
		<tx public="1"><x path="Float"/></tx>
		<d public="1"><x path="Float"/></d>
		<c public="1"><x path="Float"/></c>
		<b public="1"><x path="Float"/></b>
		<a public="1"><x path="Float"/></a>
		<wrapper public="1" set="method" line="176"><f a=""><c path="nape.geom.Mat23"/></f></wrapper>
		<outer public="1"><t path="Null"><c path="nape.geom.Mat23"/></t></outer>
		<new public="1" set="method" line="278"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_MatMN" params="" file="libSrc/napeLib/zpp_nape/geom/MatMN.hx" module="zpp_nape.geom.MatMN">
		<x public="1"><t path="nape.TArray"><x path="Float"/></t></x>
		<n public="1"><x path="Int"/></n>
		<m public="1"><x path="Int"/></m>
		<outer public="1"><c path="nape.geom.MatMN"/></outer>
		<new public="1" set="method" line="179"><f a="m:n">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Monotone" params="" file="libSrc/napeLib/zpp_nape/geom/Monotone.hx" module="zpp_nape.geom.Monotone">
		<bisector set="method" line="175" static="1"><f a="b">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></bisector>
		<below set="method" line="222" static="1"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></below>
		<above set="method" line="296" static="1"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></above>
		<left_vertex set="method" line="299" static="1"><f a="p">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></left_vertex>
		<isMonotone public="1" set="method" line="303" static="1"><f a="P">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Bool"/>
</f></isMonotone>
		<sharedPPoly public="1" static="1"><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></sharedPPoly>
		<getShared public="1" get="inline" set="null" line="378" static="1"><f a=""><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></f></getShared>
		<queue line="382" static="1"><c path="zpp_nape.util.ZNPList_ZPP_PartitionVertex"/></queue>
		<edges line="383" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/></edges>
		<decompose public="1" set="method" line="384" static="1"><f a="P:?poly">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
</f></decompose>
	</class>
	<class path="zpp_nape.geom.ZPP_PartitionVertex" params="" file="libSrc/napeLib/zpp_nape/geom/PartitionedPoly.hx" module="zpp_nape.geom.PartitionedPoly">
		<nextId line="176" static="1"><x path="Int"/></nextId>
		<zpp_pool public="1" line="185" static="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></zpp_pool>
		<get public="1" get="inline" set="null" line="230" static="1"><f a="x">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
</f></get>
		<rightdistance set="method" line="493" static="1"><f a="edge:vert">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Float"/>
</f></rightdistance>
		<vert_lt public="1" set="method" line="509" static="1"><f a="edge:vert">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></vert_lt>
		<edge_swap public="1" set="method" line="518" static="1"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></edge_swap>
		<edge_lt public="1" set="method" line="523" static="1"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></edge_lt>
		<node public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/></node>
		<sort public="1" set="method" line="314"><f a=""><x path="Void"/></f></sort>
		<copy public="1" get="inline" set="null" line="272"><f a=""><c path="zpp_nape.geom.ZPP_PartitionVertex"/></f></copy>
		<free public="1" get="inline" set="null" line="218"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="216"><f a=""><x path="Void"/></f></alloc>
		<prev public="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></prev>
		<next public="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></next>
		<rightchain public="1"><x path="Bool"/></rightchain>
		<helper public="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></helper>
		<type public="1"><x path="Int"/></type>
		<diagonals public="1"><c path="zpp_nape.util.ZNPList_ZPP_PartitionVertex"/></diagonals>
		<forced public="1"><x path="Bool"/></forced>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<mag public="1"><x path="Float"/></mag>
		<id public="1"><x path="Int"/></id>
		<new public="1" set="method" line="211"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_PartitionedPoly" params="" file="libSrc/napeLib/zpp_nape/geom/PartitionedPoly.hx" module="zpp_nape.geom.PartitionedPoly">
		<zpp_pool public="1" line="596" static="1"><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></zpp_pool>
		<sharedPPList public="1" static="1"><c path="zpp_nape.util.ZNPList_ZPP_PartitionedPoly"/></sharedPPList>
		<getSharedPP public="1" get="inline" set="null" line="891" static="1"><f a=""><c path="zpp_nape.util.ZNPList_ZPP_PartitionedPoly"/></f></getSharedPP>
		<sharedGVList public="1" static="1"><c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/></sharedGVList>
		<getShared public="1" get="inline" set="null" line="1134" static="1"><f a=""><c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/></f></getShared>
		<pull set="method" line="1218"><f a="start:ret">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
</f></pull>
		<extract public="1" set="method" line="1138"><f a="?ret">
	<c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/>
	<c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/>
</f></extract>
		<pull_partitions set="method" line="990"><f a="start:ret">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZNPList_ZPP_PartitionedPoly"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
</f></pull_partitions>
		<extract_partitions public="1" set="method" line="895"><f a="?ret">
	<c path="zpp_nape.util.ZNPList_ZPP_PartitionedPoly"/>
	<c path="zpp_nape.util.ZNPList_ZPP_PartitionedPoly"/>
</f></extract_partitions>
		<add_diagonal public="1" set="method" line="884"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></add_diagonal>
		<remove_collinear_vertices public="1" set="method" line="712"><f a=""><x path="Bool"/></f></remove_collinear_vertices>
		<init public="1" set="method" line="633"><f a="?P">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Void"/>
</f></init>
		<free public="1" get="inline" set="null" line="623"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="621"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></next>
		<eq set="method" line="589"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></eq>
		<vertices public="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></vertices>
		<new public="1" set="method" line="592"><f a="?P">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Ray" params="" file="libSrc/napeLib/zpp_nape/geom/Ray.hx" module="zpp_nape.geom.Ray">
		<internal public="1" line="176" static="1"><x path="Bool"/></internal>
		<polysect2 public="1" set="method" line="1185"><f a="p:inner:list">
	<c path="zpp_nape.shape.ZPP_Polygon"/>
	<x path="Bool"/>
	<c path="nape.geom.RayResultList"/>
	<x path="Void"/>
</f></polysect2>
		<polysect public="1" set="method" line="1068"><f a="p:inner:mint">
	<c path="zpp_nape.shape.ZPP_Polygon"/>
	<x path="Bool"/>
	<x path="Float"/>
	<t path="Null"><c path="nape.geom.RayResult"/></t>
</f></polysect>
		<circlesect2 public="1" set="method" line="761"><f a="c:inner:list">
	<c path="zpp_nape.shape.ZPP_Circle"/>
	<x path="Bool"/>
	<c path="nape.geom.RayResultList"/>
	<x path="Void"/>
</f></circlesect2>
		<circlesect public="1" set="method" line="491"><f a="c:inner:mint">
	<c path="zpp_nape.shape.ZPP_Circle"/>
	<x path="Bool"/>
	<x path="Float"/>
	<t path="Null"><c path="nape.geom.RayResult"/></t>
</f></circlesect>
		<aabbsect public="1" set="method" line="435"><f a="a">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Float"/>
</f></aabbsect>
		<aabbtest public="1" set="method" line="427"><f a="a">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
</f></aabbtest>
		<rayAABB public="1" set="method" line="391"><f a=""><c path="zpp_nape.geom.ZPP_AABB"/></f></rayAABB>
		<validate_dir public="1" set="method" line="290"><f a=""><x path="Void"/></f></validate_dir>
		<invalidate_dir public="1" get="inline" set="null" line="287"><f a=""><x path="Void"/></f></invalidate_dir>
		<zip_dir public="1"><x path="Bool"/></zip_dir>
		<direction_invalidate set="method" line="214"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></direction_invalidate>
		<origin_invalidate set="method" line="192"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></origin_invalidate>
		<absnormaly public="1"><x path="Float"/></absnormaly>
		<absnormalx public="1"><x path="Float"/></absnormalx>
		<normaly public="1"><x path="Float"/></normaly>
		<normalx public="1"><x path="Float"/></normalx>
		<idiry public="1"><x path="Float"/></idiry>
		<idirx public="1"><x path="Float"/></idirx>
		<diry public="1"><x path="Float"/></diry>
		<dirx public="1"><x path="Float"/></dirx>
		<originy public="1"><x path="Float"/></originy>
		<originx public="1"><x path="Float"/></originx>
		<userData public="1"><d><d/></d></userData>
		<maxdist public="1"><x path="Float"/></maxdist>
		<direction public="1"><c path="nape.geom.Vec2"/></direction>
		<origin public="1"><c path="nape.geom.Vec2"/></origin>
		<new public="1" set="method" line="237"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_SimpleVert" params="" file="libSrc/napeLib/zpp_nape/geom/Simple.hx" module="zpp_nape.geom.Simple">
		<zpp_pool public="1" line="181" static="1"><c path="zpp_nape.geom.ZPP_SimpleVert"/></zpp_pool>
		<less_xy public="1" set="method" line="237" static="1"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></less_xy>
		<swap_nodes public="1" set="method" line="240" static="1"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Void"/>
</f></swap_nodes>
		<get public="1" get="inline" set="null" line="246" static="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
</f></get>
		<alloc public="1" get="inline" set="null" line="215"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="208"><f a=""><x path="Void"/></f></free>
		<node public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/></node>
		<next public="1"><c path="zpp_nape.geom.ZPP_SimpleVert"/></next>
		<id public="1"><x path="Int"/></id>
		<links public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/></links>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<forced public="1"><x path="Bool"/></forced>
		<new set="method" line="216"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_SimpleSeg" params="" file="libSrc/napeLib/zpp_nape/geom/Simple.hx" module="zpp_nape.geom.Simple">
		<zpp_pool public="1" line="295" static="1"><c path="zpp_nape.geom.ZPP_SimpleSeg"/></zpp_pool>
		<get public="1" set="method" line="356" static="1"><f a="left:right">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
</f></get>
		<less_xy public="1" set="method" line="332"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></less_xy>
		<node public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/></node>
		<prev public="1"><c path="zpp_nape.geom.ZPP_SimpleSeg"/></prev>
		<alloc public="1" get="inline" set="null" line="329"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="321"><f a=""><x path="Void"/></f></free>
		<next public="1"><c path="zpp_nape.geom.ZPP_SimpleSeg"/></next>
		<id public="1"><x path="Int"/></id>
		<vertices public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/></vertices>
		<right public="1"><c path="zpp_nape.geom.ZPP_SimpleVert"/></right>
		<left public="1"><c path="zpp_nape.geom.ZPP_SimpleVert"/></left>
		<new set="method" line="335"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_SimpleEvent" params="" file="libSrc/napeLib/zpp_nape/geom/Simple.hx" module="zpp_nape.geom.Simple">
		<swap_nodes public="1" set="method" line="389" static="1"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></swap_nodes>
		<less_xy public="1" set="method" line="394" static="1"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></less_xy>
		<zpp_pool public="1" line="404" static="1"><c path="zpp_nape.geom.ZPP_SimpleEvent"/></zpp_pool>
		<get public="1" get="inline" set="null" line="440" static="1"><f a="v">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
</f></get>
		<alloc public="1" get="inline" set="null" line="437"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="430"><f a=""><x path="Void"/></f></free>
		<next public="1"><c path="zpp_nape.geom.ZPP_SimpleEvent"/></next>
		<node public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/></node>
		<segment2 public="1"><c path="zpp_nape.geom.ZPP_SimpleSeg"/></segment2>
		<segment public="1"><c path="zpp_nape.geom.ZPP_SimpleSeg"/></segment>
		<vertex public="1"><c path="zpp_nape.geom.ZPP_SimpleVert"/></vertex>
		<type public="1"><x path="Int"/></type>
		<new set="method" line="438"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_SimpleSweep" params="" file="libSrc/napeLib/zpp_nape/geom/Simple.hx" module="zpp_nape.geom.Simple">
		<intersection public="1" set="method" line="736"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
</f></intersection>
		<intersect public="1" set="method" line="718"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Bool"/>
</f></intersect>
		<remove public="1" set="method" line="710"><f a="e">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Void"/>
</f></remove>
		<add public="1" set="method" line="696"><f a="e">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
</f></add>
		<clear public="1" set="method" line="693"><f a=""><x path="Void"/></f></clear>
		<edge_lt public="1" set="method" line="493"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Bool"/>
</f></edge_lt>
		<swap_nodes public="1" set="method" line="488"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Void"/>
</f></swap_nodes>
		<tree public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/></tree>
		<sweepx public="1"><x path="Float"/></sweepx>
		<new public="1" set="method" line="467"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Simple" params="" file="libSrc/napeLib/zpp_nape/geom/Simple.hx" module="zpp_nape.geom.Simple">
		<sweep line="788" static="1"><c path="zpp_nape.geom.ZPP_SimpleSweep"/></sweep>
		<inthash line="789" static="1"><c path="zpp_nape.util.FastHash2_Hashable2_Boolfalse"/></inthash>
		<vertices line="790" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/></vertices>
		<queue line="791" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/></queue>
		<ints line="792" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/></ints>
		<decompose public="1" set="method" line="793" static="1"><f a="poly:?rets">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/>
	<c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/>
</f></decompose>
		<clip_polygon public="1" set="method" line="1791" static="1"><f a="vertices:rets">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/>
	<x path="Void"/>
</f></clip_polygon>
		<list_vertices line="2048" static="1"><c path="zpp_nape.util.ZNPList_ZPP_SimpleVert"/></list_vertices>
		<list_queue line="2049" static="1"><c path="zpp_nape.util.ZNPList_ZPP_SimpleEvent"/></list_queue>
		<isSimple public="1" set="method" line="2050" static="1"><f a="poly">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Bool"/>
</f></isSimple>
	</class>
	<class path="zpp_nape.geom.ZPP_SimplifyV" params="" file="libSrc/napeLib/zpp_nape/geom/Simplify.hx" module="zpp_nape.geom.Simplify">
		<zpp_pool public="1" line="178" static="1"><c path="zpp_nape.geom.ZPP_SimplifyV"/></zpp_pool>
		<get public="1" get="inline" set="null" line="213" static="1"><f a="v">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
</f></get>
		<alloc public="1" get="inline" set="null" line="210"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="207"><f a=""><x path="Void"/></f></free>
		<forced public="1"><x path="Bool"/></forced>
		<flag public="1"><x path="Bool"/></flag>
		<prev public="1"><c path="zpp_nape.geom.ZPP_SimplifyV"/></prev>
		<next public="1"><c path="zpp_nape.geom.ZPP_SimplifyV"/></next>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<new public="1" set="method" line="211"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_SimplifyP" params="" file="libSrc/napeLib/zpp_nape/geom/Simplify.hx" module="zpp_nape.geom.Simplify">
		<zpp_pool public="1" line="259" static="1"><c path="zpp_nape.geom.ZPP_SimplifyP"/></zpp_pool>
		<get public="1" get="inline" set="null" line="295" static="1"><f a="min:max">
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
</f></get>
		<alloc public="1" get="inline" set="null" line="293"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="288"><f a=""><x path="Void"/></f></free>
		<max public="1"><c path="zpp_nape.geom.ZPP_SimplifyV"/></max>
		<min public="1"><c path="zpp_nape.geom.ZPP_SimplifyV"/></min>
		<next public="1"><c path="zpp_nape.geom.ZPP_SimplifyP"/></next>
		<new public="1" set="method" line="285"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Simplify" params="" file="libSrc/napeLib/zpp_nape/geom/Simplify.hx" module="zpp_nape.geom.Simplify">
		<lessval public="1" get="inline" set="null" line="322" static="1"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<x path="Float"/>
</f></lessval>
		<less public="1" get="inline" set="null" line="326" static="1"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<x path="Bool"/>
</f></less>
		<distance public="1" set="method" line="329" static="1"><f a="v:a:b">
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<c path="zpp_nape.geom.ZPP_SimplifyV"/>
	<x path="Float"/>
</f></distance>
		<stack line="366" static="1"><c path="zpp_nape.util.ZNPList_ZPP_SimplifyP"/></stack>
		<simplify public="1" set="method" line="367" static="1"><f a="P:epsilon">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Float"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></simplify>
	</class>
	<class path="zpp_nape.geom.ZPP_ToiEvent" params="" file="libSrc/napeLib/zpp_nape/geom/SweepDistance.hx" module="zpp_nape.geom.SweepDistance">
		<zpp_pool public="1" line="176" static="1"><c path="zpp_nape.geom.ZPP_ToiEvent"/></zpp_pool>
		<kinematic public="1"><x path="Bool"/></kinematic>
		<failed public="1"><x path="Bool"/></failed>
		<slipped public="1"><x path="Bool"/></slipped>
		<axis public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></axis>
		<c2 public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></c2>
		<c1 public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></c1>
		<frozen2 public="1"><x path="Bool"/></frozen2>
		<frozen1 public="1"><x path="Bool"/></frozen1>
		<arbiter public="1"><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></arbiter>
		<s2 public="1"><c path="zpp_nape.shape.ZPP_Shape"/></s2>
		<s1 public="1"><c path="zpp_nape.shape.ZPP_Shape"/></s1>
		<toi public="1"><x path="Float"/></toi>
		<free public="1" get="inline" set="null" line="209"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="202"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.geom.ZPP_ToiEvent"/></next>
		<new public="1" set="method" line="222"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_SweepDistance" params="" file="libSrc/napeLib/zpp_nape/geom/SweepDistance.hx" module="zpp_nape.geom.SweepDistance">
		<dynamicSweep public="1" set="method" line="230" static="1"><f a="toi:timeStep:lowerBound:negRadius:?userAPI">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></dynamicSweep>
		<staticSweep public="1" set="method" line="339" static="1"><f a="toi:timeStep:lowerBound:negRadius">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></staticSweep>
		<distanceBody public="1" set="method" line="475" static="1"><f a="b1:b2:w1:w2">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Float"/>
</f></distanceBody>
		<distance public="1" get="inline" set="null" line="630" static="1"><f a="s1:s2:w1:w2:axis:?upperBound">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Float"/>
	<x path="Float"/>
</f></distance>
	</class>
	<class path="zpp_nape.geom.ZPP_PartitionPair" params="" file="libSrc/napeLib/zpp_nape/geom/Triangular.hx" module="zpp_nape.geom.Triangular">
		<zpp_pool public="1" line="175" static="1"><c path="zpp_nape.geom.ZPP_PartitionPair"/></zpp_pool>
		<get public="1" get="inline" set="null" line="569" static="1"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></get>
		<edge_swap public="1" set="method" line="601" static="1"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Void"/>
</f></edge_swap>
		<edge_lt public="1" set="method" line="608" static="1"><f a="a:b">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></edge_lt>
		<node public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/></node>
		<di public="1"><x path="Int"/></di>
		<id public="1"><x path="Int"/></id>
		<b public="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></b>
		<a public="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></a>
		<alloc public="1" get="inline" set="null" line="562"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="556"><f a=""><x path="Void"/></f></free>
		<at public="1" set="method" line="542"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></at>
		<iterator_at public="1" set="method" line="529"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></iterator_at>
		<back public="1" set="method" line="520"><f a=""><c path="zpp_nape.geom.ZPP_PartitionPair"/></f></back>
		<front public="1" get="inline" set="null" line="517"><f a=""><c path="zpp_nape.geom.ZPP_PartitionPair"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="487"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="482"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="479"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="474"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="459"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="453"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="448"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="444"><f a="pre:n">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="412"><f a="pre">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></inlined_erase>
		<erase public="1" set="method" line="407"><f a="pre">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="384"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="371"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="346"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="335"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="322"><f a=""><c path="zpp_nape.geom.ZPP_PartitionPair"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="317"><f a=""><c path="zpp_nape.geom.ZPP_PartitionPair"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="298"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="293"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="268"><f a="cur:o">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></inlined_insert>
		<insert public="1" set="method" line="263"><f a="cur:o">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></insert>
		<addAll public="1" set="method" line="245"><f a="x">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="226"><f a="o">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></inlined_add>
		<add public="1" set="method" line="221"><f a="o">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="216"><f a="i">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<_inuse public="1"><x path="Bool"/></_inuse>
		<begin public="1" get="inline" set="null" line="207"><f a=""><c path="zpp_nape.geom.ZPP_PartitionPair"/></f></begin>
		<elem public="1" get="inline" set="null" line="202"><f a=""><c path="zpp_nape.geom.ZPP_PartitionPair"/></f></elem>
		<next public="1"><c path="zpp_nape.geom.ZPP_PartitionPair"/></next>
		<new public="1" set="method" line="567"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Triangular" params="" file="libSrc/napeLib/zpp_nape/geom/Triangular.hx" module="zpp_nape.geom.Triangular">
		<lt get="inline" set="null" line="615" static="1"><f a="p:q">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></lt>
		<right_turn get="inline" set="null" line="619" static="1"><f a="a:b:c">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Float"/>
</f></right_turn>
		<queue line="634" static="1"><c path="zpp_nape.util.ZNPList_ZPP_PartitionVertex"/></queue>
		<stack line="635" static="1"><c path="zpp_nape.util.ZNPList_ZPP_PartitionVertex"/></stack>
		<delaunay public="1" set="method" line="636" static="1"><f a="A:B:C:D">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></delaunay>
		<edgeSet line="687" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/></edgeSet>
		<optimise public="1" set="method" line="688" static="1"><f a="P">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<x path="Void"/>
</f></optimise>
		<triangulate public="1" set="method" line="887" static="1"><f a="P">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
</f></triangulate>
	</class>
	<class path="zpp_nape.geom.ZPP_Vec2" params="" file="libSrc/napeLib/zpp_nape/geom/Vec2.hx" module="zpp_nape.geom.Vec2">
		<zpp_pool public="1" line="233" static="1"><c path="zpp_nape.geom.ZPP_Vec2"/></zpp_pool>
		<get public="1" get="inline" set="null" line="632" static="1"><f a="x:y:?immutable">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></get>
		<toString public="1" set="method" line="679"><f a=""><c path="String"/></f></toString>
		<copy public="1" get="inline" set="null" line="676"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></copy>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<at public="1" set="method" line="616"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></at>
		<iterator_at public="1" set="method" line="603"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></iterator_at>
		<back public="1" set="method" line="594"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></back>
		<front public="1" get="inline" set="null" line="591"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="561"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="556"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="553"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="548"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="533"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="527"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="522"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="518"><f a="pre:n">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="486"><f a="pre">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></inlined_erase>
		<erase public="1" set="method" line="481"><f a="pre">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="458"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="445"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="420"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="409"><f a="obj">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="396"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="391"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="372"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="367"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="342"><f a="cur:o">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></inlined_insert>
		<insert public="1" set="method" line="337"><f a="cur:o">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></insert>
		<addAll public="1" set="method" line="319"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="300"><f a="o">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></inlined_add>
		<add public="1" set="method" line="295"><f a="o">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="zpp_nape.geom.ZPP_Vec2"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="290"><f a="i">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<_inuse public="1"><x path="Bool"/></_inuse>
		<begin public="1" get="inline" set="null" line="281"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></begin>
		<elem public="1" get="inline" set="null" line="276"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></elem>
		<next public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></next>
		<alloc public="1" get="inline" set="null" line="270"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="259"><f a=""><x path="Void"/></f></free>
		<weak public="1"><x path="Bool"/></weak>
		<wrapper public="1" get="inline" set="null" line="208"><f a=""><c path="nape.geom.Vec2"/></f></wrapper>
		<outer public="1"><t path="Null"><c path="nape.geom.Vec2"/></t></outer>
		<immutable public="1" get="inline" set="null" line="195"><f a=""><x path="Void"/></f></immutable>
		<_isimmutable public="1"><t path="Null"><f a=""><x path="Void"/></f></t></_isimmutable>
		<_immutable public="1"><x path="Bool"/></_immutable>
		<invalidate public="1" get="inline" set="null" line="186"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" get="inline" set="null" line="179"><f a=""><x path="Void"/></f></validate>
		<_validate public="1"><t path="Null"><f a=""><x path="Void"/></f></t></_validate>
		<_invalidate public="1"><t path="Null"><f a="">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></t></_invalidate>
		<new public="1" set="method" line="630"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_Vec3" params="" file="libSrc/napeLib/zpp_nape/geom/Vec3.hx" module="zpp_nape.geom.Vec3">
		<validate public="1" get="inline" set="null" line="183"><f a=""><x path="Void"/></f></validate>
		<_validate public="1"><t path="Null"><f a=""><x path="Void"/></f></t></_validate>
		<immutable public="1"><x path="Bool"/></immutable>
		<z public="1"><x path="Float"/></z>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<outer public="1"><c path="nape.geom.Vec3"/></outer>
		<new public="1" set="method" line="188"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.geom.ZPP_VecMath" params="" file="libSrc/napeLib/zpp_nape/geom/VecMath.hx" module="zpp_nape.geom.VecMath">
		<vec_dsq public="1" get="inline" set="null" line="176" static="1"><f a="ax:ay:bx:by">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></vec_dsq>
		<vec_distance public="1" get="inline" set="null" line="186" static="1"><f a="ax:ay:bx:by">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></vec_distance>
	</class>
	<class path="zpp_nape.phys.ZPP_Interactor" params="" file="libSrc/napeLib/zpp_nape/phys/Interactor.hx" module="zpp_nape.phys.Interactor">
		<get public="1" set="method" line="235" static="1"><f a="i1:i2">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></get>
		<int_callback public="1" get="inline" set="null" line="426" static="1"><f a="set:x:cb">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
	<x path="Void"/>
</f></int_callback>
		<copyto public="1" set="method" line="449"><f a="ret">
	<c path="nape.phys.Interactor"/>
	<x path="Void"/>
</f></copyto>
		<lookup_group public="1" get="inline" set="null" line="440"><f a=""><t path="Null"><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></t></f></lookup_group>
		<immutable_midstep public="1" set="method" line="415"><f a="n">
	<c path="String"/>
	<x path="Void"/>
</f></immutable_midstep>
		<setGroup public="1" set="method" line="402"><f a="group">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Void"/>
</f></setGroup>
		<dealloc_cbSet public="1" set="method" line="366"><f a=""><x path="Void"/></f></dealloc_cbSet>
		<alloc_cbSet public="1" set="method" line="349"><f a=""><x path="Void"/></f></alloc_cbSet>
		<insert_cbtype public="1" set="method" line="321"><f a="cb">
	<c path="zpp_nape.callbacks.ZPP_CbType"/>
	<x path="Void"/>
</f></insert_cbtype>
		<wrap_cbTypes_adder set="method" line="317"><f a="cb">
	<c path="nape.callbacks.CbType"/>
	<x path="Bool"/>
</f></wrap_cbTypes_adder>
		<wrap_cbTypes_subber set="method" line="302"><f a="pcb">
	<c path="nape.callbacks.CbType"/>
	<x path="Void"/>
</f></wrap_cbTypes_subber>
		<immutable_cbTypes set="method" line="298"><f a=""><x path="Void"/></f></immutable_cbTypes>
		<setupcbTypes public="1" set="method" line="288"><f a=""><x path="Void"/></f></setupcbTypes>
		<wrap_cbTypes public="1"><c path="nape.callbacks.CbTypeList"/></wrap_cbTypes>
		<cbSet public="1"><c path="zpp_nape.callbacks.ZPP_CbSet"/></cbSet>
		<cbTypes public="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></cbTypes>
		<group public="1"><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></group>
		<getSpace public="1" get="inline" set="null" line="281"><f a=""><t path="Null"><c path="zpp_nape.space.ZPP_Space"/></t></f></getSpace>
		<cbsets public="1"><c path="zpp_nape.util.ZNPList_ZPP_CallbackSet"/></cbsets>
		<wake public="1" set="method" line="220"><f a=""><x path="Void"/></f></wake>
		<__iremovedFromSpace public="1" set="method" line="208"><f a=""><x path="Void"/></f></__iremovedFromSpace>
		<__iaddedToSpace public="1" set="method" line="196"><f a=""><x path="Void"/></f></__iaddedToSpace>
		<isCompound public="1" get="inline" set="null" line="193"><f a=""><x path="Bool"/></f></isCompound>
		<isBody public="1" get="inline" set="null" line="188"><f a=""><x path="Bool"/></f></isBody>
		<isShape public="1" get="inline" set="null" line="183"><f a=""><x path="Bool"/></f></isShape>
		<icompound public="1"><c path="zpp_nape.phys.ZPP_Compound"/></icompound>
		<ibody public="1"><c path="zpp_nape.phys.ZPP_Body"/></ibody>
		<ishape public="1"><c path="zpp_nape.shape.ZPP_Shape"/></ishape>
		<userData public="1"><d><d/></d></userData>
		<id public="1"><x path="Int"/></id>
		<outer_i public="1"><c path="nape.phys.Interactor"/></outer_i>
		<new public="1" set="method" line="420"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.phys.ZPP_Body" params="" file="libSrc/napeLib/zpp_nape/phys/Body.hx" module="zpp_nape.phys.Body">
		<extends path="zpp_nape.phys.ZPP_Interactor"/>
		<bodystack line="212" static="1"><c path="zpp_nape.util.ZNPList_ZPP_Body"/></bodystack>
		<bodyset line="213" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_Body"/></bodyset>
		<bodysetlt set="method" line="214" static="1"><f a="a:b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></bodysetlt>
		<cur_graph_depth line="242" static="1"><x path="Int"/></cur_graph_depth>
		<__static public="1" set="method" line="1375" static="1"><f a=""><c path="nape.phys.Body"/></f></__static>
		<copy public="1" set="method" line="1687"><f a=""><c path="nape.phys.Body"/></f></copy>
		<removedFromSpace public="1" set="method" line="1662"><f a=""><x path="Void"/></f></removedFromSpace>
		<addedToSpace public="1" set="method" line="1632"><f a=""><x path="Void"/></f></addedToSpace>
		<shapes_modifiable set="method" line="1414"><f a=""><x path="Void"/></f></shapes_modifiable>
		<shapes_invalidate set="method" line="1410"><f a="_">
	<c path="zpp_nape.util.ZPP_ShapeList"/>
	<x path="Void"/>
</f></shapes_invalidate>
		<shapes_subber set="method" line="1405"><f a="s">
	<c path="nape.shape.Shape"/>
	<x path="Void"/>
</f></shapes_subber>
		<shapes_adder set="method" line="1391"><f a="s">
	<c path="nape.shape.Shape"/>
	<x path="Bool"/>
</f></shapes_adder>
		<aabb_validate set="method" line="1385"><f a=""><x path="Void"/></f></aabb_validate>
		<clear public="1" set="method" line="1207"><f a=""><x path="Void"/></f></clear>
		<__immutable_midstep public="1" get="inline" set="null" line="1202"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></__immutable_midstep>
		<getworldCOM public="1" set="method" line="1194"><f a=""><x path="Void"/></f></getworldCOM>
		<getlocalCOM public="1" set="method" line="1188"><f a=""><x path="Void"/></f></getlocalCOM>
		<validate_worldCOM public="1" set="method" line="1157"><f a=""><x path="Void"/></f></validate_worldCOM>
		<validate_localCOM public="1" set="method" line="1061"><f a=""><x path="Void"/></f></validate_localCOM>
		<invalidate_worldCOM public="1" get="inline" set="null" line="1058"><f a=""><x path="Void"/></f></invalidate_worldCOM>
		<invalidate_localCOM public="1" get="inline" set="null" line="1052"><f a=""><x path="Void"/></f></invalidate_localCOM>
		<wrap_worldCOM public="1"><c path="nape.geom.Vec2"/></wrap_worldCOM>
		<wrap_localCOM public="1"><c path="nape.geom.Vec2"/></wrap_localCOM>
		<zip_worldCOM public="1"><x path="Bool"/></zip_worldCOM>
		<worldCOMy public="1"><x path="Float"/></worldCOMy>
		<worldCOMx public="1"><x path="Float"/></worldCOMx>
		<zip_localCOM public="1"><x path="Bool"/></zip_localCOM>
		<localCOMy public="1"><x path="Float"/></localCOMy>
		<localCOMx public="1"><x path="Float"/></localCOMx>
		<invalidate_aabb public="1" get="inline" set="null" line="1039"><f a=""><x path="Void"/></f></invalidate_aabb>
		<validate_aabb public="1" get="inline" set="null" line="978"><f a=""><x path="Void"/></f></validate_aabb>
		<zip_aabb public="1"><x path="Bool"/></zip_aabb>
		<aabb public="1"><c path="zpp_nape.geom.ZPP_AABB"/></aabb>
		<invalidate_wake public="1" get="inline" set="null" line="972"><f a=""><x path="Void"/></f></invalidate_wake>
		<validate_inertia public="1" set="method" line="940"><f a=""><x path="Void"/></f></validate_inertia>
		<invalidate_inertia public="1" set="method" line="936"><f a=""><x path="Void"/></f></invalidate_inertia>
		<norotate public="1"><x path="Bool"/></norotate>
		<sinertia public="1"><x path="Float"/></sinertia>
		<iinertia public="1"><x path="Float"/></iinertia>
		<cinertia public="1"><x path="Float"/></cinertia>
		<zip_inertia public="1"><x path="Bool"/></zip_inertia>
		<inertia public="1"><x path="Float"/></inertia>
		<inertiaMode public="1"><x path="Int"/></inertiaMode>
		<validate_gravMassScale public="1" set="method" line="919"><f a=""><x path="Void"/></f></validate_gravMassScale>
		<invalidate_gravMassScale public="1" set="method" line="915"><f a=""><x path="Void"/></f></invalidate_gravMassScale>
		<validate_gravMass public="1" set="method" line="901"><f a=""><x path="Void"/></f></validate_gravMass>
		<invalidate_gravMass public="1" set="method" line="896"><f a=""><x path="Void"/></f></invalidate_gravMass>
		<zip_gravMassScale public="1"><x path="Bool"/></zip_gravMassScale>
		<gravMassScale public="1"><x path="Float"/></gravMassScale>
		<gravMassMode public="1"><x path="Int"/></gravMassMode>
		<zip_gravMass public="1"><x path="Bool"/></zip_gravMass>
		<gravMass public="1"><x path="Float"/></gravMass>
		<validate_mass public="1" set="method" line="861"><f a=""><x path="Void"/></f></validate_mass>
		<invalidate_mass public="1" set="method" line="857"><f a=""><x path="Void"/></f></invalidate_mass>
		<nomove public="1"><x path="Bool"/></nomove>
		<cmass public="1"><x path="Float"/></cmass>
		<smass public="1"><x path="Float"/></smass>
		<imass public="1"><x path="Float"/></imass>
		<massMode public="1"><x path="Int"/></massMode>
		<zip_mass public="1"><x path="Bool"/></zip_mass>
		<mass public="1"><x path="Float"/></mass>
		<kinematicDelaySleep public="1"><x path="Bool"/></kinematicDelaySleep>
		<delta_rot public="1" get="inline" set="null" line="837"><f a="dr">
	<x path="Float"/>
	<x path="Void"/>
</f></delta_rot>
		<quick_validate_axis public="1" get="inline" set="null" line="813"><f a=""><x path="Void"/></f></quick_validate_axis>
		<validate_axis public="1" get="inline" set="null" line="805"><f a=""><x path="Void"/></f></validate_axis>
		<zip_axis public="1"><x path="Bool"/></zip_axis>
		<axisy public="1"><x path="Float"/></axisy>
		<axisx public="1"><x path="Float"/></axisx>
		<invalidate_rot public="1" get="inline" set="null" line="783"><f a=""><x path="Void"/></f></invalidate_rot>
		<rot public="1"><x path="Float"/></rot>
		<pre_rot public="1"><x path="Float"/></pre_rot>
		<kinangvel public="1"><x path="Float"/></kinangvel>
		<torque public="1"><x path="Float"/></torque>
		<angvel public="1"><x path="Float"/></angvel>
		<setup_cvel public="1" set="method" line="770"><f a=""><x path="Void"/></f></setup_cvel>
		<wrapcvel public="1"><c path="nape.geom.Vec3"/></wrapcvel>
		<cvel_validate set="method" line="764"><f a=""><x path="Void"/></f></cvel_validate>
		<setupForce public="1" set="method" line="755"><f a=""><x path="Void"/></f></setupForce>
		<setupsvel public="1" set="method" line="746"><f a=""><x path="Void"/></f></setupsvel>
		<setupkinvel public="1" set="method" line="737"><f a=""><x path="Void"/></f></setupkinvel>
		<setupVelocity public="1" set="method" line="728"><f a=""><x path="Void"/></f></setupVelocity>
		<setupPosition public="1" set="method" line="719"><f a=""><x path="Void"/></f></setupPosition>
		<force_validate set="method" line="699"><f a=""><x path="Void"/></f></force_validate>
		<force_invalidate set="method" line="673"><f a="force">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></force_invalidate>
		<svel_validate set="method" line="651"><f a=""><x path="Void"/></f></svel_validate>
		<svel_invalidate set="method" line="628"><f a="vel">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></svel_invalidate>
		<kinvel_validate set="method" line="606"><f a=""><x path="Void"/></f></kinvel_validate>
		<kinvel_invalidate set="method" line="583"><f a="vel">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></kinvel_invalidate>
		<vel_validate set="method" line="561"><f a=""><x path="Void"/></f></vel_validate>
		<vel_invalidate set="method" line="535"><f a="vel">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></vel_invalidate>
		<pos_validate set="method" line="513"><f a=""><x path="Void"/></f></pos_validate>
		<pos_invalidate set="method" line="483"><f a="pos">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></pos_invalidate>
		<invalidate_pos public="1" get="inline" set="null" line="466"><f a=""><x path="Void"/></f></invalidate_pos>
		<wrap_svel public="1"><c path="nape.geom.Vec2"/></wrap_svel>
		<svely public="1"><x path="Float"/></svely>
		<svelx public="1"><x path="Float"/></svelx>
		<wrap_kinvel public="1"><c path="nape.geom.Vec2"/></wrap_kinvel>
		<kinvely public="1"><x path="Float"/></kinvely>
		<kinvelx public="1"><x path="Float"/></kinvelx>
		<wrap_force public="1"><c path="nape.geom.Vec2"/></wrap_force>
		<forcey public="1"><x path="Float"/></forcey>
		<forcex public="1"><x path="Float"/></forcex>
		<wrap_vel public="1"><c path="nape.geom.Vec2"/></wrap_vel>
		<vely public="1"><x path="Float"/></vely>
		<velx public="1"><x path="Float"/></velx>
		<wrap_pos public="1"><c path="nape.geom.Vec2"/></wrap_pos>
		<posy public="1"><x path="Float"/></posy>
		<posx public="1"><x path="Float"/></posx>
		<pre_posy public="1"><x path="Float"/></pre_posy>
		<pre_posx public="1"><x path="Float"/></pre_posx>
		<sweepValidate public="1" get="inline" set="null" line="378"><f a="s">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></sweepValidate>
		<sweepIntegrate public="1" get="inline" set="null" line="348"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></sweepIntegrate>
		<disableCCD public="1"><x path="Bool"/></disableCCD>
		<bulletEnabled public="1"><x path="Bool"/></bulletEnabled>
		<bullet public="1"><x path="Bool"/></bullet>
		<sweepRadius public="1"><x path="Float"/></sweepRadius>
		<sweepFrozen public="1"><x path="Bool"/></sweepFrozen>
		<sweep_angvel public="1"><x path="Float"/></sweep_angvel>
		<sweepTime public="1"><x path="Float"/></sweepTime>
		<refreshArbiters public="1" set="method" line="329"><f a=""><x path="Void"/></f></refreshArbiters>
		<atRest public="1" set="method" line="304"><f a="dt">
	<x path="Float"/>
	<x path="Bool"/>
</f></atRest>
		<interactingBodies public="1" set="method" line="273"><f a="arbiter_type:depth:output">
	<x path="Int"/>
	<x path="Int"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></interactingBodies>
		<connectedBodies public="1" set="method" line="249"><f a="depth:output">
	<x path="Int"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></connectedBodies>
		<connectedBodies_cont set="method" line="243"><f a="b">
	<c path="nape.phys.Body"/>
	<x path="Void"/>
</f></connectedBodies_cont>
		<init_bodysetlist get="inline" set="null" line="219"><f a=""><x path="Void"/></f></init_bodysetlist>
		<graph_depth public="1"><x path="Int"/></graph_depth>
		<component public="1"><c path="zpp_nape.space.ZPP_Component"/></component>
		<wrap_constraints public="1"><c path="nape.constraint.ConstraintList"/></wrap_constraints>
		<constraints public="1"><c path="zpp_nape.util.ZNPList_ZPP_Constraint"/></constraints>
		<wrap_arbiters public="1"><c path="nape.dynamics.ArbiterList"/></wrap_arbiters>
		<arbiters public="1"><c path="zpp_nape.util.ZNPList_ZPP_Arbiter"/></arbiters>
		<space public="1"><c path="zpp_nape.space.ZPP_Space"/></space>
		<invalidate_shapes public="1" set="method" line="200"><f a=""><x path="Void"/></f></invalidate_shapes>
		<wrap_shapes public="1"><c path="nape.shape.ShapeList"/></wrap_shapes>
		<shapes public="1"><c path="zpp_nape.util.ZNPList_ZPP_Shape"/></shapes>
		<compound public="1"><c path="zpp_nape.phys.ZPP_Compound"/></compound>
		<invalidate_type public="1" set="method" line="193"><f a=""><x path="Void"/></f></invalidate_type>
		<isKinematic public="1" get="inline" set="null" line="190"><f a=""><x path="Bool"/></f></isKinematic>
		<isDynamic public="1" get="inline" set="null" line="185"><f a=""><x path="Bool"/></f></isDynamic>
		<isStatic public="1" get="inline" set="null" line="180"><f a=""><x path="Bool"/></f></isStatic>
		<type public="1"><x path="Int"/></type>
		<world public="1"><x path="Bool"/></world>
		<outer public="1"><c path="nape.phys.Body"/></outer>
		<new public="1" set="method" line="1419"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.phys.ZPP_Compound" params="" file="libSrc/napeLib/zpp_nape/phys/Compound.hx" module="zpp_nape.phys.Compound">
		<extends path="zpp_nape.phys.ZPP_Interactor"/>
		<copy public="1" set="method" line="336"><f a="?dict:?todo">
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="Array"><c path="zpp_nape.constraint.ZPP_CopyHelper"/></c>
	<c path="nape.phys.Compound"/>
</f></copy>
		<compounds_modifiable set="method" line="305"><f a=""><x path="Void"/></f></compounds_modifiable>
		<compounds_subber set="method" line="299"><f a="x">
	<c path="nape.phys.Compound"/>
	<x path="Void"/>
</f></compounds_subber>
		<compounds_adder set="method" line="280"><f a="x">
	<c path="nape.phys.Compound"/>
	<x path="Bool"/>
</f></compounds_adder>
		<constraints_modifiable set="method" line="276"><f a=""><x path="Void"/></f></constraints_modifiable>
		<constraints_subber set="method" line="270"><f a="x">
	<c path="nape.constraint.Constraint"/>
	<x path="Void"/>
</f></constraints_subber>
		<constraints_adder set="method" line="258"><f a="x">
	<c path="nape.constraint.Constraint"/>
	<x path="Bool"/>
</f></constraints_adder>
		<bodies_modifiable set="method" line="254"><f a=""><x path="Void"/></f></bodies_modifiable>
		<bodies_subber set="method" line="248"><f a="x">
	<c path="nape.phys.Body"/>
	<x path="Void"/>
</f></bodies_subber>
		<bodies_adder set="method" line="236"><f a="x">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
</f></bodies_adder>
		<breakApart public="1" set="method" line="196"><f a=""><x path="Void"/></f></breakApart>
		<removedFromSpace public="1" set="method" line="193"><f a=""><x path="Void"/></f></removedFromSpace>
		<addedToSpace public="1" set="method" line="190"><f a=""><x path="Void"/></f></addedToSpace>
		<__imutable_midstep public="1" set="method" line="185"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></__imutable_midstep>
		<space public="1"><c path="zpp_nape.space.ZPP_Space"/></space>
		<compound public="1"><c path="zpp_nape.phys.ZPP_Compound"/></compound>
		<depth public="1"><x path="Int"/></depth>
		<wrap_compounds public="1"><c path="nape.phys.CompoundList"/></wrap_compounds>
		<wrap_constraints public="1"><c path="nape.constraint.ConstraintList"/></wrap_constraints>
		<wrap_bodies public="1"><c path="nape.phys.BodyList"/></wrap_bodies>
		<compounds public="1"><c path="zpp_nape.util.ZNPList_ZPP_Compound"/></compounds>
		<constraints public="1"><c path="zpp_nape.util.ZNPList_ZPP_Constraint"/></constraints>
		<bodies public="1"><c path="zpp_nape.util.ZNPList_ZPP_Body"/></bodies>
		<outer public="1"><c path="nape.phys.Compound"/></outer>
		<new public="1" set="method" line="309"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.phys.ZPP_FluidProperties" params="" file="libSrc/napeLib/zpp_nape/phys/FluidProperties.hx" module="zpp_nape.phys.FluidProperties">
		<zpp_pool public="1" line="176" static="1"><c path="zpp_nape.phys.ZPP_FluidProperties"/></zpp_pool>
		<invalidate public="1" set="method" line="355"><f a=""><x path="Void"/></f></invalidate>
		<getgravity public="1" set="method" line="349"><f a=""><x path="Void"/></f></getgravity>
		<gravity_validate set="method" line="327"><f a=""><x path="Void"/></f></gravity_validate>
		<gravity_invalidate set="method" line="304"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></gravity_invalidate>
		<wrap_gravity public="1"><c path="nape.geom.Vec2"/></wrap_gravity>
		<gravityy public="1"><x path="Float"/></gravityy>
		<gravityx public="1"><x path="Float"/></gravityx>
		<density public="1"><x path="Float"/></density>
		<viscosity public="1"><x path="Float"/></viscosity>
		<copy public="1" set="method" line="251"><f a=""><c path="zpp_nape.phys.ZPP_FluidProperties"/></f></copy>
		<remShape public="1" get="inline" set="null" line="248"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></remShape>
		<addShape public="1" get="inline" set="null" line="243"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></addShape>
		<feature_cons public="1" get="inline" set="null" line="238"><f a=""><x path="Void"/></f></feature_cons>
		<wrap_shapes public="1"><c path="nape.shape.ShapeList"/></wrap_shapes>
		<shapes public="1"><c path="zpp_nape.util.ZNPList_ZPP_Shape"/></shapes>
		<alloc public="1" get="inline" set="null" line="233"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="228"><f a=""><x path="Void"/></f></free>
		<wrapper public="1" set="method" line="202"><f a=""><c path="nape.phys.FluidProperties"/></f></wrapper>
		<outer public="1"><c path="nape.phys.FluidProperties"/></outer>
		<userData public="1"><d><d/></d></userData>
		<next public="1"><c path="zpp_nape.phys.ZPP_FluidProperties"/></next>
		<new public="1" set="method" line="274"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.phys.ZPP_Material" params="" file="libSrc/napeLib/zpp_nape/phys/Material.hx" module="zpp_nape.phys.Material">
		<zpp_pool public="1" line="176" static="1"><c path="zpp_nape.phys.ZPP_Material"/></zpp_pool>
		<WAKE public="1" line="280" static="1"><x path="Int"/></WAKE>
		<PROPS public="1" line="281" static="1"><x path="Int"/></PROPS>
		<ANGDRAG public="1" line="282" static="1"><x path="Int"/></ANGDRAG>
		<ARBITERS public="1" line="283" static="1"><x path="Int"/></ARBITERS>
		<invalidate public="1" set="method" line="284"><f a="x">
	<x path="Int"/>
	<x path="Void"/>
</f></invalidate>
		<set public="1" set="method" line="273"><f a="x">
	<c path="zpp_nape.phys.ZPP_Material"/>
	<x path="Void"/>
</f></set>
		<copy public="1" set="method" line="264"><f a=""><c path="zpp_nape.phys.ZPP_Material"/></f></copy>
		<rollingFriction public="1"><x path="Float"/></rollingFriction>
		<elasticity public="1"><x path="Float"/></elasticity>
		<density public="1"><x path="Float"/></density>
		<staticFriction public="1"><x path="Float"/></staticFriction>
		<dynamicFriction public="1"><x path="Float"/></dynamicFriction>
		<remShape public="1" get="inline" set="null" line="248"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></remShape>
		<addShape public="1" get="inline" set="null" line="243"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></addShape>
		<feature_cons public="1" get="inline" set="null" line="238"><f a=""><x path="Void"/></f></feature_cons>
		<wrap_shapes public="1"><c path="nape.shape.ShapeList"/></wrap_shapes>
		<shapes public="1"><c path="zpp_nape.util.ZNPList_ZPP_Shape"/></shapes>
		<alloc public="1" get="inline" set="null" line="233"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="228"><f a=""><x path="Void"/></f></free>
		<wrapper public="1" set="method" line="202"><f a=""><c path="nape.phys.Material"/></f></wrapper>
		<outer public="1"><c path="nape.phys.Material"/></outer>
		<userData public="1"><d><d/></d></userData>
		<next public="1"><c path="zpp_nape.phys.ZPP_Material"/></next>
		<new public="1" set="method" line="256"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.shape.ZPP_Shape" params="" file="libSrc/napeLib/zpp_nape/shape/Shape.hx" module="zpp_nape.shape.Shape">
		<extends path="zpp_nape.phys.ZPP_Interactor"/>
		<copy public="1" set="method" line="480"><f a=""><c path="nape.shape.Shape"/></f></copy>
		<removedFromSpace public="1" set="method" line="474"><f a=""><x path="Void"/></f></removedFromSpace>
		<addedToSpace public="1" set="method" line="468"><f a=""><x path="Void"/></f></addedToSpace>
		<removedFromBody public="1" set="method" line="467"><f a=""><x path="Void"/></f></removedFromBody>
		<addedToBody public="1" set="method" line="463"><f a=""><x path="Void"/></f></addedToBody>
		<__immutable_midstep public="1" set="method" line="458"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></__immutable_midstep>
		<setFluid public="1" set="method" line="448"><f a="fluid">
	<c path="zpp_nape.phys.ZPP_FluidProperties"/>
	<x path="Void"/>
</f></setFluid>
		<setFilter public="1" set="method" line="438"><f a="filter">
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<x path="Void"/>
</f></setFilter>
		<setMaterial public="1" set="method" line="427"><f a="material">
	<c path="zpp_nape.phys.ZPP_Material"/>
	<x path="Void"/>
</f></setMaterial>
		<aabb_validate set="method" line="364"><f a=""><x path="Void"/></f></aabb_validate>
		<invalidate_fluidprops public="1" set="method" line="361"><f a=""><x path="Void"/></f></invalidate_fluidprops>
		<invalidate_filter public="1" set="method" line="358"><f a=""><x path="Void"/></f></invalidate_filter>
		<invalidate_material public="1" set="method" line="341"><f a="flags">
	<x path="Int"/>
	<x path="Void"/>
</f></invalidate_material>
		<invalidate_worldCOM public="1" set="method" line="337"><f a=""><x path="Void"/></f></invalidate_worldCOM>
		<invalidate_localCOM public="1" set="method" line="329"><f a=""><x path="Void"/></f></invalidate_localCOM>
		<invalidate_angDrag public="1" set="method" line="326"><f a=""><x path="Void"/></f></invalidate_angDrag>
		<invalidate_area_inertia public="1" set="method" line="318"><f a=""><x path="Void"/></f></invalidate_area_inertia>
		<getworldCOM public="1" set="method" line="292"><f a=""><x path="Void"/></f></getworldCOM>
		<validate_worldCOM public="1" get="inline" set="null" line="279"><f a=""><x path="Void"/></f></validate_worldCOM>
		<validate_localCOM public="1" get="inline" set="null" line="271"><f a=""><x path="Void"/></f></validate_localCOM>
		<validate_angDrag public="1" set="method" line="261"><f a=""><x path="Void"/></f></validate_angDrag>
		<validate_area_inertia public="1" set="method" line="254"><f a=""><x path="Void"/></f></validate_area_inertia>
		<invalidate_aabb public="1" get="inline" set="null" line="250"><f a=""><x path="Void"/></f></invalidate_aabb>
		<force_validate_aabb public="1" get="inline" set="null" line="244"><f a=""><x path="Void"/></f></force_validate_aabb>
		<validate_aabb public="1" get="inline" set="null" line="233"><f a=""><x path="Void"/></f></validate_aabb>
		<zip_aabb public="1"><x path="Bool"/></zip_aabb>
		<aabb public="1"><c path="zpp_nape.geom.ZPP_AABB"/></aabb>
		<clear public="1" set="method" line="225"><f a=""><x path="Void"/></f></clear>
		<pairs public="1"><c path="zpp_nape.util.ZNPList_ZPP_AABBPair"/></pairs>
		<node public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></node>
		<sweep public="1"><c path="zpp_nape.space.ZPP_SweepData"/></sweep>
		<sensorEnabled public="1"><x path="Bool"/></sensorEnabled>
		<fluidEnabled public="1"><x path="Bool"/></fluidEnabled>
		<fluidProperties public="1"><c path="zpp_nape.phys.ZPP_FluidProperties"/></fluidProperties>
		<filter public="1"><c path="zpp_nape.dynamics.ZPP_InteractionFilter"/></filter>
		<material public="1"><c path="zpp_nape.phys.ZPP_Material"/></material>
		<refmaterial public="1"><c path="zpp_nape.phys.ZPP_Material"/></refmaterial>
		<polygon public="1"><c path="zpp_nape.shape.ZPP_Polygon"/></polygon>
		<circle public="1"><c path="zpp_nape.shape.ZPP_Circle"/></circle>
		<validate_sweepRadius public="1" set="method" line="207"><f a=""><x path="Void"/></f></validate_sweepRadius>
		<invalidate_sweepRadius public="1" get="inline" set="null" line="204"><f a=""><x path="Void"/></f></invalidate_sweepRadius>
		<sweepCoef public="1"><x path="Float"/></sweepCoef>
		<zip_sweepRadius public="1"><x path="Bool"/></zip_sweepRadius>
		<sweepRadius public="1"><x path="Float"/></sweepRadius>
		<wrap_worldCOM public="1"><c path="nape.geom.Vec2"/></wrap_worldCOM>
		<wrap_localCOM public="1"><c path="nape.geom.Vec2"/></wrap_localCOM>
		<zip_worldCOM public="1"><x path="Bool"/></zip_worldCOM>
		<worldCOMy public="1"><x path="Float"/></worldCOMy>
		<worldCOMx public="1"><x path="Float"/></worldCOMx>
		<zip_localCOM public="1"><x path="Bool"/></zip_localCOM>
		<localCOMy public="1"><x path="Float"/></localCOMy>
		<localCOMx public="1"><x path="Float"/></localCOMx>
		<zip_angDrag public="1"><x path="Bool"/></zip_angDrag>
		<angDrag public="1"><x path="Float"/></angDrag>
		<inertia public="1"><x path="Float"/></inertia>
		<zip_area_inertia public="1"><x path="Bool"/></zip_area_inertia>
		<area public="1"><x path="Float"/></area>
		<isPolygon public="1" get="inline" set="null" line="183"><f a=""><x path="Bool"/></f></isPolygon>
		<isCircle public="1" get="inline" set="null" line="179"><f a=""><x path="Bool"/></f></isCircle>
		<type public="1"><x path="Int"/></type>
		<body public="1"><c path="zpp_nape.phys.ZPP_Body"/></body>
		<outer public="1"><c path="nape.shape.Shape"/></outer>
		<new set="method" line="370"><f a="type">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.shape.ZPP_Circle" params="" file="libSrc/napeLib/zpp_nape/shape/Circle.hx" module="zpp_nape.shape.Circle">
		<extends path="zpp_nape.shape.ZPP_Shape"/>
		<__copy public="1" set="method" line="376"><f a=""><c path="zpp_nape.shape.ZPP_Circle"/></f></__copy>
		<__transform public="1" set="method" line="364"><f a="m">
	<c path="nape.geom.Mat23"/>
	<x path="Void"/>
</f></__transform>
		<__rotate public="1" set="method" line="333"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__rotate>
		<__translate public="1" set="method" line="317"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__translate>
		<__scale public="1" set="method" line="307"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__scale>
		<__validate_angDrag public="1" set="method" line="300"><f a=""><x path="Void"/></f></__validate_angDrag>
		<__validate_area_inertia public="1" set="method" line="295"><f a=""><x path="Void"/></f></__validate_area_inertia>
		<__validate_sweepRadius public="1" set="method" line="291"><f a=""><x path="Void"/></f></__validate_sweepRadius>
		<_force_validate_aabb public="1" get="inline" set="null" line="281"><f a=""><x path="Void"/></f></_force_validate_aabb>
		<__validate_aabb public="1" get="inline" set="null" line="250"><f a=""><x path="Void"/></f></__validate_aabb>
		<setupLocalCOM public="1" set="method" line="238"><f a=""><x path="Void"/></f></setupLocalCOM>
		<localCOM_immutable set="method" line="234"><f a=""><x path="Void"/></f></localCOM_immutable>
		<localCOM_invalidate set="method" line="209"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></localCOM_invalidate>
		<localCOM_validate set="method" line="189"><f a=""><x path="Void"/></f></localCOM_validate>
		<invalidate_radius public="1" set="method" line="183"><f a=""><x path="Void"/></f></invalidate_radius>
		<__clear public="1" set="method" line="182"><f a=""><x path="Void"/></f></__clear>
		<radius public="1"><x path="Float"/></radius>
		<outer_zn public="1"><c path="nape.shape.Circle"/></outer_zn>
		<new public="1" set="method" line="177"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.shape.ZPP_Edge" params="" file="libSrc/napeLib/zpp_nape/shape/Edge.hx" module="zpp_nape.shape.Edge">
		<zpp_pool public="1" line="176" static="1"><c path="zpp_nape.shape.ZPP_Edge"/></zpp_pool>
		<internal public="1" line="209" static="1"><x path="Bool"/></internal>
		<getgnorm public="1" set="method" line="293"><f a=""><x path="Void"/></f></getgnorm>
		<getlnorm public="1" set="method" line="288"><f a=""><x path="Void"/></f></getlnorm>
		<gnorm_validate set="method" line="261"><f a=""><x path="Void"/></f></gnorm_validate>
		<lnorm_validate set="method" line="235"><f a=""><x path="Void"/></f></lnorm_validate>
		<tp1 public="1"><x path="Float"/></tp1>
		<tp0 public="1"><x path="Float"/></tp0>
		<gp1 public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></gp1>
		<lp1 public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></lp1>
		<gp0 public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></gp0>
		<lp0 public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></lp0>
		<gprojection public="1"><x path="Float"/></gprojection>
		<lprojection public="1"><x path="Float"/></lprojection>
		<length public="1"><x path="Float"/></length>
		<wrap_gnorm public="1"><c path="nape.geom.Vec2"/></wrap_gnorm>
		<gnormy public="1"><x path="Float"/></gnormy>
		<gnormx public="1"><x path="Float"/></gnormx>
		<wrap_lnorm public="1"><c path="nape.geom.Vec2"/></wrap_lnorm>
		<lnormy public="1"><x path="Float"/></lnormy>
		<lnormx public="1"><x path="Float"/></lnormx>
		<wrapper public="1" set="method" line="211"><f a=""><c path="nape.shape.Edge"/></f></wrapper>
		<outer public="1"><c path="nape.shape.Edge"/></outer>
		<polygon public="1"><c path="zpp_nape.shape.ZPP_Polygon"/></polygon>
		<alloc public="1" get="inline" set="null" line="207"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="202"><f a=""><x path="Void"/></f></free>
		<next public="1"><c path="zpp_nape.shape.ZPP_Edge"/></next>
		<new public="1" set="method" line="298"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.shape.ZPP_Polygon" params="" file="libSrc/napeLib/zpp_nape/shape/Polygon.hx" module="zpp_nape.shape.Polygon">
		<extends path="zpp_nape.shape.ZPP_Shape"/>
		<__copy public="1" set="method" line="1926"><f a=""><c path="zpp_nape.shape.ZPP_Polygon"/></f></__copy>
		<__transform public="1" set="method" line="1909"><f a="mat">
	<c path="nape.geom.Mat23"/>
	<x path="Void"/>
</f></__transform>
		<__rotate public="1" set="method" line="1871"><f a="ax:ay">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__rotate>
		<__scale public="1" set="method" line="1857"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__scale>
		<__translate public="1" set="method" line="1834"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__translate>
		<setupLocalCOM public="1" set="method" line="1820"><f a=""><x path="Void"/></f></setupLocalCOM>
		<localCOM_invalidate set="method" line="1774"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></localCOM_invalidate>
		<localCOM_validate set="method" line="1768"><f a=""><x path="Void"/></f></localCOM_validate>
		<__validate_localCOM public="1" get="inline" set="null" line="1621"><f a=""><x path="Void"/></f></__validate_localCOM>
		<__validate_angDrag public="1" set="method" line="1393"><f a=""><x path="Void"/></f></__validate_angDrag>
		<__validate_area_inertia public="1" set="method" line="1336"><f a=""><x path="Void"/></f></__validate_area_inertia>
		<__validate_sweepRadius public="1" set="method" line="1302"><f a=""><x path="Void"/></f></__validate_sweepRadius>
		<_force_validate_aabb public="1" get="inline" set="null" line="1233"><f a=""><x path="Void"/></f></_force_validate_aabb>
		<__validate_aabb public="1" get="inline" set="null" line="1171"><f a=""><x path="Void"/></f></__validate_aabb>
		<validate_gaxi public="1" get="inline" set="null" line="1081"><f a=""><x path="Void"/></f></validate_gaxi>
		<validate_gverts public="1" get="inline" set="null" line="1055"><f a=""><x path="Void"/></f></validate_gverts>
		<validate_laxi public="1" set="method" line="889"><f a=""><x path="Void"/></f></validate_laxi>
		<reverse_vertices public="1" set="method" line="877"><f a=""><x path="Void"/></f></reverse_vertices>
		<splice_collinear_real public="1" set="method" line="821"><f a=""><x path="Void"/></f></splice_collinear_real>
		<splice_collinear public="1" get="inline" set="null" line="815"><f a=""><x path="Void"/></f></splice_collinear>
		<zip_sanitation public="1"><x path="Bool"/></zip_sanitation>
		<cleanup_lvert public="1" set="method" line="714"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></cleanup_lvert>
		<validate_lverts public="1" set="method" line="702"><f a=""><x path="Void"/></f></validate_lverts>
		<valid public="1" set="method" line="369"><f a=""><c path="nape.shape.ValidationResult"/></f></valid>
		<validation public="1"><c path="nape.shape.ValidationResult"/></validation>
		<zip_valid public="1"><x path="Bool"/></zip_valid>
		<invalidate_gaxi public="1" set="method" line="364"><f a=""><x path="Void"/></f></invalidate_gaxi>
		<zip_gaxi public="1"><x path="Bool"/></zip_gaxi>
		<invalidate_gverts public="1" set="method" line="359"><f a=""><x path="Void"/></f></invalidate_gverts>
		<zip_gverts public="1"><x path="Bool"/></zip_gverts>
		<invalidate_laxi public="1" set="method" line="353"><f a=""><x path="Void"/></f></invalidate_laxi>
		<zip_laxi public="1"><x path="Bool"/></zip_laxi>
		<invalidate_lverts public="1" set="method" line="341"><f a=""><x path="Void"/></f></invalidate_lverts>
		<zip_lverts public="1"><x path="Bool"/></zip_lverts>
		<getedges public="1" set="method" line="334"><f a=""><x path="Void"/></f></getedges>
		<getgverts public="1" set="method" line="328"><f a=""><x path="Void"/></f></getgverts>
		<getlverts public="1" set="method" line="316"><f a=""><x path="Void"/></f></getlverts>
		<edges_validate set="method" line="312"><f a=""><x path="Void"/></f></edges_validate>
		<gverts_validate set="method" line="309"><f a=""><x path="Void"/></f></gverts_validate>
		<lverts_modifiable set="method" line="302"><f a=""><x path="Void"/></f></lverts_modifiable>
		<lverts_validate set="method" line="298"><f a=""><x path="Void"/></f></lverts_validate>
		<lverts_invalidate set="method" line="295"><f a="_">
	<c path="zpp_nape.util.ZPP_Vec2List"/>
	<x path="Void"/>
</f></lverts_invalidate>
		<lverts_subber set="method" line="292"><f a="x">
	<c path="nape.geom.Vec2"/>
	<x path="Void"/>
</f></lverts_subber>
		<lverts_post_adder set="method" line="199"><f a="x">
	<c path="nape.geom.Vec2"/>
	<x path="Void"/>
</f></lverts_post_adder>
		<gverts_pa_validate set="method" line="193"><f a=""><x path="Void"/></f></gverts_pa_validate>
		<lverts_pa_immutable set="method" line="189"><f a=""><x path="Void"/></f></lverts_pa_immutable>
		<lverts_pa_invalidate set="method" line="185"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></lverts_pa_invalidate>
		<__clear public="1" set="method" line="184"><f a=""><x path="Void"/></f></__clear>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<edgeCnt public="1"><x path="Int"/></edgeCnt>
		<wrap_edges public="1"><c path="nape.shape.EdgeList"/></wrap_edges>
		<edges public="1"><c path="zpp_nape.util.ZNPList_ZPP_Edge"/></edges>
		<wrap_gverts public="1"><c path="nape.geom.Vec2List"/></wrap_gverts>
		<gverts public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></gverts>
		<wrap_lverts public="1"><c path="nape.geom.Vec2List"/></wrap_lverts>
		<lverts public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></lverts>
		<outer_zn public="1"><c path="nape.shape.Polygon"/></outer_zn>
		<new public="1" set="method" line="1826"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_Broadphase" params="" file="libSrc/napeLib/zpp_nape/space/Broadphase.hx" module="zpp_nape.space.Broadphase">
		<rayMultiCast public="1" set="method" line="274"><f a="ray:inner:filter:output">
	<c path="zpp_nape.geom.ZPP_Ray"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.geom.RayResultList"/>
	<c path="nape.geom.RayResultList"/>
</f></rayMultiCast>
		<rayCast public="1" set="method" line="271"><f a="ray:inner:filter">
	<c path="zpp_nape.geom.ZPP_Ray"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.geom.RayResult"/>
</f></rayCast>
		<bodiesInShape public="1" set="method" line="268"><f a="shape:containment:filter:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInShape>
		<shapesInShape public="1" set="method" line="265"><f a="shape:containment:filter:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInShape>
		<validateShape public="1" set="method" line="260"><f a="s">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></validateShape>
		<bodiesInCircle public="1" set="method" line="257"><f a="x:y:r:containment:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInCircle>
		<shapesInCircle public="1" set="method" line="254"><f a="x:y:r:containment:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInCircle>
		<updateCircShape public="1" set="method" line="237"><f a="x:y:r">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></updateCircShape>
		<circShape public="1"><c path="nape.shape.Shape"/></circShape>
		<bodiesInAABB public="1" set="method" line="233"><f a="aabb:strict:containment:filter:output">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInAABB>
		<shapesInAABB public="1" set="method" line="230"><f a="aabb:strict:containment:filter:output">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInAABB>
		<updateAABBShape public="1" set="method" line="210"><f a="aabb">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Void"/>
</f></updateAABBShape>
		<matrix public="1"><c path="nape.geom.Mat23"/></matrix>
		<aabbShape public="1"><c path="nape.shape.Shape"/></aabbShape>
		<bodiesUnderPoint public="1" set="method" line="205"><f a="x:y:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesUnderPoint>
		<shapesUnderPoint public="1" set="method" line="202"><f a="x:y:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesUnderPoint>
		<clear public="1" set="method" line="201"><f a=""><x path="Void"/></f></clear>
		<broadphase public="1" set="method" line="191"><f a="space:discrete">
	<c path="zpp_nape.space.ZPP_Space"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></broadphase>
		<sync public="1" set="method" line="187"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></sync>
		<remove public="1" set="method" line="183"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></remove>
		<insert public="1" set="method" line="179"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></insert>
		<dynab public="1"><c path="zpp_nape.space.ZPP_DynAABBPhase"/></dynab>
		<sweep public="1"><c path="zpp_nape.space.ZPP_SweepPhase"/></sweep>
		<is_sweep public="1"><x path="Bool"/></is_sweep>
		<space public="1"><c path="zpp_nape.space.ZPP_Space"/></space>
		<new public="1" set="method" line="174"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_AABBNode" params="" file="libSrc/napeLib/zpp_nape/space/DynAABBPhase.hx" module="zpp_nape.space.DynAABBPhase">
		<zpp_pool public="1" line="187" static="1"><c path="zpp_nape.space.ZPP_AABBNode"/></zpp_pool>
		<isLeaf public="1" get="inline" set="null" line="268"><f a=""><x path="Bool"/></f></isLeaf>
		<first_sync public="1"><x path="Bool"/></first_sync>
		<synced public="1"><x path="Bool"/></synced>
		<snext public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></snext>
		<moved public="1"><x path="Bool"/></moved>
		<mnext public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></mnext>
		<free public="1" get="inline" set="null" line="237"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="213"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></next>
		<rayt public="1"><x path="Float"/></rayt>
		<height public="1"><x path="Int"/></height>
		<child2 public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></child2>
		<child1 public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></child1>
		<parent public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></parent>
		<dyn public="1"><x path="Bool"/></dyn>
		<shape public="1"><c path="zpp_nape.shape.ZPP_Shape"/></shape>
		<aabb public="1"><c path="zpp_nape.geom.ZPP_AABB"/></aabb>
		<new public="1" set="method" line="183"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_AABBPair" params="" file="libSrc/napeLib/zpp_nape/space/DynAABBPhase.hx" module="zpp_nape.space.DynAABBPhase">
		<zpp_pool public="1" line="282" static="1"><c path="zpp_nape.space.ZPP_AABBPair"/></zpp_pool>
		<free public="1" get="inline" set="null" line="321"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="309"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.space.ZPP_AABBPair"/></next>
		<arb public="1"><c path="zpp_nape.dynamics.ZPP_Arbiter"/></arb>
		<di public="1"><x path="Int"/></di>
		<id public="1"><x path="Int"/></id>
		<sleeping public="1"><x path="Bool"/></sleeping>
		<first public="1"><x path="Bool"/></first>
		<n2 public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></n2>
		<n1 public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></n1>
		<new public="1" set="method" line="306"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_AABBTree" params="" file="libSrc/napeLib/zpp_nape/space/DynAABBPhase.hx" module="zpp_nape.space.DynAABBPhase">
		<tmpaabb public="1" line="419" static="1"><c path="zpp_nape.geom.ZPP_AABB"/></tmpaabb>
		<balance public="1" get="inline" set="null" line="589"><f a="a">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<c path="zpp_nape.space.ZPP_AABBNode"/>
</f></balance>
		<inlined_removeLeaf public="1" get="inline" set="null" line="520"><f a="leaf">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Void"/>
</f></inlined_removeLeaf>
		<removeLeaf public="1" set="method" line="515"><f a="leaf">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Void"/>
</f></removeLeaf>
		<inlined_insertLeaf public="1" get="inline" set="null" line="425"><f a="leaf">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Void"/>
</f></inlined_insertLeaf>
		<insertLeaf set="method" line="420"><f a="leaf">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Void"/>
</f></insertLeaf>
		<clear public="1" set="method" line="338"><f a=""><x path="Void"/></f></clear>
		<root public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></root>
		<new public="1" set="method" line="337"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_DynAABBPhase" params="" file="libSrc/napeLib/zpp_nape/space/DynAABBPhase.hx" module="zpp_nape.space.DynAABBPhase">
		<extends path="zpp_nape.space.ZPP_Broadphase"/>
		<FATTEN get="inline" set="null" line="696" static="1"><x path="Float"/></FATTEN>
		<VEL_STEPS get="inline" set="null" line="698" static="1"><x path="Float"/></VEL_STEPS>
		<rayMultiCast public="1" set="method" line="2950" override="1"><f a="ray:inner:filter:output">
	<c path="zpp_nape.geom.ZPP_Ray"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.geom.RayResultList"/>
	<c path="nape.geom.RayResultList"/>
</f></rayMultiCast>
		<rayCast public="1" set="method" line="2821" override="1"><f a="ray:inner:filter">
	<c path="zpp_nape.geom.ZPP_Ray"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.geom.RayResult"/>
</f></rayCast>
		<openlist public="1"><c path="zpp_nape.util.ZNPList_ZPP_AABBNode"/></openlist>
		<bodiesInShape public="1" set="method" line="2721" override="1"><f a="shp:containment:filter:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInShape>
		<shapesInShape public="1" set="method" line="2644" override="1"><f a="shp:containment:filter:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInShape>
		<bodiesInCircle public="1" set="method" line="2545" override="1"><f a="x:y:r:containment:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInCircle>
		<shapesInCircle public="1" set="method" line="2468" override="1"><f a="x:y:r:containment:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInCircle>
		<bodiesInAABB public="1" set="method" line="2277" override="1"><f a="aabb:strict:containment:filter:output">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInAABB>
		<failed public="1"><c path="nape.phys.BodyList"/></failed>
		<shapesInAABB public="1" set="method" line="2133" override="1"><f a="aabb:strict:containment:filter:output">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInAABB>
		<treeStack2 public="1"><c path="zpp_nape.util.ZNPList_ZPP_AABBNode"/></treeStack2>
		<bodiesUnderPoint public="1" set="method" line="2029" override="1"><f a="x:y:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesUnderPoint>
		<shapesUnderPoint public="1" set="method" line="1932" override="1"><f a="x:y:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesUnderPoint>
		<treeStack><c path="zpp_nape.util.ZNPList_ZPP_AABBNode"/></treeStack>
		<clear public="1" set="method" line="1882" override="1"><f a=""><x path="Void"/></f></clear>
		<broadphase public="1" set="method" line="1106" override="1"><f a="space:discrete">
	<c path="zpp_nape.space.ZPP_Space"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></broadphase>
		<sync_broadphase public="1" set="method" line="986"><f a=""><x path="Void"/></f></sync_broadphase>
		<__sync public="1" get="inline" set="null" line="944"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></__sync>
		<__remove public="1" set="method" line="777"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></__remove>
		<__insert public="1" set="method" line="717"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></__insert>
		<dyn public="1" get="inline" set="null" line="713"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></dyn>
		<moves public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></moves>
		<syncs public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></syncs>
		<pairs public="1"><c path="zpp_nape.space.ZPP_AABBPair"/></pairs>
		<dtree public="1"><c path="zpp_nape.space.ZPP_AABBTree"/></dtree>
		<stree public="1"><c path="zpp_nape.space.ZPP_AABBTree"/></stree>
		<new public="1" set="method" line="704"><f a="space">
	<c path="zpp_nape.space.ZPP_Space"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.space.ZPP_Island" params="" file="libSrc/napeLib/zpp_nape/space/Space.hx" module="zpp_nape.space.Space">
		<zpp_pool public="1" line="533" static="1"><c path="zpp_nape.space.ZPP_Island"/></zpp_pool>
		<alloc public="1" get="inline" set="null" line="571"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="559"><f a=""><x path="Void"/></f></free>
		<waket public="1"><x path="Int"/></waket>
		<sleep public="1"><x path="Bool"/></sleep>
		<comps public="1"><c path="zpp_nape.util.ZNPList_ZPP_Component"/></comps>
		<at public="1" set="method" line="518"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></at>
		<iterator_at public="1" set="method" line="505"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></iterator_at>
		<back public="1" set="method" line="496"><f a=""><c path="zpp_nape.space.ZPP_Island"/></f></back>
		<front public="1" get="inline" set="null" line="493"><f a=""><c path="zpp_nape.space.ZPP_Island"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="463"><f a="obj">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="458"><f a="obj">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="455"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="450"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="435"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="429"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="424"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="420"><f a="pre:n">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="388"><f a="pre">
	<c path="zpp_nape.space.ZPP_Island"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></inlined_erase>
		<erase public="1" set="method" line="383"><f a="pre">
	<c path="zpp_nape.space.ZPP_Island"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="360"><f a="obj">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="347"><f a="obj">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="322"><f a="obj">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="311"><f a="obj">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="298"><f a=""><c path="zpp_nape.space.ZPP_Island"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="293"><f a=""><c path="zpp_nape.space.ZPP_Island"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="274"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="269"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="244"><f a="cur:o">
	<c path="zpp_nape.space.ZPP_Island"/>
	<c path="zpp_nape.space.ZPP_Island"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></inlined_insert>
		<insert public="1" set="method" line="239"><f a="cur:o">
	<c path="zpp_nape.space.ZPP_Island"/>
	<c path="zpp_nape.space.ZPP_Island"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></insert>
		<addAll public="1" set="method" line="221"><f a="x">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="202"><f a="o">
	<c path="zpp_nape.space.ZPP_Island"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></inlined_add>
		<add public="1" set="method" line="197"><f a="o">
	<c path="zpp_nape.space.ZPP_Island"/>
	<c path="zpp_nape.space.ZPP_Island"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="192"><f a="i">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<_inuse public="1"><x path="Bool"/></_inuse>
		<begin public="1" get="inline" set="null" line="183"><f a=""><c path="zpp_nape.space.ZPP_Island"/></f></begin>
		<elem public="1" get="inline" set="null" line="178"><f a=""><c path="zpp_nape.space.ZPP_Island"/></f></elem>
		<next public="1"><c path="zpp_nape.space.ZPP_Island"/></next>
		<new public="1" set="method" line="574"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_Component" params="" file="libSrc/napeLib/zpp_nape/space/Space.hx" module="zpp_nape.space.Space">
		<zpp_pool public="1" line="581" static="1"><c path="zpp_nape.space.ZPP_Component"/></zpp_pool>
		<reset public="1" get="inline" set="null" line="637"><f a=""><x path="Void"/></f></reset>
		<alloc public="1" get="inline" set="null" line="630"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="616"><f a=""><x path="Void"/></f></free>
		<woken public="1"><x path="Bool"/></woken>
		<waket public="1"><x path="Int"/></waket>
		<sleeping public="1"><x path="Bool"/></sleeping>
		<island public="1"><c path="zpp_nape.space.ZPP_Island"/></island>
		<constraint public="1"><c path="zpp_nape.constraint.ZPP_Constraint"/></constraint>
		<body public="1"><c path="zpp_nape.phys.ZPP_Body"/></body>
		<isBody public="1"><x path="Bool"/></isBody>
		<rank public="1"><x path="Int"/></rank>
		<parent public="1"><c path="zpp_nape.space.ZPP_Component"/></parent>
		<next public="1"><c path="zpp_nape.space.ZPP_Component"/></next>
		<new public="1" set="method" line="631"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_CallbackSet" params="" file="libSrc/napeLib/zpp_nape/space/Space.hx" module="zpp_nape.space.Space">
		<get public="1" set="method" line="650" static="1"><f a="i1:i2">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></get>
		<zpp_pool public="1" line="1059" static="1"><c path="zpp_nape.space.ZPP_CallbackSet"/></zpp_pool>
		<sleeping public="1" get="inline" set="null" line="1163"><f a=""><x path="Bool"/></f></sleeping>
		<really_empty public="1" get="inline" set="null" line="1158"><f a=""><x path="Bool"/></f></really_empty>
		<empty_arb public="1" set="method" line="1130"><f a="type">
	<x path="Int"/>
	<x path="Bool"/>
</f></empty_arb>
		<remove_arb public="1" set="method" line="1127"><f a="x">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Void"/>
</f></remove_arb>
		<try_remove_arb public="1" set="method" line="1124"><f a="x">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Bool"/>
</f></try_remove_arb>
		<add_arb public="1" get="inline" set="null" line="1117"><f a="x">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Bool"/>
</f></add_arb>
		<alloc public="1" get="inline" set="null" line="1102"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="1087"><f a=""><x path="Void"/></f></free>
		<lazydel public="1"><x path="Bool"/></lazydel>
		<freed public="1"><x path="Bool"/></freed>
		<at public="1" set="method" line="1047"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></at>
		<iterator_at public="1" set="method" line="1034"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></iterator_at>
		<back public="1" set="method" line="1025"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></back>
		<front public="1" get="inline" set="null" line="1022"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="992"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="987"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="984"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="979"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="964"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="958"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="953"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="949"><f a="pre:n">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="917"><f a="pre">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></inlined_erase>
		<erase public="1" set="method" line="912"><f a="pre">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="889"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="876"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="851"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="840"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="827"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="822"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="803"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="798"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="773"><f a="cur:o">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></inlined_insert>
		<insert public="1" set="method" line="768"><f a="cur:o">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></insert>
		<addAll public="1" set="method" line="750"><f a="x">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="731"><f a="o">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></inlined_add>
		<add public="1" set="method" line="726"><f a="o">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="721"><f a="i">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<_inuse public="1"><x path="Bool"/></_inuse>
		<begin public="1" get="inline" set="null" line="712"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></begin>
		<elem public="1" get="inline" set="null" line="707"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></elem>
		<next public="1"><c path="zpp_nape.space.ZPP_CallbackSet"/></next>
		<FLUIDstamp public="1"><x path="Int"/></FLUIDstamp>
		<FLUIDstate public="1"><x path="Int"/></FLUIDstate>
		<SENSORstamp public="1"><x path="Int"/></SENSORstamp>
		<SENSORstate public="1"><x path="Int"/></SENSORstate>
		<COLLISIONstamp public="1"><x path="Int"/></COLLISIONstamp>
		<COLLISIONstate public="1"><x path="Int"/></COLLISIONstate>
		<arbiters public="1"><c path="zpp_nape.util.ZNPList_ZPP_Arbiter"/></arbiters>
		<int2 public="1"><c path="zpp_nape.phys.ZPP_Interactor"/></int2>
		<int1 public="1"><c path="zpp_nape.phys.ZPP_Interactor"/></int1>
		<di public="1"><x path="Int"/></di>
		<id public="1"><x path="Int"/></id>
		<new public="1" set="method" line="1113"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_CbSetManager" params="" file="libSrc/napeLib/zpp_nape/space/Space.hx" module="zpp_nape.space.Space">
		<valid_listener public="1" get="inline" set="null" line="1374"><f a="i">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Bool"/>
</f></valid_listener>
		<pair public="1" get="inline" set="null" line="1348"><f a="a:b">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
</f></pair>
		<validate public="1" get="inline" set="null" line="1318"><f a=""><x path="Void"/></f></validate>
		<clear public="1" set="method" line="1285"><f a=""><x path="Void"/></f></clear>
		<remove public="1" set="method" line="1253"><f a="set">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Void"/>
</f></remove>
		<get public="1" set="method" line="1194"><f a="cbTypes">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
</f></get>
		<space public="1"><c path="zpp_nape.space.ZPP_Space"/></space>
		<cbsets public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/></cbsets>
		<new public="1" set="method" line="1295"><f a="space">
	<c path="zpp_nape.space.ZPP_Space"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.space.ZPP_Space" params="" file="libSrc/napeLib/zpp_nape/space/Space.hx" module="zpp_nape.space.Space">
		<inlined_MRCA_chains public="1" get="inline" set="null" line="7220"><f a="s1:s2">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></inlined_MRCA_chains>
		<MRCA_chains public="1" set="method" line="7215"><f a="s1:s2">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></MRCA_chains>
		<mrca2 public="1"><c path="zpp_nape.util.ZNPList_ZPP_Interactor"/></mrca2>
		<mrca1 public="1"><c path="zpp_nape.util.ZNPList_ZPP_Interactor"/></mrca1>
		<narrowPhase public="1" set="method" line="5860"><f a="s1:s2:stat:in_arb:continuous">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
</f></narrowPhase>
		<prelisteners><c path="zpp_nape.util.ZNPList_ZPP_InteractionListener"/></prelisteners>
		<precb><c path="nape.callbacks.PreCallback"/></precb>
		<interactionType public="1" get="inline" set="null" line="5810"><f a="s1:s2:b1:b2">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Int"/>
</f></interactionType>
		<group_ignore public="1" get="inline" set="null" line="5788"><f a="s1:s2">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></group_ignore>
		<iteratePos public="1" set="method" line="5731"><f a="times">
	<x path="Int"/>
	<x path="Void"/>
</f></iteratePos>
		<iterateVel public="1" set="method" line="5674"><f a="times">
	<x path="Int"/>
	<x path="Void"/>
</f></iterateVel>
		<warmStart public="1" set="method" line="5637"><f a=""><x path="Void"/></f></warmStart>
		<prestep public="1" set="method" line="5492"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></prestep>
		<presteparb public="1" set="method" line="5348"><f a="arb:dt:?cont">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></presteparb>
		<continuous public="1"><x path="Bool"/></continuous>
		<updatePos public="1" set="method" line="5158"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></updatePos>
		<updateVel public="1" set="method" line="5128"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></updateVel>
		<validation public="1" set="method" line="4936"><f a=""><x path="Void"/></f></validation>
		<static_validation public="1" set="method" line="4906"><f a="body">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></static_validation>
		<sleepArbiters public="1" set="method" line="4757"><f a=""><x path="Void"/></f></sleepArbiters>
		<doForests public="1" set="method" line="4467"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></doForests>
		<wake_constraint public="1" set="method" line="4424"><f a="con:?fst">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></wake_constraint>
		<really_wake public="1" set="method" line="4315"><f a="o:?fst">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></really_wake>
		<non_inlined_wake public="1" set="method" line="4287"><f a="o:?fst">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></non_inlined_wake>
		<wakeIsland public="1" set="method" line="4184"><f a="i">
	<c path="zpp_nape.space.ZPP_Island"/>
	<x path="Void"/>
</f></wakeIsland>
		<wakeCompound public="1" set="method" line="4133"><f a="x">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Void"/>
</f></wakeCompound>
		<freshInteractorType public="1" set="method" line="4045"><f a="intx:?me">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></freshInteractorType>
		<freshListenerType public="1" set="method" line="3948"><f a="cb1:cb2">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Void"/>
</f></freshListenerType>
		<nullInteractorType public="1" set="method" line="3866"><f a="intx:?me">
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<c path="zpp_nape.phys.ZPP_Interactor"/>
	<x path="Void"/>
</f></nullInteractorType>
		<nullListenerType public="1" set="method" line="3757"><f a="cb1:cb2">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Void"/>
</f></nullListenerType>
		<constraintCbBreak public="1" set="method" line="3737"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></constraintCbBreak>
		<constraintCbSleep public="1" set="method" line="3717"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></constraintCbSleep>
		<constraintCbWake public="1" set="method" line="3694"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></constraintCbWake>
		<bodyCbSleep public="1" set="method" line="3674"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></bodyCbSleep>
		<bodyCbWake public="1" set="method" line="3651"><f a="b">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></bodyCbWake>
		<continuousEvent public="1" set="method" line="3565"><f a="s1:s2:stat:in_arb:_">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
</f></continuousEvent>
		<continuousCollisions public="1" set="method" line="3355"><f a="deltaTime">
	<x path="Float"/>
	<x path="Void"/>
</f></continuousCollisions>
		<toiEvents public="1"><c path="zpp_nape.util.ZNPList_ZPP_ToiEvent"/></toiEvents>
		<step public="1" set="method" line="3014"><f a="deltaTime:velocityIterations:positionIterations">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></step>
		<pre_dt public="1"><x path="Float"/></pre_dt>
		<push_callback public="1" set="method" line="2982"><f a="i">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<c path="zpp_nape.callbacks.ZPP_Callback"/>
</f></push_callback>
		<convexMultiCast public="1" set="method" line="2837"><f a="shape:deltaTime:filter:dynamics:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Float"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<x path="Bool"/>
	<c path="nape.geom.ConvexResultList"/>
	<c path="nape.geom.ConvexResultList"/>
</f></convexMultiCast>
		<prepareCast get="inline" set="null" line="2833"><f a="s">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></prepareCast>
		<convexCast public="1" set="method" line="2612"><f a="shape:deltaTime:filter:dynamics">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Float"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<x path="Bool"/>
	<c path="nape.geom.ConvexResult"/>
</f></convexCast>
		<convexShapeList><c path="nape.shape.ShapeList"/></convexShapeList>
		<rayMultiCast public="1" set="method" line="2608"><f a="ray:inner:filter:output">
	<c path="nape.geom.Ray"/>
	<x path="Bool"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<c path="nape.geom.RayResultList"/>
	<c path="nape.geom.RayResultList"/>
</f></rayMultiCast>
		<rayCast public="1" set="method" line="2605"><f a="ray:inner:filter">
	<c path="nape.geom.Ray"/>
	<x path="Bool"/>
	<c path="nape.dynamics.InteractionFilter"/>
	<c path="nape.geom.RayResult"/>
</f></rayCast>
		<bodiesInShape public="1" set="method" line="2602"><f a="shape:cont:filter:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInShape>
		<shapesInShape public="1" set="method" line="2599"><f a="shape:cont:filter:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInShape>
		<bodiesInCircle public="1" set="method" line="2596"><f a="pos:rad:cont:filter:output">
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInCircle>
		<shapesInCircle public="1" set="method" line="2593"><f a="pos:rad:cont:filter:output">
	<c path="nape.geom.Vec2"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInCircle>
		<bodiesInAABB public="1" set="method" line="2590"><f a="aabb:strict:cont:filter:output">
	<c path="nape.geom.AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInAABB>
		<shapesInAABB public="1" set="method" line="2587"><f a="aabb:strict:cont:filter:output">
	<c path="nape.geom.AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInAABB>
		<bodiesUnderPoint public="1" set="method" line="2584"><f a="x:y:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesUnderPoint>
		<shapesUnderPoint public="1" set="method" line="2581"><f a="x:y:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesUnderPoint>
		<remBody public="1" set="method" line="2439"><f a="body:?flag">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Int"/>
	<x path="Void"/>
</f></remBody>
		<addBody public="1" set="method" line="2358"><f a="body:?flag">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addBody>
		<remCompound public="1" set="method" line="2330"><f a="x">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Void"/>
</f></remCompound>
		<addCompound public="1" set="method" line="2302"><f a="x">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Void"/>
</f></addCompound>
		<remConstraint public="1" set="method" line="2294"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></remConstraint>
		<addConstraint public="1" set="method" line="2278"><f a="con">
	<c path="zpp_nape.constraint.ZPP_Constraint"/>
	<x path="Void"/>
</f></addConstraint>
		<removed_shape public="1" set="method" line="2134"><f a="s:?deleting">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></removed_shape>
		<added_shape public="1" get="inline" set="null" line="2102"><f a="s:?dontwake">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></added_shape>
		<transmitType public="1" set="method" line="2033"><f a="p:new_type">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Int"/>
	<x path="Void"/>
</f></transmitType>
		<remove_callbackset public="1" set="method" line="2028"><f a="cb">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Void"/>
</f></remove_callbackset>
		<add_callbackset public="1" set="method" line="2015"><f a="cb">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Void"/>
</f></add_callbackset>
		<remListener public="1" set="method" line="2008"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Void"/>
</f></remListener>
		<addListener public="1" set="method" line="2001"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Void"/>
</f></addListener>
		<unrevoke_listener public="1" get="inline" set="null" line="2000"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Void"/>
</f></unrevoke_listener>
		<revoke_listener public="1" get="inline" set="null" line="1997"><f a="x">
	<c path="zpp_nape.callbacks.ZPP_InteractionListener"/>
	<x path="Void"/>
</f></revoke_listener>
		<listeners_modifiable set="method" line="1884"><f a=""><x path="Void"/></f></listeners_modifiable>
		<listeners_subber set="method" line="1880"><f a="x">
	<c path="nape.callbacks.Listener"/>
	<x path="Void"/>
</f></listeners_subber>
		<listeners_adder set="method" line="1872"><f a="x">
	<c path="nape.callbacks.Listener"/>
	<x path="Bool"/>
</f></listeners_adder>
		<constraints_modifiable set="method" line="1868"><f a=""><x path="Void"/></f></constraints_modifiable>
		<constraints_subber set="method" line="1864"><f a="x">
	<c path="nape.constraint.Constraint"/>
	<x path="Void"/>
</f></constraints_subber>
		<constraints_adder set="method" line="1853"><f a="x">
	<c path="nape.constraint.Constraint"/>
	<x path="Bool"/>
</f></constraints_adder>
		<compounds_modifiable set="method" line="1849"><f a=""><x path="Void"/></f></compounds_modifiable>
		<compounds_subber set="method" line="1845"><f a="x">
	<c path="nape.phys.Compound"/>
	<x path="Void"/>
</f></compounds_subber>
		<compounds_adder set="method" line="1834"><f a="x">
	<c path="nape.phys.Compound"/>
	<x path="Bool"/>
</f></compounds_adder>
		<bodies_modifiable set="method" line="1830"><f a=""><x path="Void"/></f></bodies_modifiable>
		<bodies_subber set="method" line="1826"><f a="x">
	<c path="nape.phys.Body"/>
	<x path="Void"/>
</f></bodies_subber>
		<bodies_adder set="method" line="1815"><f a="x">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
</f></bodies_adder>
		<clear public="1" set="method" line="1556"><f a=""><x path="Void"/></f></clear>
		<cbsets public="1"><c path="zpp_nape.space.ZPP_CbSetManager"/></cbsets>
		<callbackset_list public="1"><c path="zpp_nape.space.ZPP_CallbackSet"/></callbackset_list>
		<callbacks public="1"><c path="zpp_nape.callbacks.ZPP_Callback"/></callbacks>
		<wrap_listeners public="1"><c path="nape.callbacks.ListenerList"/></wrap_listeners>
		<listeners public="1"><c path="zpp_nape.util.ZNPList_ZPP_Listener"/></listeners>
		<islands public="1"><c path="zpp_nape.space.ZPP_Island"/></islands>
		<staticsleep public="1"><c path="zpp_nape.util.ZNPList_ZPP_Body"/></staticsleep>
		<wrap_livecon public="1"><c path="nape.constraint.ConstraintList"/></wrap_livecon>
		<live_constraints public="1"><c path="zpp_nape.util.ZNPList_ZPP_Constraint"/></live_constraints>
		<wrap_live public="1"><c path="nape.phys.BodyList"/></wrap_live>
		<live public="1"><c path="zpp_nape.util.ZNPList_ZPP_Body"/></live>
		<wrap_arbiters public="1"><c path="nape.dynamics.ArbiterList"/></wrap_arbiters>
		<s_arbiters public="1"><c path="zpp_nape.util.ZNPList_ZPP_SensorArbiter"/></s_arbiters>
		<f_arbiters public="1"><c path="zpp_nape.util.ZNPList_ZPP_FluidArbiter"/></f_arbiters>
		<c_arbiters_false public="1"><c path="zpp_nape.util.ZNPList_ZPP_ColArbiter"/></c_arbiters_false>
		<c_arbiters_true public="1"><c path="zpp_nape.util.ZNPList_ZPP_ColArbiter"/></c_arbiters_true>
		<sortcontacts public="1"><x path="Bool"/></sortcontacts>
		<time public="1"><x path="Float"/></time>
		<midstep public="1"><x path="Bool"/></midstep>
		<stamp public="1"><x path="Int"/></stamp>
		<global_ang_drag public="1"><x path="Float"/></global_ang_drag>
		<global_lin_drag public="1"><x path="Float"/></global_lin_drag>
		<__static public="1"><c path="nape.phys.Body"/></__static>
		<bphase public="1"><c path="zpp_nape.space.ZPP_Broadphase"/></bphase>
		<kinematics public="1"><c path="zpp_nape.util.ZNPList_ZPP_Body"/></kinematics>
		<wrap_constraints public="1"><c path="nape.constraint.ConstraintList"/></wrap_constraints>
		<constraints public="1"><c path="zpp_nape.util.ZNPList_ZPP_Constraint"/></constraints>
		<wrap_compounds public="1"><c path="nape.phys.CompoundList"/></wrap_compounds>
		<compounds public="1"><c path="zpp_nape.util.ZNPList_ZPP_Compound"/></compounds>
		<wrap_bodies public="1"><c path="nape.phys.BodyList"/></wrap_bodies>
		<bodies public="1"><c path="zpp_nape.util.ZNPList_ZPP_Body"/></bodies>
		<gravity_validate set="method" line="1502"><f a=""><x path="Void"/></f></gravity_validate>
		<gravity_invalidate set="method" line="1391"><f a="x">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Void"/>
</f></gravity_invalidate>
		<getgravity public="1" set="method" line="1385"><f a=""><x path="Void"/></f></getgravity>
		<wrap_gravity public="1"><c path="nape.geom.Vec2"/></wrap_gravity>
		<gravityy public="1"><x path="Float"/></gravityy>
		<gravityx public="1"><x path="Float"/></gravityx>
		<userData public="1"><d><d/></d></userData>
		<outer public="1"><c path="nape.space.Space"/></outer>
		<new public="1" set="method" line="1888"><f a="gravity:broadphase">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<c path="nape.space.Broadphase"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.space.ZPP_SweepData" params="" file="libSrc/napeLib/zpp_nape/space/SweepPhase.hx" module="zpp_nape.space.SweepPhase">
		<zpp_pool public="1" line="176" static="1"><c path="zpp_nape.space.ZPP_SweepData"/></zpp_pool>
		<gt public="1" get="inline" set="null" line="216"><f a="x">
	<c path="zpp_nape.space.ZPP_SweepData"/>
	<x path="Bool"/>
</f></gt>
		<alloc public="1" get="inline" set="null" line="212"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="205"><f a=""><x path="Void"/></f></free>
		<aabb public="1"><c path="zpp_nape.geom.ZPP_AABB"/></aabb>
		<shape public="1"><c path="zpp_nape.shape.ZPP_Shape"/></shape>
		<prev public="1"><c path="zpp_nape.space.ZPP_SweepData"/></prev>
		<next public="1"><c path="zpp_nape.space.ZPP_SweepData"/></next>
		<new public="1" set="method" line="213"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.space.ZPP_SweepPhase" params="" file="libSrc/napeLib/zpp_nape/space/SweepPhase.hx" module="zpp_nape.space.SweepPhase">
		<extends path="zpp_nape.space.ZPP_Broadphase"/>
		<rayMultiCast public="1" set="method" line="745" override="1"><f a="ray:inner:filter:output">
	<c path="zpp_nape.geom.ZPP_Ray"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.geom.RayResultList"/>
	<c path="nape.geom.RayResultList"/>
</f></rayMultiCast>
		<rayCast public="1" set="method" line="657" override="1"><f a="ray:inner:filter">
	<c path="zpp_nape.geom.ZPP_Ray"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.geom.RayResult"/>
</f></rayCast>
		<bodiesInShape public="1" set="method" line="624" override="1"><f a="shape:containment:filter:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInShape>
		<shapesInShape public="1" set="method" line="603" override="1"><f a="shape:containment:filter:output">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInShape>
		<bodiesInCircle public="1" set="method" line="570" override="1"><f a="x:y:r:containment:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInCircle>
		<shapesInCircle public="1" set="method" line="549" override="1"><f a="x:y:r:containment:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInCircle>
		<bodiesInAABB public="1" set="method" line="499" override="1"><f a="aabb:strict:containment:filter:output">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesInAABB>
		<failed public="1"><c path="nape.phys.BodyList"/></failed>
		<shapesInAABB public="1" set="method" line="471" override="1"><f a="aabb:strict:containment:filter:output">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesInAABB>
		<bodiesUnderPoint public="1" set="method" line="429" override="1"><f a="x:y:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.phys.BodyList"/>
	<c path="nape.phys.BodyList"/>
</f></bodiesUnderPoint>
		<shapesUnderPoint public="1" set="method" line="390" override="1"><f a="x:y:filter:output">
	<x path="Float"/>
	<x path="Float"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionFilter"/>
	<c path="nape.shape.ShapeList"/>
	<c path="nape.shape.ShapeList"/>
</f></shapesUnderPoint>
		<clear public="1" set="method" line="384" override="1"><f a=""><x path="Void"/></f></clear>
		<broadphase public="1" set="method" line="345" override="1"><f a="space:discrete">
	<c path="zpp_nape.space.ZPP_Space"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></broadphase>
		<sync_broadphase_fast public="1" get="inline" set="null" line="313"><f a=""><x path="Void"/></f></sync_broadphase_fast>
		<sync_broadphase public="1" set="method" line="307"><f a=""><x path="Void"/></f></sync_broadphase>
		<__sync public="1" get="inline" set="null" line="296"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></__sync>
		<__remove public="1" set="method" line="262"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></__remove>
		<__insert public="1" set="method" line="228"><f a="shape">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></__insert>
		<list public="1"><c path="zpp_nape.space.ZPP_SweepData"/></list>
		<new public="1" set="method" line="223"><f a="space">
	<c path="zpp_nape.space.ZPP_Space"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.util.ZNPArray2_Float" params="" file="libSrc/napeLib/zpp_nape/util/Array2.hx" module="zpp_nape.util.Array2">
		<set public="1" get="inline" set="null" line="222"><f a="x:y:obj">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set>
		<get public="1" get="inline" set="null" line="209"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></get>
		<resize public="1" set="method" line="191"><f a="width:height:def">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></resize>
		<total public="1"><x path="Int"/></total>
		<width public="1"><x path="Int"/></width>
		<list public="1"><t path="nape.TArray"><x path="Float"/></t></list>
		<new public="1" set="method" line="182"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.util.ZNPArray2_ZPP_GeomVert" params="" file="libSrc/napeLib/zpp_nape/util/Array2.hx" module="zpp_nape.util.Array2">
		<set public="1" get="inline" set="null" line="282"><f a="x:y:obj">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></set>
		<get public="1" get="inline" set="null" line="269"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></get>
		<resize public="1" set="method" line="251"><f a="width:height:def">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Void"/>
</f></resize>
		<total public="1"><x path="Int"/></total>
		<width public="1"><x path="Int"/></width>
		<list public="1"><t path="nape.TArray"><c path="zpp_nape.geom.ZPP_GeomVert"/></t></list>
		<new public="1" set="method" line="242"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.util.ZNPArray2_ZPP_MarchPair" params="" file="libSrc/napeLib/zpp_nape/util/Array2.hx" module="zpp_nape.util.Array2">
		<set public="1" get="inline" set="null" line="342"><f a="x:y:obj">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
</f></set>
		<get public="1" get="inline" set="null" line="329"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
</f></get>
		<resize public="1" set="method" line="311"><f a="width:height:def">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_MarchPair"/>
	<x path="Void"/>
</f></resize>
		<total public="1"><x path="Int"/></total>
		<width public="1"><x path="Int"/></width>
		<list public="1"><t path="nape.TArray"><c path="zpp_nape.geom.ZPP_MarchPair"/></t></list>
		<new public="1" set="method" line="302"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Debug" params="" file="libSrc/napeLib/zpp_nape/util/Debug.hx" module="zpp_nape.util.Debug">
		<internal public="1" line="175" static="1"><x path="Bool"/></internal>
		<sup_setbg public="1" set="method" line="422"><f a="bgcol">
	<x path="Int"/>
	<x path="Void"/>
</f></sup_setbg>
		<cull public="1" set="method" line="270"><f a="aabb">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Bool"/>
</f></cull>
		<tmpab public="1"><c path="zpp_nape.geom.ZPP_AABB"/></tmpab>
		<setform public="1" set="method" line="265"><f a=""><x path="Void"/></f></setform>
		<xform_invalidate set="method" line="201"><f a=""><x path="Void"/></f></xform_invalidate>
		<iport public="1"><c path="zpp_nape.geom.ZPP_AABB"/></iport>
		<viewport public="1"><c path="zpp_nape.geom.ZPP_AABB"/></viewport>
		<height public="1"><x path="Int"/></height>
		<width public="1"><x path="Int"/></width>
		<xdet public="1"><x path="Float"/></xdet>
		<xnull public="1"><x path="Bool"/></xnull>
		<xform public="1"><c path="zpp_nape.geom.ZPP_Mat23"/></xform>
		<bg_col public="1"><x path="Int"/></bg_col>
		<bg_b public="1"><x path="Float"/></bg_b>
		<bg_g public="1"><x path="Float"/></bg_g>
		<bg_r public="1"><x path="Float"/></bg_r>
		<d_shape public="1"><c path="zpp_nape.util.ZPP_ShapeDebug"/></d_shape>
		<d_bmp public="1"><c path="zpp_nape.util.ZPP_BitmapDebug"/></d_bmp>
		<isbmp public="1"><x path="Bool"/></isbmp>
		<outer public="1"><c path="nape.util.Debug"/></outer>
		<new public="1" set="method" line="192"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.util.ZPP_ShapeDebug" params="" file="libSrc/napeLib/zpp_nape/util/Debug.hx" module="zpp_nape.util.Debug">
		<extends path="zpp_nape.util.ZPP_Debug"/>
		<draw_arbiter public="1" set="method" line="1032"><f a="arb:xform:xdet:xnull">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<c path="zpp_nape.geom.ZPP_Mat23"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></draw_arbiter>
		<draw_shape public="1" set="method" line="774"><f a="shape:xform:xdet:xnull">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.geom.ZPP_Mat23"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></draw_shape>
		<draw_body public="1" set="method" line="572"><f a="body:xform:xdet:xnull">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.geom.ZPP_Mat23"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></draw_body>
		<draw_space public="1" set="method" line="473"><f a="space:xform:xdet:xnull">
	<c path="zpp_nape.space.ZPP_Space"/>
	<c path="zpp_nape.geom.ZPP_Mat23"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></draw_space>
		<bodyList><c path="nape.phys.BodyList"/></bodyList>
		<shapeList><c path="nape.shape.ShapeList"/></shapeList>
		<draw_compound public="1" set="method" line="445"><f a="compound:xform:xdet:xnull">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<c path="zpp_nape.geom.ZPP_Mat23"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></draw_compound>
		<compoundstack public="1"><c path="zpp_nape.util.ZNPList_ZPP_Compound"/></compoundstack>
		<setbg public="1" set="method" line="441"><f a="bgColor">
	<x path="Int"/>
	<x path="Void"/>
</f></setbg>
		<graphics public="1"><c path="flash.display.Graphics"/></graphics>
		<shape public="1"><c path="flash.display.Shape"/></shape>
		<outer_zn public="1"><c path="nape.util.ShapeDebug"/></outer_zn>
		<new public="1" set="method" line="434"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.util.ZPP_BitmapDebug" params="" file="libSrc/napeLib/zpp_nape/util/Debug.hx" module="zpp_nape.util.Debug">
		<extends path="zpp_nape.util.ZPP_Debug"/>
		<__aabb public="1" set="method" line="2937"><f a="aabb:col">
	<c path="zpp_nape.geom.ZPP_AABB"/>
	<x path="Int"/>
	<x path="Void"/>
</f></__aabb>
		<__box public="1" set="method" line="2930"><f a="x0:y0:x1:y1:col">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></__box>
		<draw_arbiter public="1" set="method" line="2527"><f a="arb:xform:xdet:xnull">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<c path="zpp_nape.geom.ZPP_Mat23"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></draw_arbiter>
		<draw_shape public="1" set="method" line="2196"><f a="shape:xform:xdet:xnull">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.geom.ZPP_Mat23"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></draw_shape>
		<draw_body public="1" set="method" line="1947"><f a="body:xform:xdet:xnull">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.geom.ZPP_Mat23"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></draw_body>
		<draw_space public="1" set="method" line="1848"><f a="space:xform:xdet:xnull">
	<c path="zpp_nape.space.ZPP_Space"/>
	<c path="zpp_nape.geom.ZPP_Mat23"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></draw_space>
		<bodyList><c path="nape.phys.BodyList"/></bodyList>
		<shapeList><c path="nape.shape.ShapeList"/></shapeList>
		<draw_compound public="1" set="method" line="1820"><f a="compound:xform:xdet:xnull">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<c path="zpp_nape.geom.ZPP_Mat23"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></draw_compound>
		<compoundstack public="1"><c path="zpp_nape.util.ZNPList_ZPP_Compound"/></compoundstack>
		<__round public="1" get="inline" set="null" line="1816"><f a="x">
	<x path="Float"/>
	<x path="Int"/>
</f></__round>
		<colour public="1"><x path="Int"/></colour>
		<peny public="1"><x path="Int"/></peny>
		<penx public="1"><x path="Int"/></penx>
		<__fcircle public="1" set="method" line="1780"><f a="x0:y0:radius:col">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></__fcircle>
		<__circle public="1" set="method" line="1748"><f a="x0:y0:radius:col">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></__circle>
		<__tri public="1" set="method" line="1600"><f a="p0:p1:p2:col">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Int"/>
	<x path="Void"/>
</f></__tri>
		<__curve public="1" set="method" line="1551"><f a="u:v:q:col">
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<c path="nape.geom.Vec2"/>
	<x path="Int"/>
	<x path="Void"/>
</f></__curve>
		<__line public="1" set="method" line="1459"><f a="x0:y0:x1:y1:col">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></__line>
		<setpixel public="1" get="inline" set="null" line="1456"><f a="x:y:col">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setpixel>
		<setpix public="1" get="inline" set="null" line="1451"><f a="ind:col">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setpix>
		<index public="1" get="inline" set="null" line="1446"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></index>
		<flush public="1" set="method" line="1438"><f a=""><x path="Void"/></f></flush>
		<prepare public="1" set="method" line="1435"><f a=""><x path="Void"/></f></prepare>
		<clear public="1" set="method" line="1430"><f a=""><x path="Void"/></f></clear>
		<setbg public="1" set="method" line="1398"><f a="bgColor">
	<x path="Int"/>
	<x path="Void"/>
</f></setbg>
		<filledXs public="1"><c path="Array"><x path="Int"/></c></filledXs>
		<filledVertices public="1"><c path="Array"><c path="nape.geom.Vec2"/></c></filledVertices>
		<transp public="1"><x path="Bool"/></transp>
		<bgbytes public="1"><c path="flash.utils.ByteArray"/></bgbytes>
		<bytes public="1"><c path="flash.utils.ByteArray"/></bytes>
		<bit public="1"><c path="flash.display.BitmapData"/></bit>
		<rect public="1"><c path="flash.geom.Rectangle"/></rect>
		<bitmap public="1"><c path="flash.display.Bitmap"/></bitmap>
		<outer_zn public="1"><c path="nape.util.BitmapDebug"/></outer_zn>
		<new public="1" set="method" line="1407"><f a="w:h:bgcol:transparent">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="zpp_nape.util.Hashable2_Boolfalse" params="" file="libSrc/napeLib/zpp_nape/util/FastHash.hx" module="zpp_nape.util.FastHash">
		<zpp_pool public="1" line="179" static="1"><c path="zpp_nape.util.Hashable2_Boolfalse"/></zpp_pool>
		<get public="1" get="inline" set="null" line="214" static="1"><f a="id:di:val">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
</f></get>
		<getpersist public="1" get="inline" set="null" line="220" static="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
</f></getpersist>
		<ordered_get public="1" get="inline" set="null" line="244" static="1"><f a="id:di:val">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
</f></ordered_get>
		<ordered_get_persist public="1" get="inline" set="null" line="248" static="1"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
</f></ordered_get_persist>
		<alloc public="1" get="inline" set="null" line="211"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="208"><f a=""><x path="Void"/></f></free>
		<di public="1"><x path="Int"/></di>
		<id public="1"><x path="Int"/></id>
		<hnext public="1"><c path="zpp_nape.util.Hashable2_Boolfalse"/></hnext>
		<next public="1"><c path="zpp_nape.util.Hashable2_Boolfalse"/></next>
		<value public="1"><x path="Bool"/></value>
		<new set="method" line="212"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.FastHash2_Hashable2_Boolfalse" params="" file="libSrc/napeLib/zpp_nape/util/FastHash.hx" module="zpp_nape.util.FastHash">
		<hash public="1" get="inline" set="null" line="416"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></hash>
		<remove public="1" set="method" line="382"><f a="arb">
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
	<x path="Void"/>
</f></remove>
		<add public="1" set="method" line="350"><f a="arb">
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
	<x path="Void"/>
</f></add>
		<maybeAdd public="1" set="method" line="316"><f a="arb">
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
	<x path="Void"/>
</f></maybeAdd>
		<has public="1" set="method" line="307"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></has>
		<ordered_get public="1" get="inline" set="null" line="299"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<t path="Null"><c path="zpp_nape.util.Hashable2_Boolfalse"/></t>
</f></ordered_get>
		<get public="1" get="inline" set="null" line="288"><f a="id:di">
	<x path="Int"/>
	<x path="Int"/>
	<c path="zpp_nape.util.Hashable2_Boolfalse"/>
</f></get>
		<clear public="1" set="method" line="271"><f a=""><x path="Void"/></f></clear>
		<empty public="1" get="inline" set="null" line="268"><f a=""><x path="Bool"/></f></empty>
		<cnt public="1"><x path="Int"/></cnt>
		<table public="1"><t path="nape.TArray"><c path="zpp_nape.util.Hashable2_Boolfalse"/></t></table>
		<new public="1" set="method" line="259"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Flags" params="" file="libSrc/napeLib/zpp_nape/util/Flags.hx" module="zpp_nape.util.Flags">
		<internal public="1" line="175" static="1"><x path="Bool"/></internal>
		<id_ImmState_ACCEPT public="1" line="177" static="1"><x path="Int"/></id_ImmState_ACCEPT>
		<id_ImmState_IGNORE public="1" line="178" static="1"><x path="Int"/></id_ImmState_IGNORE>
		<id_ImmState_ALWAYS public="1" line="179" static="1"><x path="Int"/></id_ImmState_ALWAYS>
		<id_GravMassMode_DEFAULT public="1" line="180" static="1"><x path="Int"/></id_GravMassMode_DEFAULT>
		<id_GravMassMode_FIXED public="1" line="181" static="1"><x path="Int"/></id_GravMassMode_FIXED>
		<id_GravMassMode_SCALED public="1" line="182" static="1"><x path="Int"/></id_GravMassMode_SCALED>
		<id_InertiaMode_DEFAULT public="1" line="183" static="1"><x path="Int"/></id_InertiaMode_DEFAULT>
		<id_InertiaMode_FIXED public="1" line="184" static="1"><x path="Int"/></id_InertiaMode_FIXED>
		<id_MassMode_DEFAULT public="1" line="185" static="1"><x path="Int"/></id_MassMode_DEFAULT>
		<id_MassMode_FIXED public="1" line="186" static="1"><x path="Int"/></id_MassMode_FIXED>
		<id_BodyType_STATIC public="1" line="187" static="1"><x path="Int"/></id_BodyType_STATIC>
		<id_BodyType_DYNAMIC public="1" line="188" static="1"><x path="Int"/></id_BodyType_DYNAMIC>
		<id_BodyType_KINEMATIC public="1" line="189" static="1"><x path="Int"/></id_BodyType_KINEMATIC>
		<id_ListenerType_BODY public="1" line="190" static="1"><x path="Int"/></id_ListenerType_BODY>
		<id_ListenerType_CONSTRAINT public="1" line="191" static="1"><x path="Int"/></id_ListenerType_CONSTRAINT>
		<id_ListenerType_INTERACTION public="1" line="192" static="1"><x path="Int"/></id_ListenerType_INTERACTION>
		<id_ListenerType_PRE public="1" line="193" static="1"><x path="Int"/></id_ListenerType_PRE>
		<id_PreFlag_ACCEPT public="1" line="194" static="1"><x path="Int"/></id_PreFlag_ACCEPT>
		<id_PreFlag_IGNORE public="1" line="195" static="1"><x path="Int"/></id_PreFlag_IGNORE>
		<id_PreFlag_ACCEPT_ONCE public="1" line="196" static="1"><x path="Int"/></id_PreFlag_ACCEPT_ONCE>
		<id_PreFlag_IGNORE_ONCE public="1" line="197" static="1"><x path="Int"/></id_PreFlag_IGNORE_ONCE>
		<id_CbEvent_BEGIN public="1" line="198" static="1"><x path="Int"/></id_CbEvent_BEGIN>
		<id_CbEvent_ONGOING public="1" line="199" static="1"><x path="Int"/></id_CbEvent_ONGOING>
		<id_CbEvent_END public="1" line="200" static="1"><x path="Int"/></id_CbEvent_END>
		<id_CbEvent_WAKE public="1" line="201" static="1"><x path="Int"/></id_CbEvent_WAKE>
		<id_CbEvent_SLEEP public="1" line="202" static="1"><x path="Int"/></id_CbEvent_SLEEP>
		<id_CbEvent_BREAK public="1" line="203" static="1"><x path="Int"/></id_CbEvent_BREAK>
		<id_CbEvent_PRE public="1" line="204" static="1"><x path="Int"/></id_CbEvent_PRE>
		<id_InteractionType_COLLISION public="1" line="205" static="1"><x path="Int"/></id_InteractionType_COLLISION>
		<id_InteractionType_SENSOR public="1" line="206" static="1"><x path="Int"/></id_InteractionType_SENSOR>
		<id_InteractionType_FLUID public="1" line="207" static="1"><x path="Int"/></id_InteractionType_FLUID>
		<id_InteractionType_ANY public="1" line="208" static="1"><x path="Int"/></id_InteractionType_ANY>
		<id_Winding_UNDEFINED public="1" line="209" static="1"><x path="Int"/></id_Winding_UNDEFINED>
		<id_Winding_CLOCKWISE public="1" line="210" static="1"><x path="Int"/></id_Winding_CLOCKWISE>
		<id_Winding_ANTICLOCKWISE public="1" line="211" static="1"><x path="Int"/></id_Winding_ANTICLOCKWISE>
		<id_ValidationResult_VALID public="1" line="212" static="1"><x path="Int"/></id_ValidationResult_VALID>
		<id_ValidationResult_DEGENERATE public="1" line="213" static="1"><x path="Int"/></id_ValidationResult_DEGENERATE>
		<id_ValidationResult_CONCAVE public="1" line="214" static="1"><x path="Int"/></id_ValidationResult_CONCAVE>
		<id_ValidationResult_SELF_INTERSECTING public="1" line="215" static="1"><x path="Int"/></id_ValidationResult_SELF_INTERSECTING>
		<id_ShapeType_CIRCLE public="1" line="216" static="1"><x path="Int"/></id_ShapeType_CIRCLE>
		<id_ShapeType_POLYGON public="1" line="217" static="1"><x path="Int"/></id_ShapeType_POLYGON>
		<id_Broadphase_DYNAMIC_AABB_TREE public="1" line="218" static="1"><x path="Int"/></id_Broadphase_DYNAMIC_AABB_TREE>
		<id_Broadphase_SWEEP_AND_PRUNE public="1" line="219" static="1"><x path="Int"/></id_Broadphase_SWEEP_AND_PRUNE>
		<id_ArbiterType_COLLISION public="1" line="220" static="1"><x path="Int"/></id_ArbiterType_COLLISION>
		<id_ArbiterType_SENSOR public="1" line="221" static="1"><x path="Int"/></id_ArbiterType_SENSOR>
		<id_ArbiterType_FLUID public="1" line="222" static="1"><x path="Int"/></id_ArbiterType_FLUID>
		<GravMassMode_DEFAULT public="1" static="1"><c path="nape.phys.GravMassMode"/></GravMassMode_DEFAULT>
		<GravMassMode_FIXED public="1" static="1"><c path="nape.phys.GravMassMode"/></GravMassMode_FIXED>
		<GravMassMode_SCALED public="1" static="1"><c path="nape.phys.GravMassMode"/></GravMassMode_SCALED>
		<InertiaMode_DEFAULT public="1" static="1"><c path="nape.phys.InertiaMode"/></InertiaMode_DEFAULT>
		<InertiaMode_FIXED public="1" static="1"><c path="nape.phys.InertiaMode"/></InertiaMode_FIXED>
		<MassMode_DEFAULT public="1" static="1"><c path="nape.phys.MassMode"/></MassMode_DEFAULT>
		<MassMode_FIXED public="1" static="1"><c path="nape.phys.MassMode"/></MassMode_FIXED>
		<BodyType_STATIC public="1" static="1"><c path="nape.phys.BodyType"/></BodyType_STATIC>
		<BodyType_DYNAMIC public="1" static="1"><c path="nape.phys.BodyType"/></BodyType_DYNAMIC>
		<BodyType_KINEMATIC public="1" static="1"><c path="nape.phys.BodyType"/></BodyType_KINEMATIC>
		<ListenerType_BODY public="1" static="1"><c path="nape.callbacks.ListenerType"/></ListenerType_BODY>
		<ListenerType_CONSTRAINT public="1" static="1"><c path="nape.callbacks.ListenerType"/></ListenerType_CONSTRAINT>
		<ListenerType_INTERACTION public="1" static="1"><c path="nape.callbacks.ListenerType"/></ListenerType_INTERACTION>
		<ListenerType_PRE public="1" static="1"><c path="nape.callbacks.ListenerType"/></ListenerType_PRE>
		<PreFlag_ACCEPT public="1" static="1"><c path="nape.callbacks.PreFlag"/></PreFlag_ACCEPT>
		<PreFlag_IGNORE public="1" static="1"><c path="nape.callbacks.PreFlag"/></PreFlag_IGNORE>
		<PreFlag_ACCEPT_ONCE public="1" static="1"><c path="nape.callbacks.PreFlag"/></PreFlag_ACCEPT_ONCE>
		<PreFlag_IGNORE_ONCE public="1" static="1"><c path="nape.callbacks.PreFlag"/></PreFlag_IGNORE_ONCE>
		<CbEvent_BEGIN public="1" static="1"><c path="nape.callbacks.CbEvent"/></CbEvent_BEGIN>
		<CbEvent_ONGOING public="1" static="1"><c path="nape.callbacks.CbEvent"/></CbEvent_ONGOING>
		<CbEvent_END public="1" static="1"><c path="nape.callbacks.CbEvent"/></CbEvent_END>
		<CbEvent_WAKE public="1" static="1"><c path="nape.callbacks.CbEvent"/></CbEvent_WAKE>
		<CbEvent_SLEEP public="1" static="1"><c path="nape.callbacks.CbEvent"/></CbEvent_SLEEP>
		<CbEvent_BREAK public="1" static="1"><c path="nape.callbacks.CbEvent"/></CbEvent_BREAK>
		<CbEvent_PRE public="1" static="1"><c path="nape.callbacks.CbEvent"/></CbEvent_PRE>
		<InteractionType_COLLISION public="1" static="1"><c path="nape.callbacks.InteractionType"/></InteractionType_COLLISION>
		<InteractionType_SENSOR public="1" static="1"><c path="nape.callbacks.InteractionType"/></InteractionType_SENSOR>
		<InteractionType_FLUID public="1" static="1"><c path="nape.callbacks.InteractionType"/></InteractionType_FLUID>
		<InteractionType_ANY public="1" static="1"><c path="nape.callbacks.InteractionType"/></InteractionType_ANY>
		<Winding_UNDEFINED public="1" static="1"><c path="nape.geom.Winding"/></Winding_UNDEFINED>
		<Winding_CLOCKWISE public="1" static="1"><c path="nape.geom.Winding"/></Winding_CLOCKWISE>
		<Winding_ANTICLOCKWISE public="1" static="1"><c path="nape.geom.Winding"/></Winding_ANTICLOCKWISE>
		<ValidationResult_VALID public="1" static="1"><c path="nape.shape.ValidationResult"/></ValidationResult_VALID>
		<ValidationResult_DEGENERATE public="1" static="1"><c path="nape.shape.ValidationResult"/></ValidationResult_DEGENERATE>
		<ValidationResult_CONCAVE public="1" static="1"><c path="nape.shape.ValidationResult"/></ValidationResult_CONCAVE>
		<ValidationResult_SELF_INTERSECTING public="1" static="1"><c path="nape.shape.ValidationResult"/></ValidationResult_SELF_INTERSECTING>
		<ShapeType_CIRCLE public="1" static="1"><c path="nape.shape.ShapeType"/></ShapeType_CIRCLE>
		<ShapeType_POLYGON public="1" static="1"><c path="nape.shape.ShapeType"/></ShapeType_POLYGON>
		<Broadphase_DYNAMIC_AABB_TREE public="1" static="1"><c path="nape.space.Broadphase"/></Broadphase_DYNAMIC_AABB_TREE>
		<Broadphase_SWEEP_AND_PRUNE public="1" static="1"><c path="nape.space.Broadphase"/></Broadphase_SWEEP_AND_PRUNE>
		<ArbiterType_COLLISION public="1" static="1"><c path="nape.dynamics.ArbiterType"/></ArbiterType_COLLISION>
		<ArbiterType_SENSOR public="1" static="1"><c path="nape.dynamics.ArbiterType"/></ArbiterType_SENSOR>
		<ArbiterType_FLUID public="1" static="1"><c path="nape.dynamics.ArbiterType"/></ArbiterType_FLUID>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_CallbackSet" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="995"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></at>
		<iterator_at public="1" set="method" line="982"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
</f></iterator_at>
		<back public="1" set="method" line="973"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></back>
		<front public="1" get="inline" set="null" line="970"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="940"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="935"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="932"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="927"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="912"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="906"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="901"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="897"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="851"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
</f></inlined_erase>
		<erase public="1" set="method" line="846"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="823"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="810"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="785"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="774"><f a="obj">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="761"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="756"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="723"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="718"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="675"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
</f></inlined_insert>
		<insert public="1" set="method" line="670"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
</f></insert>
		<addAll public="1" set="method" line="652"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_CallbackSet"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="615"><f a="o">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></inlined_add>
		<add public="1" set="method" line="610"><f a="o">
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
	<c path="zpp_nape.space.ZPP_CallbackSet"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="605"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="597"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/></head>
		<new public="1" set="method" line="594"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Shape" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="1412"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
</f></at>
		<iterator_at public="1" set="method" line="1399"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
</f></iterator_at>
		<back public="1" set="method" line="1390"><f a=""><c path="zpp_nape.shape.ZPP_Shape"/></f></back>
		<front public="1" get="inline" set="null" line="1387"><f a=""><c path="zpp_nape.shape.ZPP_Shape"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="1357"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="1352"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="1349"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="1344"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="1329"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="1323"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="1318"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="1314"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="1268"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
</f></inlined_erase>
		<erase public="1" set="method" line="1263"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="1240"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="1227"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="1202"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="1191"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="1178"><f a=""><c path="zpp_nape.shape.ZPP_Shape"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="1173"><f a=""><c path="zpp_nape.shape.ZPP_Shape"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="1140"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="1135"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="1092"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
</f></inlined_insert>
		<insert public="1" set="method" line="1087"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
</f></insert>
		<addAll public="1" set="method" line="1069"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Shape"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="1032"><f a="o">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
</f></inlined_add>
		<add public="1" set="method" line="1027"><f a="o">
	<c path="zpp_nape.shape.ZPP_Shape"/>
	<c path="zpp_nape.shape.ZPP_Shape"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="1022"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Shape"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="1014"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Shape"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Shape"/></head>
		<new public="1" set="method" line="1011"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Body" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="1829"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
</f></at>
		<iterator_at public="1" set="method" line="1816"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
</f></iterator_at>
		<back public="1" set="method" line="1807"><f a=""><c path="zpp_nape.phys.ZPP_Body"/></f></back>
		<front public="1" get="inline" set="null" line="1804"><f a=""><c path="zpp_nape.phys.ZPP_Body"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="1774"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="1769"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="1766"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="1761"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="1746"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="1740"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="1735"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="1731"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="1685"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
</f></inlined_erase>
		<erase public="1" set="method" line="1680"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="1657"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="1644"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="1619"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="1608"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="1595"><f a=""><c path="zpp_nape.phys.ZPP_Body"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="1590"><f a=""><c path="zpp_nape.phys.ZPP_Body"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="1557"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="1552"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="1509"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
</f></inlined_insert>
		<insert public="1" set="method" line="1504"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
</f></insert>
		<addAll public="1" set="method" line="1486"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Body"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="1449"><f a="o">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
</f></inlined_add>
		<add public="1" set="method" line="1444"><f a="o">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="1439"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Body"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="1431"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Body"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Body"/></head>
		<new public="1" set="method" line="1428"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Compound" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="2663"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.phys.ZPP_Compound"/>
</f></at>
		<iterator_at public="1" set="method" line="2650"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
</f></iterator_at>
		<back public="1" set="method" line="2641"><f a=""><c path="zpp_nape.phys.ZPP_Compound"/></f></back>
		<front public="1" get="inline" set="null" line="2638"><f a=""><c path="zpp_nape.phys.ZPP_Compound"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="2608"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="2603"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="2600"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="2595"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="2580"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="2574"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="2569"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="2565"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="2519"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
</f></inlined_erase>
		<erase public="1" set="method" line="2514"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="2491"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="2478"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="2453"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="2442"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="2429"><f a=""><c path="zpp_nape.phys.ZPP_Compound"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="2424"><f a=""><c path="zpp_nape.phys.ZPP_Compound"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="2391"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="2386"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="2343"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
</f></inlined_insert>
		<insert public="1" set="method" line="2338"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
</f></insert>
		<addAll public="1" set="method" line="2320"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Compound"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="2283"><f a="o">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<c path="zpp_nape.phys.ZPP_Compound"/>
</f></inlined_add>
		<add public="1" set="method" line="2278"><f a="o">
	<c path="zpp_nape.phys.ZPP_Compound"/>
	<c path="zpp_nape.phys.ZPP_Compound"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="2273"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Compound"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="2265"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Compound"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Compound"/></head>
		<new public="1" set="method" line="2262"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Arbiter" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="3914"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
</f></at>
		<iterator_at public="1" set="method" line="3901"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
</f></iterator_at>
		<back public="1" set="method" line="3892"><f a=""><c path="zpp_nape.dynamics.ZPP_Arbiter"/></f></back>
		<front public="1" get="inline" set="null" line="3889"><f a=""><c path="zpp_nape.dynamics.ZPP_Arbiter"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="3859"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="3854"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="3851"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="3846"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="3831"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="3825"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="3820"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="3816"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="3770"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
</f></inlined_erase>
		<erase public="1" set="method" line="3765"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="3742"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="3729"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="3704"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="3693"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="3680"><f a=""><c path="zpp_nape.dynamics.ZPP_Arbiter"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="3675"><f a=""><c path="zpp_nape.dynamics.ZPP_Arbiter"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="3642"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="3637"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="3594"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
</f></inlined_insert>
		<insert public="1" set="method" line="3589"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
</f></insert>
		<addAll public="1" set="method" line="3571"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Arbiter"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="3534"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
</f></inlined_add>
		<add public="1" set="method" line="3529"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
	<c path="zpp_nape.dynamics.ZPP_Arbiter"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="3524"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="3516"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/></head>
		<new public="1" set="method" line="3513"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_CbSetPair" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="5582"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
</f></at>
		<iterator_at public="1" set="method" line="5569"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
</f></iterator_at>
		<back public="1" set="method" line="5560"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></f></back>
		<front public="1" get="inline" set="null" line="5557"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="5527"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="5522"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="5519"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="5514"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="5499"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="5493"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="5488"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="5484"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="5438"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
</f></inlined_erase>
		<erase public="1" set="method" line="5433"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="5410"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="5397"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="5372"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="5361"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="5348"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="5343"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="5310"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="5305"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="5262"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
</f></inlined_insert>
		<insert public="1" set="method" line="5257"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
</f></insert>
		<addAll public="1" set="method" line="5239"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_CbSetPair"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="5202"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
</f></inlined_add>
		<add public="1" set="method" line="5197"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="5192"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="5184"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/></head>
		<new public="1" set="method" line="5181"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_CutInt" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="5999"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_CutInt"/>
</f></at>
		<iterator_at public="1" set="method" line="5986"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
</f></iterator_at>
		<back public="1" set="method" line="5977"><f a=""><c path="zpp_nape.geom.ZPP_CutInt"/></f></back>
		<front public="1" get="inline" set="null" line="5974"><f a=""><c path="zpp_nape.geom.ZPP_CutInt"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="5944"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="5939"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="5936"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="5931"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="5916"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="5910"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="5905"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="5901"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="5855"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
</f></inlined_erase>
		<erase public="1" set="method" line="5850"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="5827"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="5814"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="5789"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="5778"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="5765"><f a=""><c path="zpp_nape.geom.ZPP_CutInt"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="5760"><f a=""><c path="zpp_nape.geom.ZPP_CutInt"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="5727"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="5722"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="5679"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
</f></inlined_insert>
		<insert public="1" set="method" line="5674"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
</f></insert>
		<addAll public="1" set="method" line="5656"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_CutInt"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="5619"><f a="o">
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<c path="zpp_nape.geom.ZPP_CutInt"/>
</f></inlined_add>
		<add public="1" set="method" line="5614"><f a="o">
	<c path="zpp_nape.geom.ZPP_CutInt"/>
	<c path="zpp_nape.geom.ZPP_CutInt"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="5609"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="5601"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/></head>
		<new public="1" set="method" line="5598"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_CutVert" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="6416"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_CutVert"/>
</f></at>
		<iterator_at public="1" set="method" line="6403"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
</f></iterator_at>
		<back public="1" set="method" line="6394"><f a=""><c path="zpp_nape.geom.ZPP_CutVert"/></f></back>
		<front public="1" get="inline" set="null" line="6391"><f a=""><c path="zpp_nape.geom.ZPP_CutVert"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="6361"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="6356"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="6353"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="6348"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="6333"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="6327"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="6322"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="6318"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="6272"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
</f></inlined_erase>
		<erase public="1" set="method" line="6267"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="6244"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="6231"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="6206"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="6195"><f a="obj">
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="6182"><f a=""><c path="zpp_nape.geom.ZPP_CutVert"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="6177"><f a=""><c path="zpp_nape.geom.ZPP_CutVert"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="6144"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="6139"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="6096"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
</f></inlined_insert>
		<insert public="1" set="method" line="6091"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
</f></insert>
		<addAll public="1" set="method" line="6073"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_CutVert"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="6036"><f a="o">
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<c path="zpp_nape.geom.ZPP_CutVert"/>
</f></inlined_add>
		<add public="1" set="method" line="6031"><f a="o">
	<c path="zpp_nape.geom.ZPP_CutVert"/>
	<c path="zpp_nape.geom.ZPP_CutVert"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="6026"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="6018"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/></head>
		<new public="1" set="method" line="6015"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_PartitionVertex" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="6833"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
</f></at>
		<iterator_at public="1" set="method" line="6820"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
</f></iterator_at>
		<back public="1" set="method" line="6811"><f a=""><c path="zpp_nape.geom.ZPP_PartitionVertex"/></f></back>
		<front public="1" get="inline" set="null" line="6808"><f a=""><c path="zpp_nape.geom.ZPP_PartitionVertex"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="6778"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="6773"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="6770"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="6765"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="6750"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="6744"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="6739"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="6735"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="6689"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
</f></inlined_erase>
		<erase public="1" set="method" line="6684"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="6661"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="6648"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="6623"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="6612"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="6599"><f a=""><c path="zpp_nape.geom.ZPP_PartitionVertex"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="6594"><f a=""><c path="zpp_nape.geom.ZPP_PartitionVertex"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="6561"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="6556"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="6513"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
</f></inlined_insert>
		<insert public="1" set="method" line="6508"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
</f></insert>
		<addAll public="1" set="method" line="6490"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="6453"><f a="o">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
</f></inlined_add>
		<add public="1" set="method" line="6448"><f a="o">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="6443"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="6435"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/></head>
		<new public="1" set="method" line="6432"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_PartitionedPoly" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="7250"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
</f></at>
		<iterator_at public="1" set="method" line="7237"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
</f></iterator_at>
		<back public="1" set="method" line="7228"><f a=""><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></f></back>
		<front public="1" get="inline" set="null" line="7225"><f a=""><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="7195"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="7190"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="7187"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="7182"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="7167"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="7161"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="7156"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="7152"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="7106"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
</f></inlined_erase>
		<erase public="1" set="method" line="7101"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="7078"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="7065"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="7040"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="7029"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="7016"><f a=""><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="7011"><f a=""><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="6978"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="6973"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="6930"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
</f></inlined_insert>
		<insert public="1" set="method" line="6925"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
</f></insert>
		<addAll public="1" set="method" line="6907"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_PartitionedPoly"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="6870"><f a="o">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
</f></inlined_add>
		<add public="1" set="method" line="6865"><f a="o">
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
	<c path="zpp_nape.geom.ZPP_PartitionedPoly"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="6860"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="6852"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/></head>
		<new public="1" set="method" line="6849"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_GeomVert" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="7667"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></at>
		<iterator_at public="1" set="method" line="7654"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
</f></iterator_at>
		<back public="1" set="method" line="7645"><f a=""><c path="zpp_nape.geom.ZPP_GeomVert"/></f></back>
		<front public="1" get="inline" set="null" line="7642"><f a=""><c path="zpp_nape.geom.ZPP_GeomVert"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="7612"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="7607"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="7604"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="7599"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="7584"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="7578"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="7573"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="7569"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="7523"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
</f></inlined_erase>
		<erase public="1" set="method" line="7518"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="7495"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="7482"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="7457"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="7446"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="7433"><f a=""><c path="zpp_nape.geom.ZPP_GeomVert"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="7428"><f a=""><c path="zpp_nape.geom.ZPP_GeomVert"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="7395"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="7390"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="7347"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
</f></inlined_insert>
		<insert public="1" set="method" line="7342"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
</f></insert>
		<addAll public="1" set="method" line="7324"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_GeomVert"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="7287"><f a="o">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></inlined_add>
		<add public="1" set="method" line="7282"><f a="o">
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
	<c path="zpp_nape.geom.ZPP_GeomVert"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="7277"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="7269"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/></head>
		<new public="1" set="method" line="7266"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_SimplifyP" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="8084"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
</f></at>
		<iterator_at public="1" set="method" line="8071"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
</f></iterator_at>
		<back public="1" set="method" line="8062"><f a=""><c path="zpp_nape.geom.ZPP_SimplifyP"/></f></back>
		<front public="1" get="inline" set="null" line="8059"><f a=""><c path="zpp_nape.geom.ZPP_SimplifyP"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="8029"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="8024"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="8021"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="8016"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="8001"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="7995"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="7990"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="7986"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="7940"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
</f></inlined_erase>
		<erase public="1" set="method" line="7935"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="7912"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="7899"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="7874"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="7863"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="7850"><f a=""><c path="zpp_nape.geom.ZPP_SimplifyP"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="7845"><f a=""><c path="zpp_nape.geom.ZPP_SimplifyP"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="7812"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="7807"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="7764"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
</f></inlined_insert>
		<insert public="1" set="method" line="7759"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
</f></insert>
		<addAll public="1" set="method" line="7741"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_SimplifyP"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="7704"><f a="o">
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
</f></inlined_add>
		<add public="1" set="method" line="7699"><f a="o">
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
	<c path="zpp_nape.geom.ZPP_SimplifyP"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="7694"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="7686"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/></head>
		<new public="1" set="method" line="7683"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_SimpleVert" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="8501"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
</f></at>
		<iterator_at public="1" set="method" line="8488"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
</f></iterator_at>
		<back public="1" set="method" line="8479"><f a=""><c path="zpp_nape.geom.ZPP_SimpleVert"/></f></back>
		<front public="1" get="inline" set="null" line="8476"><f a=""><c path="zpp_nape.geom.ZPP_SimpleVert"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="8446"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="8441"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="8438"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="8433"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="8418"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="8412"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="8407"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="8403"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="8357"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
</f></inlined_erase>
		<erase public="1" set="method" line="8352"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="8329"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="8316"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="8291"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="8280"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="8267"><f a=""><c path="zpp_nape.geom.ZPP_SimpleVert"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="8262"><f a=""><c path="zpp_nape.geom.ZPP_SimpleVert"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="8229"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="8224"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="8181"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
</f></inlined_insert>
		<insert public="1" set="method" line="8176"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
</f></insert>
		<addAll public="1" set="method" line="8158"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_SimpleVert"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="8121"><f a="o">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
</f></inlined_add>
		<add public="1" set="method" line="8116"><f a="o">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="8111"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="8103"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/></head>
		<new public="1" set="method" line="8100"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_SimpleEvent" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="8918"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
</f></at>
		<iterator_at public="1" set="method" line="8905"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
</f></iterator_at>
		<back public="1" set="method" line="8896"><f a=""><c path="zpp_nape.geom.ZPP_SimpleEvent"/></f></back>
		<front public="1" get="inline" set="null" line="8893"><f a=""><c path="zpp_nape.geom.ZPP_SimpleEvent"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="8863"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="8858"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="8855"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="8850"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="8835"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="8829"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="8824"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="8820"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="8774"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
</f></inlined_erase>
		<erase public="1" set="method" line="8769"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="8746"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="8733"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="8708"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="8697"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="8684"><f a=""><c path="zpp_nape.geom.ZPP_SimpleEvent"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="8679"><f a=""><c path="zpp_nape.geom.ZPP_SimpleEvent"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="8646"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="8641"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="8598"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
</f></inlined_insert>
		<insert public="1" set="method" line="8593"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
</f></insert>
		<addAll public="1" set="method" line="8575"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="8538"><f a="o">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
</f></inlined_add>
		<add public="1" set="method" line="8533"><f a="o">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="8528"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="8520"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/></head>
		<new public="1" set="method" line="8517"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_AABBPair" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="9752"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_AABBPair"/>
</f></at>
		<iterator_at public="1" set="method" line="9739"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
</f></iterator_at>
		<back public="1" set="method" line="9730"><f a=""><c path="zpp_nape.space.ZPP_AABBPair"/></f></back>
		<front public="1" get="inline" set="null" line="9727"><f a=""><c path="zpp_nape.space.ZPP_AABBPair"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="9697"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="9692"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="9689"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="9684"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="9669"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="9663"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="9658"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="9654"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="9608"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
</f></inlined_erase>
		<erase public="1" set="method" line="9603"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="9580"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="9567"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="9542"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="9531"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="9518"><f a=""><c path="zpp_nape.space.ZPP_AABBPair"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="9513"><f a=""><c path="zpp_nape.space.ZPP_AABBPair"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="9480"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="9475"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="9432"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
</f></inlined_insert>
		<insert public="1" set="method" line="9427"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
</f></insert>
		<addAll public="1" set="method" line="9409"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_AABBPair"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="9372"><f a="o">
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<c path="zpp_nape.space.ZPP_AABBPair"/>
</f></inlined_add>
		<add public="1" set="method" line="9367"><f a="o">
	<c path="zpp_nape.space.ZPP_AABBPair"/>
	<c path="zpp_nape.space.ZPP_AABBPair"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="9362"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="9354"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/></head>
		<new public="1" set="method" line="9351"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Edge" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="10169"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.shape.ZPP_Edge"/>
</f></at>
		<iterator_at public="1" set="method" line="10156"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
</f></iterator_at>
		<back public="1" set="method" line="10147"><f a=""><c path="zpp_nape.shape.ZPP_Edge"/></f></back>
		<front public="1" get="inline" set="null" line="10144"><f a=""><c path="zpp_nape.shape.ZPP_Edge"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="10114"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="10109"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="10106"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="10101"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="10086"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="10080"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="10075"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="10071"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="10025"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
</f></inlined_erase>
		<erase public="1" set="method" line="10020"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="9997"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="9984"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="9959"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="9948"><f a="obj">
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="9935"><f a=""><c path="zpp_nape.shape.ZPP_Edge"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="9930"><f a=""><c path="zpp_nape.shape.ZPP_Edge"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="9897"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="9892"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="9849"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
</f></inlined_insert>
		<insert public="1" set="method" line="9844"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
</f></insert>
		<addAll public="1" set="method" line="9826"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Edge"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="9789"><f a="o">
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<c path="zpp_nape.shape.ZPP_Edge"/>
</f></inlined_add>
		<add public="1" set="method" line="9784"><f a="o">
	<c path="zpp_nape.shape.ZPP_Edge"/>
	<c path="zpp_nape.shape.ZPP_Edge"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="9779"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Edge"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="9771"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Edge"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Edge"/></head>
		<new public="1" set="method" line="9768"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_AABBNode" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="10586"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_AABBNode"/>
</f></at>
		<iterator_at public="1" set="method" line="10573"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
</f></iterator_at>
		<back public="1" set="method" line="10564"><f a=""><c path="zpp_nape.space.ZPP_AABBNode"/></f></back>
		<front public="1" get="inline" set="null" line="10561"><f a=""><c path="zpp_nape.space.ZPP_AABBNode"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="10531"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="10526"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="10523"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="10518"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="10503"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="10497"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="10492"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="10488"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="10442"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
</f></inlined_erase>
		<erase public="1" set="method" line="10437"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="10414"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="10401"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="10376"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="10365"><f a="obj">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="10352"><f a=""><c path="zpp_nape.space.ZPP_AABBNode"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="10347"><f a=""><c path="zpp_nape.space.ZPP_AABBNode"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="10314"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="10309"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="10266"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
</f></inlined_insert>
		<insert public="1" set="method" line="10261"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
</f></insert>
		<addAll public="1" set="method" line="10243"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_AABBNode"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="10206"><f a="o">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<c path="zpp_nape.space.ZPP_AABBNode"/>
</f></inlined_add>
		<add public="1" set="method" line="10201"><f a="o">
	<c path="zpp_nape.space.ZPP_AABBNode"/>
	<c path="zpp_nape.space.ZPP_AABBNode"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="10196"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="10188"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/></head>
		<new public="1" set="method" line="10185"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Component" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="11003"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.space.ZPP_Component"/>
</f></at>
		<iterator_at public="1" set="method" line="10990"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
</f></iterator_at>
		<back public="1" set="method" line="10981"><f a=""><c path="zpp_nape.space.ZPP_Component"/></f></back>
		<front public="1" get="inline" set="null" line="10978"><f a=""><c path="zpp_nape.space.ZPP_Component"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="10948"><f a="obj">
	<c path="zpp_nape.space.ZPP_Component"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="10943"><f a="obj">
	<c path="zpp_nape.space.ZPP_Component"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="10940"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="10935"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="10920"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="10914"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="10909"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="10905"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="10859"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
</f></inlined_erase>
		<erase public="1" set="method" line="10854"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="10831"><f a="obj">
	<c path="zpp_nape.space.ZPP_Component"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="10818"><f a="obj">
	<c path="zpp_nape.space.ZPP_Component"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="10793"><f a="obj">
	<c path="zpp_nape.space.ZPP_Component"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="10782"><f a="obj">
	<c path="zpp_nape.space.ZPP_Component"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="10769"><f a=""><c path="zpp_nape.space.ZPP_Component"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="10764"><f a=""><c path="zpp_nape.space.ZPP_Component"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="10731"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="10726"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="10683"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
	<c path="zpp_nape.space.ZPP_Component"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
</f></inlined_insert>
		<insert public="1" set="method" line="10678"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
	<c path="zpp_nape.space.ZPP_Component"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
</f></insert>
		<addAll public="1" set="method" line="10660"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Component"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="10623"><f a="o">
	<c path="zpp_nape.space.ZPP_Component"/>
	<c path="zpp_nape.space.ZPP_Component"/>
</f></inlined_add>
		<add public="1" set="method" line="10618"><f a="o">
	<c path="zpp_nape.space.ZPP_Component"/>
	<c path="zpp_nape.space.ZPP_Component"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="10613"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Component"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="10605"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Component"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Component"/></head>
		<new public="1" set="method" line="10602"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_FluidArbiter" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="11420"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
</f></at>
		<iterator_at public="1" set="method" line="11407"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
</f></iterator_at>
		<back public="1" set="method" line="11398"><f a=""><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></f></back>
		<front public="1" get="inline" set="null" line="11395"><f a=""><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="11365"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="11360"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="11357"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="11352"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="11337"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="11331"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="11326"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="11322"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="11276"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
</f></inlined_erase>
		<erase public="1" set="method" line="11271"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="11248"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="11235"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="11210"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="11199"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="11186"><f a=""><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="11181"><f a=""><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="11148"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="11143"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="11100"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
</f></inlined_insert>
		<insert public="1" set="method" line="11095"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
</f></insert>
		<addAll public="1" set="method" line="11077"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_FluidArbiter"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="11040"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
</f></inlined_add>
		<add public="1" set="method" line="11035"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_FluidArbiter"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="11030"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="11022"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/></head>
		<new public="1" set="method" line="11019"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_SensorArbiter" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="11837"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
</f></at>
		<iterator_at public="1" set="method" line="11824"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
</f></iterator_at>
		<back public="1" set="method" line="11815"><f a=""><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></f></back>
		<front public="1" get="inline" set="null" line="11812"><f a=""><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="11782"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="11777"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="11774"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="11769"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="11754"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="11748"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="11743"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="11739"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="11693"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
</f></inlined_erase>
		<erase public="1" set="method" line="11688"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="11665"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="11652"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="11627"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="11616"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="11603"><f a=""><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="11598"><f a=""><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="11565"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="11560"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="11517"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
</f></inlined_insert>
		<insert public="1" set="method" line="11512"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
</f></insert>
		<addAll public="1" set="method" line="11494"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_SensorArbiter"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="11457"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
</f></inlined_add>
		<add public="1" set="method" line="11452"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_SensorArbiter"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="11447"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="11439"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/></head>
		<new public="1" set="method" line="11436"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_Listener" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="12254"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
</f></at>
		<iterator_at public="1" set="method" line="12241"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
</f></iterator_at>
		<back public="1" set="method" line="12232"><f a=""><c path="zpp_nape.callbacks.ZPP_Listener"/></f></back>
		<front public="1" get="inline" set="null" line="12229"><f a=""><c path="zpp_nape.callbacks.ZPP_Listener"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="12199"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="12194"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="12191"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="12186"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="12171"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="12165"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="12160"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="12156"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="12110"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
</f></inlined_erase>
		<erase public="1" set="method" line="12105"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="12082"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="12069"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="12044"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="12033"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="12020"><f a=""><c path="zpp_nape.callbacks.ZPP_Listener"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="12015"><f a=""><c path="zpp_nape.callbacks.ZPP_Listener"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="11982"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="11977"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="11934"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
</f></inlined_insert>
		<insert public="1" set="method" line="11929"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
</f></insert>
		<addAll public="1" set="method" line="11911"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_Listener"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="11874"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
</f></inlined_add>
		<add public="1" set="method" line="11869"><f a="o">
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
	<c path="zpp_nape.callbacks.ZPP_Listener"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="11864"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_Listener"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="11856"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_Listener"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Listener"/></head>
		<new public="1" set="method" line="11853"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_ColArbiter" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="12671"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
</f></at>
		<iterator_at public="1" set="method" line="12658"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
</f></iterator_at>
		<back public="1" set="method" line="12649"><f a=""><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></f></back>
		<front public="1" get="inline" set="null" line="12646"><f a=""><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="12616"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="12611"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="12608"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="12603"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="12588"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="12582"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="12577"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="12573"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="12527"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
</f></inlined_erase>
		<erase public="1" set="method" line="12522"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="12499"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="12486"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="12461"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="12450"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="12437"><f a=""><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="12432"><f a=""><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="12399"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="12394"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="12351"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
</f></inlined_insert>
		<insert public="1" set="method" line="12346"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
</f></insert>
		<addAll public="1" set="method" line="12328"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_ColArbiter"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="12291"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
</f></inlined_add>
		<add public="1" set="method" line="12286"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
	<c path="zpp_nape.dynamics.ZPP_ColArbiter"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="12281"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="12273"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/></head>
		<new public="1" set="method" line="12270"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_ToiEvent" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="13088"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
</f></at>
		<iterator_at public="1" set="method" line="13075"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
</f></iterator_at>
		<back public="1" set="method" line="13066"><f a=""><c path="zpp_nape.geom.ZPP_ToiEvent"/></f></back>
		<front public="1" get="inline" set="null" line="13063"><f a=""><c path="zpp_nape.geom.ZPP_ToiEvent"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="13033"><f a="obj">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="13028"><f a="obj">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="13025"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="13020"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="13005"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="12999"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="12994"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="12990"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="12944"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
</f></inlined_erase>
		<erase public="1" set="method" line="12939"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="12916"><f a="obj">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="12903"><f a="obj">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="12878"><f a="obj">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="12867"><f a="obj">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="12854"><f a=""><c path="zpp_nape.geom.ZPP_ToiEvent"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="12849"><f a=""><c path="zpp_nape.geom.ZPP_ToiEvent"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="12816"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="12811"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="12768"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
</f></inlined_insert>
		<insert public="1" set="method" line="12763"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
</f></insert>
		<addAll public="1" set="method" line="12745"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_ToiEvent"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="12708"><f a="o">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
</f></inlined_add>
		<add public="1" set="method" line="12703"><f a="o">
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
	<c path="zpp_nape.geom.ZPP_ToiEvent"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="12698"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="12690"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/></head>
		<new public="1" set="method" line="12687"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_InteractionGroup" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="13505"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
</f></at>
		<iterator_at public="1" set="method" line="13492"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
</f></iterator_at>
		<back public="1" set="method" line="13483"><f a=""><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></f></back>
		<front public="1" get="inline" set="null" line="13480"><f a=""><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="13450"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="13445"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="13442"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="13437"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="13422"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="13416"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="13411"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="13407"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="13361"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
</f></inlined_erase>
		<erase public="1" set="method" line="13356"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="13333"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="13320"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="13295"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="13284"><f a="obj">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="13271"><f a=""><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="13266"><f a=""><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="13233"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="13228"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="13185"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
</f></inlined_insert>
		<insert public="1" set="method" line="13180"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
</f></insert>
		<addAll public="1" set="method" line="13162"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_InteractionGroup"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="13125"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
</f></inlined_add>
		<add public="1" set="method" line="13120"><f a="o">
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
	<c path="zpp_nape.dynamics.ZPP_InteractionGroup"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="13115"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="13107"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/></head>
		<new public="1" set="method" line="13104"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ConvexResult" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="13922"><f a="ind">
	<x path="Int"/>
	<c path="nape.geom.ConvexResult"/>
</f></at>
		<iterator_at public="1" set="method" line="13909"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
</f></iterator_at>
		<back public="1" set="method" line="13900"><f a=""><c path="nape.geom.ConvexResult"/></f></back>
		<front public="1" get="inline" set="null" line="13897"><f a=""><c path="nape.geom.ConvexResult"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="13867"><f a="obj">
	<c path="nape.geom.ConvexResult"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="13862"><f a="obj">
	<c path="nape.geom.ConvexResult"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="13859"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="13854"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="13839"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="13833"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="13828"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="13824"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="13778"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
</f></inlined_erase>
		<erase public="1" set="method" line="13773"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="13750"><f a="obj">
	<c path="nape.geom.ConvexResult"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="13737"><f a="obj">
	<c path="nape.geom.ConvexResult"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="13712"><f a="obj">
	<c path="nape.geom.ConvexResult"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="13701"><f a="obj">
	<c path="nape.geom.ConvexResult"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="13688"><f a=""><c path="nape.geom.ConvexResult"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="13683"><f a=""><c path="nape.geom.ConvexResult"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="13650"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="13645"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="13602"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
	<c path="nape.geom.ConvexResult"/>
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
</f></inlined_insert>
		<insert public="1" set="method" line="13597"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
	<c path="nape.geom.ConvexResult"/>
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
</f></insert>
		<addAll public="1" set="method" line="13579"><f a="x">
	<c path="zpp_nape.util.ZNPList_ConvexResult"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="13542"><f a="o">
	<c path="nape.geom.ConvexResult"/>
	<c path="nape.geom.ConvexResult"/>
</f></inlined_add>
		<add public="1" set="method" line="13537"><f a="o">
	<c path="nape.geom.ConvexResult"/>
	<c path="nape.geom.ConvexResult"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="13532"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ConvexResult"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="13524"><f a=""><c path="zpp_nape.util.ZNPNode_ConvexResult"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ConvexResult"/></head>
		<new public="1" set="method" line="13521"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_ZPP_GeomPoly" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="14339"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
</f></at>
		<iterator_at public="1" set="method" line="14326"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
</f></iterator_at>
		<back public="1" set="method" line="14317"><f a=""><c path="zpp_nape.geom.ZPP_GeomPoly"/></f></back>
		<front public="1" get="inline" set="null" line="14314"><f a=""><c path="zpp_nape.geom.ZPP_GeomPoly"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="14284"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="14279"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="14276"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="14271"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="14256"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="14250"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="14245"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="14241"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="14195"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
</f></inlined_erase>
		<erase public="1" set="method" line="14190"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="14167"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="14154"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="14129"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="14118"><f a="obj">
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="14105"><f a=""><c path="zpp_nape.geom.ZPP_GeomPoly"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="14100"><f a=""><c path="zpp_nape.geom.ZPP_GeomPoly"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="14067"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="14062"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="14019"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
</f></inlined_insert>
		<insert public="1" set="method" line="14014"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
</f></insert>
		<addAll public="1" set="method" line="13996"><f a="x">
	<c path="zpp_nape.util.ZNPList_ZPP_GeomPoly"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="13959"><f a="o">
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
</f></inlined_add>
		<add public="1" set="method" line="13954"><f a="o">
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
	<c path="zpp_nape.geom.ZPP_GeomPoly"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="13949"><f a="i">
	<c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="13941"><f a=""><c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/></head>
		<new public="1" set="method" line="13938"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPList_RayResult" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<at public="1" set="method" line="14756"><f a="ind">
	<x path="Int"/>
	<c path="nape.geom.RayResult"/>
</f></at>
		<iterator_at public="1" set="method" line="14743"><f a="ind">
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
</f></iterator_at>
		<back public="1" set="method" line="14734"><f a=""><c path="nape.geom.RayResult"/></f></back>
		<front public="1" get="inline" set="null" line="14731"><f a=""><c path="nape.geom.RayResult"/></f></front>
		<inlined_has public="1" get="inline" set="null" line="14701"><f a="obj">
	<c path="nape.geom.RayResult"/>
	<x path="Bool"/>
</f></inlined_has>
		<has public="1" set="method" line="14696"><f a="obj">
	<c path="nape.geom.RayResult"/>
	<x path="Bool"/>
</f></has>
		<size public="1" get="inline" set="null" line="14693"><f a=""><x path="Int"/></f></size>
		<empty public="1" get="inline" set="null" line="14688"><f a=""><x path="Bool"/></f></empty>
		<reverse public="1" set="method" line="14673"><f a=""><x path="Void"/></f></reverse>
		<inlined_clear public="1" get="inline" set="null" line="14667"><f a=""><x path="Void"/></f></inlined_clear>
		<clear public="1" set="method" line="14662"><f a=""><x path="Void"/></f></clear>
		<splice public="1" set="method" line="14658"><f a="pre:n">
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
	<x path="Int"/>
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
</f></splice>
		<inlined_erase public="1" get="inline" set="null" line="14612"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
</f></inlined_erase>
		<erase public="1" set="method" line="14607"><f a="pre">
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
</f></erase>
		<inlined_try_remove public="1" get="inline" set="null" line="14584"><f a="obj">
	<c path="nape.geom.RayResult"/>
	<x path="Bool"/>
</f></inlined_try_remove>
		<inlined_remove public="1" get="inline" set="null" line="14571"><f a="obj">
	<c path="nape.geom.RayResult"/>
	<x path="Void"/>
</f></inlined_remove>
		<try_remove public="1" set="method" line="14546"><f a="obj">
	<c path="nape.geom.RayResult"/>
	<x path="Bool"/>
</f></try_remove>
		<remove public="1" set="method" line="14535"><f a="obj">
	<c path="nape.geom.RayResult"/>
	<x path="Void"/>
</f></remove>
		<inlined_pop_unsafe public="1" get="inline" set="null" line="14522"><f a=""><c path="nape.geom.RayResult"/></f></inlined_pop_unsafe>
		<pop_unsafe public="1" set="method" line="14517"><f a=""><c path="nape.geom.RayResult"/></f></pop_unsafe>
		<inlined_pop public="1" get="inline" set="null" line="14484"><f a=""><x path="Void"/></f></inlined_pop>
		<pop public="1" set="method" line="14479"><f a=""><x path="Void"/></f></pop>
		<inlined_insert public="1" get="inline" set="null" line="14436"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
	<c path="nape.geom.RayResult"/>
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
</f></inlined_insert>
		<insert public="1" set="method" line="14431"><f a="cur:o">
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
	<c path="nape.geom.RayResult"/>
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
</f></insert>
		<addAll public="1" set="method" line="14413"><f a="x">
	<c path="zpp_nape.util.ZNPList_RayResult"/>
	<x path="Void"/>
</f></addAll>
		<inlined_add public="1" get="inline" set="null" line="14376"><f a="o">
	<c path="nape.geom.RayResult"/>
	<c path="nape.geom.RayResult"/>
</f></inlined_add>
		<add public="1" set="method" line="14371"><f a="o">
	<c path="nape.geom.RayResult"/>
	<c path="nape.geom.RayResult"/>
</f></add>
		<setbegin public="1" get="inline" set="null" line="14366"><f a="i">
	<c path="zpp_nape.util.ZNPNode_RayResult"/>
	<x path="Void"/>
</f></setbegin>
		<length public="1"><x path="Int"/></length>
		<pushmod public="1"><x path="Bool"/></pushmod>
		<modified public="1"><x path="Bool"/></modified>
		<begin public="1" get="inline" set="null" line="14358"><f a=""><c path="zpp_nape.util.ZNPNode_RayResult"/></f></begin>
		<head public="1"><c path="zpp_nape.util.ZNPNode_RayResult"/></head>
		<new public="1" set="method" line="14355"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_CbType" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="14772" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbType"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="14809"><f a=""><c path="zpp_nape.callbacks.ZPP_CbType"/></f></elem>
		<elt public="1"><c path="zpp_nape.callbacks.ZPP_CbType"/></elt>
		<free public="1" get="inline" set="null" line="14802"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="14799"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbType"/></next>
		<new public="1" set="method" line="14806"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_CallbackSet" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="14815" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="14852"><f a=""><c path="zpp_nape.space.ZPP_CallbackSet"/></f></elem>
		<elt public="1"><c path="zpp_nape.space.ZPP_CallbackSet"/></elt>
		<free public="1" get="inline" set="null" line="14845"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="14842"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CallbackSet"/></next>
		<new public="1" set="method" line="14849"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Shape" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="14858" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Shape"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="14895"><f a=""><c path="zpp_nape.shape.ZPP_Shape"/></f></elem>
		<elt public="1"><c path="zpp_nape.shape.ZPP_Shape"/></elt>
		<free public="1" get="inline" set="null" line="14888"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="14885"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Shape"/></next>
		<new public="1" set="method" line="14892"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Body" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="14901" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Body"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="14938"><f a=""><c path="zpp_nape.phys.ZPP_Body"/></f></elem>
		<elt public="1"><c path="zpp_nape.phys.ZPP_Body"/></elt>
		<free public="1" get="inline" set="null" line="14931"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="14928"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Body"/></next>
		<new public="1" set="method" line="14935"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Constraint" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="14944" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="14981"><f a=""><c path="zpp_nape.constraint.ZPP_Constraint"/></f></elem>
		<elt public="1"><c path="zpp_nape.constraint.ZPP_Constraint"/></elt>
		<free public="1" get="inline" set="null" line="14974"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="14971"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/></next>
		<new public="1" set="method" line="14978"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Compound" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="14987" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Compound"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15024"><f a=""><c path="zpp_nape.phys.ZPP_Compound"/></f></elem>
		<elt public="1"><c path="zpp_nape.phys.ZPP_Compound"/></elt>
		<free public="1" get="inline" set="null" line="15017"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15014"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Compound"/></next>
		<new public="1" set="method" line="15021"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_InteractionListener" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15030" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15067"><f a=""><c path="zpp_nape.callbacks.ZPP_InteractionListener"/></f></elem>
		<elt public="1"><c path="zpp_nape.callbacks.ZPP_InteractionListener"/></elt>
		<free public="1" get="inline" set="null" line="15060"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15057"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_InteractionListener"/></next>
		<new public="1" set="method" line="15064"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_CbSet" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15073" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15110"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSet"/></f></elem>
		<elt public="1"><c path="zpp_nape.callbacks.ZPP_CbSet"/></elt>
		<free public="1" get="inline" set="null" line="15103"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15100"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbSet"/></next>
		<new public="1" set="method" line="15107"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Arbiter" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15116" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15153"><f a=""><c path="zpp_nape.dynamics.ZPP_Arbiter"/></f></elem>
		<elt public="1"><c path="zpp_nape.dynamics.ZPP_Arbiter"/></elt>
		<free public="1" get="inline" set="null" line="15146"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15143"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/></next>
		<new public="1" set="method" line="15150"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Interactor" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15159" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15196"><f a=""><c path="zpp_nape.phys.ZPP_Interactor"/></f></elem>
		<elt public="1"><c path="zpp_nape.phys.ZPP_Interactor"/></elt>
		<free public="1" get="inline" set="null" line="15189"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15186"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/></next>
		<new public="1" set="method" line="15193"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_BodyListener" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15202" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15239"><f a=""><c path="zpp_nape.callbacks.ZPP_BodyListener"/></f></elem>
		<elt public="1"><c path="zpp_nape.callbacks.ZPP_BodyListener"/></elt>
		<free public="1" get="inline" set="null" line="15232"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15229"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_BodyListener"/></next>
		<new public="1" set="method" line="15236"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15245" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15282"><f a=""><c path="zpp_nape.callbacks.ZPP_ConstraintListener"/></f></elem>
		<elt public="1"><c path="zpp_nape.callbacks.ZPP_ConstraintListener"/></elt>
		<free public="1" get="inline" set="null" line="15275"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15272"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_ConstraintListener"/></next>
		<new public="1" set="method" line="15279"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_CbSetPair" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15288" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15325"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></f></elem>
		<elt public="1"><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></elt>
		<free public="1" get="inline" set="null" line="15318"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15315"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbSetPair"/></next>
		<new public="1" set="method" line="15322"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_CutInt" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15331" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15368"><f a=""><c path="zpp_nape.geom.ZPP_CutInt"/></f></elem>
		<elt public="1"><c path="zpp_nape.geom.ZPP_CutInt"/></elt>
		<free public="1" get="inline" set="null" line="15361"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15358"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CutInt"/></next>
		<new public="1" set="method" line="15365"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_CutVert" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15374" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15411"><f a=""><c path="zpp_nape.geom.ZPP_CutVert"/></f></elem>
		<elt public="1"><c path="zpp_nape.geom.ZPP_CutVert"/></elt>
		<free public="1" get="inline" set="null" line="15404"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15401"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CutVert"/></next>
		<new public="1" set="method" line="15408"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15417" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15454"><f a=""><c path="zpp_nape.geom.ZPP_PartitionVertex"/></f></elem>
		<elt public="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></elt>
		<free public="1" get="inline" set="null" line="15447"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15444"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_PartitionVertex"/></next>
		<new public="1" set="method" line="15451"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15460" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15497"><f a=""><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></f></elem>
		<elt public="1"><c path="zpp_nape.geom.ZPP_PartitionedPoly"/></elt>
		<free public="1" get="inline" set="null" line="15490"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15487"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"/></next>
		<new public="1" set="method" line="15494"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_GeomVert" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15503" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15540"><f a=""><c path="zpp_nape.geom.ZPP_GeomVert"/></f></elem>
		<elt public="1"><c path="zpp_nape.geom.ZPP_GeomVert"/></elt>
		<free public="1" get="inline" set="null" line="15533"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15530"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_GeomVert"/></next>
		<new public="1" set="method" line="15537"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_SimplifyP" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15546" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15583"><f a=""><c path="zpp_nape.geom.ZPP_SimplifyP"/></f></elem>
		<elt public="1"><c path="zpp_nape.geom.ZPP_SimplifyP"/></elt>
		<free public="1" get="inline" set="null" line="15576"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15573"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimplifyP"/></next>
		<new public="1" set="method" line="15580"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_SimpleVert" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15589" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15626"><f a=""><c path="zpp_nape.geom.ZPP_SimpleVert"/></f></elem>
		<elt public="1"><c path="zpp_nape.geom.ZPP_SimpleVert"/></elt>
		<free public="1" get="inline" set="null" line="15619"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15616"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimpleVert"/></next>
		<new public="1" set="method" line="15623"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15632" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15669"><f a=""><c path="zpp_nape.geom.ZPP_SimpleEvent"/></f></elem>
		<elt public="1"><c path="zpp_nape.geom.ZPP_SimpleEvent"/></elt>
		<free public="1" get="inline" set="null" line="15662"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15659"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SimpleEvent"/></next>
		<new public="1" set="method" line="15666"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Vec2" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15675" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15712"><f a=""><c path="zpp_nape.geom.ZPP_Vec2"/></f></elem>
		<elt public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></elt>
		<free public="1" get="inline" set="null" line="15705"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15702"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/></next>
		<new public="1" set="method" line="15709"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_AABBPair" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15718" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15755"><f a=""><c path="zpp_nape.space.ZPP_AABBPair"/></f></elem>
		<elt public="1"><c path="zpp_nape.space.ZPP_AABBPair"/></elt>
		<free public="1" get="inline" set="null" line="15748"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15745"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_AABBPair"/></next>
		<new public="1" set="method" line="15752"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Edge" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15761" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Edge"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15798"><f a=""><c path="zpp_nape.shape.ZPP_Edge"/></f></elem>
		<elt public="1"><c path="zpp_nape.shape.ZPP_Edge"/></elt>
		<free public="1" get="inline" set="null" line="15791"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15788"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Edge"/></next>
		<new public="1" set="method" line="15795"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_AABBNode" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15804" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15841"><f a=""><c path="zpp_nape.space.ZPP_AABBNode"/></f></elem>
		<elt public="1"><c path="zpp_nape.space.ZPP_AABBNode"/></elt>
		<free public="1" get="inline" set="null" line="15834"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15831"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_AABBNode"/></next>
		<new public="1" set="method" line="15838"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Component" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15847" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Component"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15884"><f a=""><c path="zpp_nape.space.ZPP_Component"/></f></elem>
		<elt public="1"><c path="zpp_nape.space.ZPP_Component"/></elt>
		<free public="1" get="inline" set="null" line="15877"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15874"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Component"/></next>
		<new public="1" set="method" line="15881"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15890" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15927"><f a=""><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></f></elem>
		<elt public="1"><c path="zpp_nape.dynamics.ZPP_FluidArbiter"/></elt>
		<free public="1" get="inline" set="null" line="15920"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15917"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_FluidArbiter"/></next>
		<new public="1" set="method" line="15924"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15933" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="15970"><f a=""><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></f></elem>
		<elt public="1"><c path="zpp_nape.dynamics.ZPP_SensorArbiter"/></elt>
		<free public="1" get="inline" set="null" line="15963"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="15960"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_SensorArbiter"/></next>
		<new public="1" set="method" line="15967"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_Listener" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="15976" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_Listener"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="16013"><f a=""><c path="zpp_nape.callbacks.ZPP_Listener"/></f></elem>
		<elt public="1"><c path="zpp_nape.callbacks.ZPP_Listener"/></elt>
		<free public="1" get="inline" set="null" line="16006"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="16003"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Listener"/></next>
		<new public="1" set="method" line="16010"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_ColArbiter" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="16019" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="16056"><f a=""><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></f></elem>
		<elt public="1"><c path="zpp_nape.dynamics.ZPP_ColArbiter"/></elt>
		<free public="1" get="inline" set="null" line="16049"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="16046"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_ColArbiter"/></next>
		<new public="1" set="method" line="16053"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_ToiEvent" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="16062" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="16099"><f a=""><c path="zpp_nape.geom.ZPP_ToiEvent"/></f></elem>
		<elt public="1"><c path="zpp_nape.geom.ZPP_ToiEvent"/></elt>
		<free public="1" get="inline" set="null" line="16092"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="16089"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_ToiEvent"/></next>
		<new public="1" set="method" line="16096"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="16105" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="16142"><f a=""><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></f></elem>
		<elt public="1"><c path="zpp_nape.dynamics.ZPP_InteractionGroup"/></elt>
		<free public="1" get="inline" set="null" line="16135"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="16132"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/></next>
		<new public="1" set="method" line="16139"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ConvexResult" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="16148" static="1"><c path="zpp_nape.util.ZNPNode_ConvexResult"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="16185"><f a=""><c path="nape.geom.ConvexResult"/></f></elem>
		<elt public="1"><c path="nape.geom.ConvexResult"/></elt>
		<free public="1" get="inline" set="null" line="16178"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="16175"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ConvexResult"/></next>
		<new public="1" set="method" line="16182"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_ZPP_GeomPoly" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="16191" static="1"><c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="16228"><f a=""><c path="zpp_nape.geom.ZPP_GeomPoly"/></f></elem>
		<elt public="1"><c path="zpp_nape.geom.ZPP_GeomPoly"/></elt>
		<free public="1" get="inline" set="null" line="16221"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="16218"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/></next>
		<new public="1" set="method" line="16225"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZNPNode_RayResult" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<zpp_pool public="1" line="16234" static="1"><c path="zpp_nape.util.ZNPNode_RayResult"/></zpp_pool>
		<elem public="1" get="inline" set="null" line="16271"><f a=""><c path="nape.geom.RayResult"/></f></elem>
		<elt public="1"><c path="nape.geom.RayResult"/></elt>
		<free public="1" get="inline" set="null" line="16264"><f a=""><x path="Void"/></f></free>
		<alloc public="1" get="inline" set="null" line="16261"><f a=""><x path="Void"/></f></alloc>
		<next public="1"><c path="zpp_nape.util.ZNPNode_RayResult"/></next>
		<new public="1" set="method" line="16268"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_MixVec2List" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<extends path="nape.geom.Vec2List"/>
		<get public="1" set="method" line="16283" static="1"><f a="list:?immutable">
	<c path="zpp_nape.geom.ZPP_Vec2"/>
	<x path="Bool"/>
	<c path="zpp_nape.util.ZPP_MixVec2List"/>
</f></get>
		<clear public="1" set="method" line="16481" override="1"><f a=""><x path="Void"/></f></clear>
		<remove public="1" set="method" line="16450" override="1"><f a="obj">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
</f></remove>
		<shift public="1" set="method" line="16421" override="1"><f a=""><c path="nape.geom.Vec2"/></f></shift>
		<pop public="1" set="method" line="16392" override="1"><f a=""><c path="nape.geom.Vec2"/></f></pop>
		<unshift public="1" set="method" line="16370" override="1"><f a="obj">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
</f></unshift>
		<push public="1" set="method" line="16348" override="1"><f a="obj">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
</f></push>
		<at public="1" set="method" line="16321" override="1"><f a="index">
	<x path="Int"/>
	<c path="nape.geom.Vec2"/>
</f></at>
		<zpp_vm public="1" set="method" line="16312" override="1"><f a=""><x path="Void"/></f></zpp_vm>
		<zpp_gl public="1" set="method" line="16296" override="1"><f a=""><x path="Int"/></f></zpp_gl>
		<at_index public="1"><x path="Int"/></at_index>
		<at_ite public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></at_ite>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<_length public="1"><x path="Int"/></_length>
		<inner public="1"><c path="zpp_nape.geom.ZPP_Vec2"/></inner>
		<new public="1" set="method" line="16289"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_ConstraintList" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16503" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="16509" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ZPP_Constraint"/>
	<x path="Bool"/>
	<c path="nape.constraint.ConstraintList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Constraint"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="16542"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="16536"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="16531"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="16526"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="16516"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.constraint.Constraint"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.constraint.Constraint"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.constraint.Constraint"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_ConstraintList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Constraint"/></inner>
		<outer public="1"><c path="nape.constraint.ConstraintList"/></outer>
		<new public="1" set="method" line="16551"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_BodyList" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16565" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="16571" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ZPP_Body"/>
	<x path="Bool"/>
	<c path="nape.phys.BodyList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Body"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Body"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="16604"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="16598"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="16593"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="16588"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="16578"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.phys.Body"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.phys.Body"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.phys.Body"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_BodyList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Body"/></inner>
		<outer public="1"><c path="nape.phys.BodyList"/></outer>
		<new public="1" set="method" line="16613"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_InteractorList" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16627" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="16633" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ZPP_Interactor"/>
	<x path="Bool"/>
	<c path="nape.phys.InteractorList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Interactor"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="16666"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="16660"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="16655"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="16650"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="16640"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.phys.Interactor"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.phys.Interactor"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.phys.Interactor"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_InteractorList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Interactor"/></inner>
		<outer public="1"><c path="nape.phys.InteractorList"/></outer>
		<new public="1" set="method" line="16675"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_CompoundList" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16689" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="16695" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ZPP_Compound"/>
	<x path="Bool"/>
	<c path="nape.phys.CompoundList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Compound"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Compound"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="16728"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="16722"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="16717"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="16712"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="16702"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.phys.Compound"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.phys.Compound"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.phys.Compound"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_CompoundList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Compound"/></inner>
		<outer public="1"><c path="nape.phys.CompoundList"/></outer>
		<new public="1" set="method" line="16737"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_ListenerList" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16751" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="16757" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ZPP_Listener"/>
	<x path="Bool"/>
	<c path="nape.callbacks.ListenerList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Listener"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Listener"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="16790"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="16784"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="16779"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="16774"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="16764"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.callbacks.Listener"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.callbacks.Listener"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.callbacks.Listener"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_ListenerList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Listener"/></inner>
		<outer public="1"><c path="nape.callbacks.ListenerList"/></outer>
		<new public="1" set="method" line="16799"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_CbTypeList" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16813" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="16819" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ZPP_CbType"/>
	<x path="Bool"/>
	<c path="nape.callbacks.CbTypeList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbType"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_CbType"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="16852"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="16846"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="16841"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="16836"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="16826"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.callbacks.CbType"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.callbacks.CbType"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.callbacks.CbType"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_CbTypeList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_CbType"/></inner>
		<outer public="1"><c path="nape.callbacks.CbTypeList"/></outer>
		<new public="1" set="method" line="16861"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Vec2List" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16875" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="16881" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ZPP_Vec2"/>
	<x path="Bool"/>
	<c path="nape.geom.Vec2List"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Vec2"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="16914"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="16908"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="16903"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="16898"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="16888"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.geom.Vec2"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.geom.Vec2"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.geom.Vec2"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_Vec2List"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Vec2"/></inner>
		<outer public="1"><c path="nape.geom.Vec2List"/></outer>
		<new public="1" set="method" line="16923"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_GeomPolyList" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16937" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="16943" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ZPP_GeomPoly"/>
	<x path="Bool"/>
	<c path="nape.geom.GeomPolyList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_GeomPoly"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="16976"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="16970"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="16965"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="16960"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="16950"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.geom.GeomPoly"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.geom.GeomPoly"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.geom.GeomPoly"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_GeomPolyList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_GeomPoly"/></inner>
		<outer public="1"><c path="nape.geom.GeomPolyList"/></outer>
		<new public="1" set="method" line="16985"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_RayResultList" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="16999" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="17005" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_RayResult"/>
	<x path="Bool"/>
	<c path="nape.geom.RayResultList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_RayResult"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_RayResult"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="17038"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="17032"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="17027"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="17022"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="17012"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.geom.RayResult"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.geom.RayResult"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.geom.RayResult"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_RayResultList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_RayResult"/></inner>
		<outer public="1"><c path="nape.geom.RayResultList"/></outer>
		<new public="1" set="method" line="17047"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_ConvexResultList" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="17061" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="17067" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ConvexResult"/>
	<x path="Bool"/>
	<c path="nape.geom.ConvexResultList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ConvexResult"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ConvexResult"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="17100"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="17094"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="17089"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="17084"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="17074"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.geom.ConvexResult"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.geom.ConvexResult"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.geom.ConvexResult"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_ConvexResultList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ConvexResult"/></inner>
		<outer public="1"><c path="nape.geom.ConvexResultList"/></outer>
		<new public="1" set="method" line="17109"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_ShapeList" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="17123" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="17129" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ZPP_Shape"/>
	<x path="Bool"/>
	<c path="nape.shape.ShapeList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Shape"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Shape"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="17162"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="17156"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="17151"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="17146"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="17136"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.shape.Shape"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.shape.Shape"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.shape.Shape"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_ShapeList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Shape"/></inner>
		<outer public="1"><c path="nape.shape.ShapeList"/></outer>
		<new public="1" set="method" line="17171"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_EdgeList" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="17185" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="17191" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ZPP_Edge"/>
	<x path="Bool"/>
	<c path="nape.shape.EdgeList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Edge"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Edge"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="17224"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="17218"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="17213"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="17208"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="17198"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.shape.Edge"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.shape.Edge"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.shape.Edge"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_EdgeList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Edge"/></inner>
		<outer public="1"><c path="nape.shape.EdgeList"/></outer>
		<new public="1" set="method" line="17233"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_InteractionGroupList" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="17247" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="17253" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ZPP_InteractionGroup"/>
	<x path="Bool"/>
	<c path="nape.dynamics.InteractionGroupList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_InteractionGroup"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="17286"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="17280"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="17275"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="17270"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="17260"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.dynamics.InteractionGroup"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.dynamics.InteractionGroup"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.dynamics.InteractionGroup"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_InteractionGroupList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_InteractionGroup"/></inner>
		<outer public="1"><c path="nape.dynamics.InteractionGroupList"/></outer>
		<new public="1" set="method" line="17295"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_ArbiterList" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="17309" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="17315" static="1"><f a="list:?imm">
	<c path="zpp_nape.util.ZNPList_ZPP_Arbiter"/>
	<x path="Bool"/>
	<c path="nape.dynamics.ArbiterList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.util.ZNPNode_ZPP_Arbiter"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="17348"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="17342"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="17337"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="17332"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="17322"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.dynamics.Arbiter"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.dynamics.Arbiter"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.dynamics.Arbiter"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_ArbiterList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.util.ZNPList_ZPP_Arbiter"/></inner>
		<outer public="1"><c path="nape.dynamics.ArbiterList"/></outer>
		<new public="1" set="method" line="17357"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_ContactList" params="" file="libSrc/napeLib/zpp_nape/util/Lists.hx" module="zpp_nape.util.Lists">
		<internal public="1" line="17371" static="1"><x path="Bool"/></internal>
		<get public="1" set="method" line="17377" static="1"><f a="list:?imm">
	<c path="zpp_nape.dynamics.ZPP_Contact"/>
	<x path="Bool"/>
	<c path="nape.dynamics.ContactList"/>
</f></get>
		<user_length public="1"><x path="Int"/></user_length>
		<zip_length public="1"><x path="Bool"/></zip_length>
		<push_ite public="1"><c path="zpp_nape.dynamics.ZPP_Contact"/></push_ite>
		<at_ite public="1"><c path="zpp_nape.dynamics.ZPP_Contact"/></at_ite>
		<at_index public="1"><x path="Int"/></at_index>
		<invalidate public="1" set="method" line="17410"><f a=""><x path="Void"/></f></invalidate>
		<validate public="1" set="method" line="17404"><f a=""><x path="Void"/></f></validate>
		<modify_test public="1" set="method" line="17399"><f a=""><x path="Void"/></f></modify_test>
		<modified public="1" set="method" line="17394"><f a=""><x path="Void"/></f></modified>
		<valmod public="1" set="method" line="17384"><f a=""><x path="Void"/></f></valmod>
		<reverse_flag public="1"><x path="Bool"/></reverse_flag>
		<dontremove public="1"><x path="Bool"/></dontremove>
		<subber public="1"><f a="">
	<c path="nape.dynamics.Contact"/>
	<x path="Void"/>
</f></subber>
		<post_adder public="1"><f a="">
	<c path="nape.dynamics.Contact"/>
	<x path="Void"/>
</f></post_adder>
		<adder public="1"><f a="">
	<c path="nape.dynamics.Contact"/>
	<x path="Bool"/>
</f></adder>
		<_modifiable public="1"><f a=""><x path="Void"/></f></_modifiable>
		<_validate public="1"><f a=""><x path="Void"/></f></_validate>
		<_invalidate public="1"><f a="">
	<c path="zpp_nape.util.ZPP_ContactList"/>
	<x path="Void"/>
</f></_invalidate>
		<_invalidated public="1"><x path="Bool"/></_invalidated>
		<immutable public="1"><x path="Bool"/></immutable>
		<inner public="1"><c path="zpp_nape.dynamics.ZPP_Contact"/></inner>
		<outer public="1"><c path="nape.dynamics.ContactList"/></outer>
		<new public="1" set="method" line="17419"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Math" params="" file="libSrc/napeLib/zpp_nape/util/Math.hx" module="zpp_nape.util.Math">
		<sqrt public="1" get="inline" set="null" line="179" static="1"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></sqrt>
		<invsqrt public="1" get="inline" set="null" line="193" static="1"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></invsqrt>
		<sqr public="1" get="inline" set="null" line="210" static="1"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></sqr>
		<clamp2 public="1" get="inline" set="null" line="222" static="1"><f a="x:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></clamp2>
		<clamp public="1" get="inline" set="null" line="234" static="1"><f a="x:a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></clamp>
	</class>
	<class path="zpp_nape.util.ZPP_PubPool" params="" file="libSrc/napeLib/zpp_nape/util/Pool.hx" module="zpp_nape.util.Pool">
		<poolGeomPoly public="1" line="176" static="1"><c path="nape.geom.GeomPoly"/></poolGeomPoly>
		<nextGeomPoly public="1" line="178" static="1"><c path="nape.geom.GeomPoly"/></nextGeomPoly>
		<poolVec2 public="1" line="180" static="1"><c path="nape.geom.Vec2"/></poolVec2>
		<nextVec2 public="1" line="182" static="1"><c path="nape.geom.Vec2"/></nextVec2>
		<poolVec3 public="1" line="184" static="1"><c path="nape.geom.Vec3"/></poolVec3>
		<nextVec3 public="1" line="186" static="1"><c path="nape.geom.Vec3"/></nextVec3>
	</class>
	<class path="zpp_nape.util.ZPP_Set_ZPP_Body" params="" file="libSrc/napeLib/zpp_nape/util/RBTree.hx" module="zpp_nape.util.RBTree">
		<zpp_pool public="1" line="176" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_Body"/></zpp_pool>
		<insert public="1" set="method" line="997"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
</f></insert>
		<try_insert public="1" set="method" line="905"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
</f></try_insert>
		<try_insert_bool public="1" set="method" line="813"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></try_insert_bool>
		<__fix_dbl_red public="1" set="method" line="724"><f a="x">
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
	<x path="Void"/>
</f></__fix_dbl_red>
		<__fix_neg_red public="1" set="method" line="657"><f a="negred">
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
	<x path="Void"/>
</f></__fix_neg_red>
		<clear_node get="inline" set="null" line="622"><f a="node:lambda">
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
	<f a="">
		<c path="zpp_nape.phys.ZPP_Body"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
</f></clear_node>
		<clear_with public="1" get="inline" set="null" line="613"><f a="lambda">
	<f a="">
		<c path="zpp_nape.phys.ZPP_Body"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></clear_with>
		<clear public="1" set="method" line="609"><f a=""><x path="Void"/></f></clear>
		<remove_node public="1" set="method" line="489"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
	<x path="Void"/>
</f></remove_node>
		<predecessor public="1" set="method" line="477"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<t path="Null"><c path="zpp_nape.phys.ZPP_Body"/></t>
</f></predecessor>
		<successor public="1" set="method" line="465"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<t path="Null"><c path="zpp_nape.phys.ZPP_Body"/></t>
</f></successor>
		<predecessor_node public="1" set="method" line="442"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
</f></predecessor_node>
		<successor_node public="1" set="method" line="419"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
</f></successor_node>
		<remove public="1" set="method" line="407"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></remove>
		<pop_front public="1" set="method" line="392"><f a=""><c path="zpp_nape.phys.ZPP_Body"/></f></pop_front>
		<first public="1" set="method" line="379"><f a=""><c path="zpp_nape.phys.ZPP_Body"/></f></first>
		<lower_bound public="1" set="method" line="342"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
</f></lower_bound>
		<find_weak public="1" set="method" line="333"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
</f></find_weak>
		<has_weak public="1" set="method" line="330"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></has_weak>
		<find public="1" set="method" line="322"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_Body"/>
</f></find>
		<has public="1" set="method" line="319"><f a="obj">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></has>
		<size public="1" set="method" line="289"><f a=""><x path="Int"/></f></size>
		<singular public="1" set="method" line="286"><f a=""><x path="Bool"/></f></singular>
		<empty public="1" set="method" line="283"><f a=""><x path="Bool"/></f></empty>
		<verify public="1" set="method" line="218"><f a=""><x path="Bool"/></f></verify>
		<colour public="1"><x path="Int"/></colour>
		<parent public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_Body"/></parent>
		<next public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_Body"/></next>
		<prev public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_Body"/></prev>
		<data public="1"><c path="zpp_nape.phys.ZPP_Body"/></data>
		<swapped public="1"><f a=":">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Void"/>
</f></swapped>
		<lt public="1"><f a=":">
	<c path="zpp_nape.phys.ZPP_Body"/>
	<c path="zpp_nape.phys.ZPP_Body"/>
	<x path="Bool"/>
</f></lt>
		<alloc public="1" get="inline" set="null" line="209"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="202"><f a=""><x path="Void"/></f></free>
		<new public="1" set="method" line="217"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair" params="" file="libSrc/napeLib/zpp_nape/util/RBTree.hx" module="zpp_nape.util.RBTree">
		<zpp_pool public="1" line="1065" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/></zpp_pool>
		<insert public="1" set="method" line="1886"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
</f></insert>
		<try_insert public="1" set="method" line="1794"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
</f></try_insert>
		<try_insert_bool public="1" set="method" line="1702"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></try_insert_bool>
		<__fix_dbl_red public="1" set="method" line="1613"><f a="x">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
	<x path="Void"/>
</f></__fix_dbl_red>
		<__fix_neg_red public="1" set="method" line="1546"><f a="negred">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
	<x path="Void"/>
</f></__fix_neg_red>
		<clear_node get="inline" set="null" line="1511"><f a="node:lambda">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
	<f a="">
		<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
</f></clear_node>
		<clear_with public="1" get="inline" set="null" line="1502"><f a="lambda">
	<f a="">
		<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></clear_with>
		<clear public="1" set="method" line="1498"><f a=""><x path="Void"/></f></clear>
		<remove_node public="1" set="method" line="1378"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
	<x path="Void"/>
</f></remove_node>
		<predecessor public="1" set="method" line="1366"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<t path="Null"><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></t>
</f></predecessor>
		<successor public="1" set="method" line="1354"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<t path="Null"><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></t>
</f></successor>
		<predecessor_node public="1" set="method" line="1331"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
</f></predecessor_node>
		<successor_node public="1" set="method" line="1308"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
</f></successor_node>
		<remove public="1" set="method" line="1296"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Void"/>
</f></remove>
		<pop_front public="1" set="method" line="1281"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></f></pop_front>
		<first public="1" set="method" line="1268"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></f></first>
		<lower_bound public="1" set="method" line="1231"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
</f></lower_bound>
		<find_weak public="1" set="method" line="1222"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
</f></find_weak>
		<has_weak public="1" set="method" line="1219"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></has_weak>
		<find public="1" set="method" line="1211"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/>
</f></find>
		<has public="1" set="method" line="1208"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></has>
		<size public="1" set="method" line="1178"><f a=""><x path="Int"/></f></size>
		<singular public="1" set="method" line="1175"><f a=""><x path="Bool"/></f></singular>
		<empty public="1" set="method" line="1172"><f a=""><x path="Bool"/></f></empty>
		<verify public="1" set="method" line="1107"><f a=""><x path="Bool"/></f></verify>
		<colour public="1"><x path="Int"/></colour>
		<parent public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/></parent>
		<next public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/></next>
		<prev public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSetPair"/></prev>
		<data public="1"><c path="zpp_nape.callbacks.ZPP_CbSetPair"/></data>
		<swapped public="1"><f a=":">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Void"/>
</f></swapped>
		<lt public="1"><f a=":">
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<c path="zpp_nape.callbacks.ZPP_CbSetPair"/>
	<x path="Bool"/>
</f></lt>
		<alloc public="1" get="inline" set="null" line="1098"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="1091"><f a=""><x path="Void"/></f></free>
		<new public="1" set="method" line="1106"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex" params="" file="libSrc/napeLib/zpp_nape/util/RBTree.hx" module="zpp_nape.util.RBTree">
		<zpp_pool public="1" line="1954" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/></zpp_pool>
		<insert public="1" set="method" line="2775"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
</f></insert>
		<try_insert public="1" set="method" line="2683"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
</f></try_insert>
		<try_insert_bool public="1" set="method" line="2591"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></try_insert_bool>
		<__fix_dbl_red public="1" set="method" line="2502"><f a="x">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></__fix_dbl_red>
		<__fix_neg_red public="1" set="method" line="2435"><f a="negred">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></__fix_neg_red>
		<clear_node get="inline" set="null" line="2400"><f a="node:lambda">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
	<f a="">
		<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
</f></clear_node>
		<clear_with public="1" get="inline" set="null" line="2391"><f a="lambda">
	<f a="">
		<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></clear_with>
		<clear public="1" set="method" line="2387"><f a=""><x path="Void"/></f></clear>
		<remove_node public="1" set="method" line="2267"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></remove_node>
		<predecessor public="1" set="method" line="2255"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<t path="Null"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></t>
</f></predecessor>
		<successor public="1" set="method" line="2243"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<t path="Null"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></t>
</f></successor>
		<predecessor_node public="1" set="method" line="2220"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
</f></predecessor_node>
		<successor_node public="1" set="method" line="2197"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
</f></successor_node>
		<remove public="1" set="method" line="2185"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></remove>
		<pop_front public="1" set="method" line="2170"><f a=""><c path="zpp_nape.geom.ZPP_PartitionVertex"/></f></pop_front>
		<first public="1" set="method" line="2157"><f a=""><c path="zpp_nape.geom.ZPP_PartitionVertex"/></f></first>
		<lower_bound public="1" set="method" line="2120"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
</f></lower_bound>
		<find_weak public="1" set="method" line="2111"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
</f></find_weak>
		<has_weak public="1" set="method" line="2108"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></has_weak>
		<find public="1" set="method" line="2100"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/>
</f></find>
		<has public="1" set="method" line="2097"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></has>
		<size public="1" set="method" line="2067"><f a=""><x path="Int"/></f></size>
		<singular public="1" set="method" line="2064"><f a=""><x path="Bool"/></f></singular>
		<empty public="1" set="method" line="2061"><f a=""><x path="Bool"/></f></empty>
		<verify public="1" set="method" line="1996"><f a=""><x path="Bool"/></f></verify>
		<colour public="1"><x path="Int"/></colour>
		<parent public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/></parent>
		<next public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/></next>
		<prev public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"/></prev>
		<data public="1"><c path="zpp_nape.geom.ZPP_PartitionVertex"/></data>
		<swapped public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Void"/>
</f></swapped>
		<lt public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<c path="zpp_nape.geom.ZPP_PartitionVertex"/>
	<x path="Bool"/>
</f></lt>
		<alloc public="1" get="inline" set="null" line="1987"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="1980"><f a=""><x path="Void"/></f></free>
		<new public="1" set="method" line="1995"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair" params="" file="libSrc/napeLib/zpp_nape/util/RBTree.hx" module="zpp_nape.util.RBTree">
		<zpp_pool public="1" line="2843" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/></zpp_pool>
		<insert public="1" set="method" line="3664"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
</f></insert>
		<try_insert public="1" set="method" line="3572"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
</f></try_insert>
		<try_insert_bool public="1" set="method" line="3480"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></try_insert_bool>
		<__fix_dbl_red public="1" set="method" line="3391"><f a="x">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
	<x path="Void"/>
</f></__fix_dbl_red>
		<__fix_neg_red public="1" set="method" line="3324"><f a="negred">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
	<x path="Void"/>
</f></__fix_neg_red>
		<clear_node get="inline" set="null" line="3289"><f a="node:lambda">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
	<f a="">
		<c path="zpp_nape.geom.ZPP_PartitionPair"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
</f></clear_node>
		<clear_with public="1" get="inline" set="null" line="3280"><f a="lambda">
	<f a="">
		<c path="zpp_nape.geom.ZPP_PartitionPair"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></clear_with>
		<clear public="1" set="method" line="3276"><f a=""><x path="Void"/></f></clear>
		<remove_node public="1" set="method" line="3156"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
	<x path="Void"/>
</f></remove_node>
		<predecessor public="1" set="method" line="3144"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<t path="Null"><c path="zpp_nape.geom.ZPP_PartitionPair"/></t>
</f></predecessor>
		<successor public="1" set="method" line="3132"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<t path="Null"><c path="zpp_nape.geom.ZPP_PartitionPair"/></t>
</f></successor>
		<predecessor_node public="1" set="method" line="3109"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
</f></predecessor_node>
		<successor_node public="1" set="method" line="3086"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
</f></successor_node>
		<remove public="1" set="method" line="3074"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Void"/>
</f></remove>
		<pop_front public="1" set="method" line="3059"><f a=""><c path="zpp_nape.geom.ZPP_PartitionPair"/></f></pop_front>
		<first public="1" set="method" line="3046"><f a=""><c path="zpp_nape.geom.ZPP_PartitionPair"/></f></first>
		<lower_bound public="1" set="method" line="3009"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
</f></lower_bound>
		<find_weak public="1" set="method" line="3000"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
</f></find_weak>
		<has_weak public="1" set="method" line="2997"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></has_weak>
		<find public="1" set="method" line="2989"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/>
</f></find>
		<has public="1" set="method" line="2986"><f a="obj">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></has>
		<size public="1" set="method" line="2956"><f a=""><x path="Int"/></f></size>
		<singular public="1" set="method" line="2953"><f a=""><x path="Bool"/></f></singular>
		<empty public="1" set="method" line="2950"><f a=""><x path="Bool"/></f></empty>
		<verify public="1" set="method" line="2885"><f a=""><x path="Bool"/></f></verify>
		<colour public="1"><x path="Int"/></colour>
		<parent public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/></parent>
		<next public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/></next>
		<prev public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_PartitionPair"/></prev>
		<data public="1"><c path="zpp_nape.geom.ZPP_PartitionPair"/></data>
		<swapped public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Void"/>
</f></swapped>
		<lt public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<c path="zpp_nape.geom.ZPP_PartitionPair"/>
	<x path="Bool"/>
</f></lt>
		<alloc public="1" get="inline" set="null" line="2876"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="2869"><f a=""><x path="Void"/></f></free>
		<new public="1" set="method" line="2884"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert" params="" file="libSrc/napeLib/zpp_nape/util/RBTree.hx" module="zpp_nape.util.RBTree">
		<zpp_pool public="1" line="3732" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/></zpp_pool>
		<insert public="1" set="method" line="4553"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
</f></insert>
		<try_insert public="1" set="method" line="4461"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
</f></try_insert>
		<try_insert_bool public="1" set="method" line="4369"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></try_insert_bool>
		<__fix_dbl_red public="1" set="method" line="4280"><f a="x">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
	<x path="Void"/>
</f></__fix_dbl_red>
		<__fix_neg_red public="1" set="method" line="4213"><f a="negred">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
	<x path="Void"/>
</f></__fix_neg_red>
		<clear_node get="inline" set="null" line="4178"><f a="node:lambda">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
	<f a="">
		<c path="zpp_nape.geom.ZPP_SimpleVert"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
</f></clear_node>
		<clear_with public="1" get="inline" set="null" line="4169"><f a="lambda">
	<f a="">
		<c path="zpp_nape.geom.ZPP_SimpleVert"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></clear_with>
		<clear public="1" set="method" line="4165"><f a=""><x path="Void"/></f></clear>
		<remove_node public="1" set="method" line="4045"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
	<x path="Void"/>
</f></remove_node>
		<predecessor public="1" set="method" line="4033"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<t path="Null"><c path="zpp_nape.geom.ZPP_SimpleVert"/></t>
</f></predecessor>
		<successor public="1" set="method" line="4021"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<t path="Null"><c path="zpp_nape.geom.ZPP_SimpleVert"/></t>
</f></successor>
		<predecessor_node public="1" set="method" line="3998"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
</f></predecessor_node>
		<successor_node public="1" set="method" line="3975"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
</f></successor_node>
		<remove public="1" set="method" line="3963"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Void"/>
</f></remove>
		<pop_front public="1" set="method" line="3948"><f a=""><c path="zpp_nape.geom.ZPP_SimpleVert"/></f></pop_front>
		<first public="1" set="method" line="3935"><f a=""><c path="zpp_nape.geom.ZPP_SimpleVert"/></f></first>
		<lower_bound public="1" set="method" line="3898"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
</f></lower_bound>
		<find_weak public="1" set="method" line="3889"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
</f></find_weak>
		<has_weak public="1" set="method" line="3886"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></has_weak>
		<find public="1" set="method" line="3878"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/>
</f></find>
		<has public="1" set="method" line="3875"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></has>
		<size public="1" set="method" line="3845"><f a=""><x path="Int"/></f></size>
		<singular public="1" set="method" line="3842"><f a=""><x path="Bool"/></f></singular>
		<empty public="1" set="method" line="3839"><f a=""><x path="Bool"/></f></empty>
		<verify public="1" set="method" line="3774"><f a=""><x path="Bool"/></f></verify>
		<colour public="1"><x path="Int"/></colour>
		<parent public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/></parent>
		<next public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/></next>
		<prev public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleVert"/></prev>
		<data public="1"><c path="zpp_nape.geom.ZPP_SimpleVert"/></data>
		<swapped public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Void"/>
</f></swapped>
		<lt public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<c path="zpp_nape.geom.ZPP_SimpleVert"/>
	<x path="Bool"/>
</f></lt>
		<alloc public="1" get="inline" set="null" line="3765"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="3758"><f a=""><x path="Void"/></f></free>
		<new public="1" set="method" line="3773"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg" params="" file="libSrc/napeLib/zpp_nape/util/RBTree.hx" module="zpp_nape.util.RBTree">
		<zpp_pool public="1" line="4621" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/></zpp_pool>
		<insert public="1" set="method" line="5442"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
</f></insert>
		<try_insert public="1" set="method" line="5350"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
</f></try_insert>
		<try_insert_bool public="1" set="method" line="5258"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Bool"/>
</f></try_insert_bool>
		<__fix_dbl_red public="1" set="method" line="5169"><f a="x">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
	<x path="Void"/>
</f></__fix_dbl_red>
		<__fix_neg_red public="1" set="method" line="5102"><f a="negred">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
	<x path="Void"/>
</f></__fix_neg_red>
		<clear_node get="inline" set="null" line="5067"><f a="node:lambda">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
	<f a="">
		<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
</f></clear_node>
		<clear_with public="1" get="inline" set="null" line="5058"><f a="lambda">
	<f a="">
		<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></clear_with>
		<clear public="1" set="method" line="5054"><f a=""><x path="Void"/></f></clear>
		<remove_node public="1" set="method" line="4934"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
	<x path="Void"/>
</f></remove_node>
		<predecessor public="1" set="method" line="4922"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<t path="Null"><c path="zpp_nape.geom.ZPP_SimpleSeg"/></t>
</f></predecessor>
		<successor public="1" set="method" line="4910"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<t path="Null"><c path="zpp_nape.geom.ZPP_SimpleSeg"/></t>
</f></successor>
		<predecessor_node public="1" set="method" line="4887"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
</f></predecessor_node>
		<successor_node public="1" set="method" line="4864"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
</f></successor_node>
		<remove public="1" set="method" line="4852"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Void"/>
</f></remove>
		<pop_front public="1" set="method" line="4837"><f a=""><c path="zpp_nape.geom.ZPP_SimpleSeg"/></f></pop_front>
		<first public="1" set="method" line="4824"><f a=""><c path="zpp_nape.geom.ZPP_SimpleSeg"/></f></first>
		<lower_bound public="1" set="method" line="4787"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
</f></lower_bound>
		<find_weak public="1" set="method" line="4778"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
</f></find_weak>
		<has_weak public="1" set="method" line="4775"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Bool"/>
</f></has_weak>
		<find public="1" set="method" line="4767"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/>
</f></find>
		<has public="1" set="method" line="4764"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Bool"/>
</f></has>
		<size public="1" set="method" line="4734"><f a=""><x path="Int"/></f></size>
		<singular public="1" set="method" line="4731"><f a=""><x path="Bool"/></f></singular>
		<empty public="1" set="method" line="4728"><f a=""><x path="Bool"/></f></empty>
		<verify public="1" set="method" line="4663"><f a=""><x path="Bool"/></f></verify>
		<colour public="1"><x path="Int"/></colour>
		<parent public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/></parent>
		<next public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/></next>
		<prev public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"/></prev>
		<data public="1"><c path="zpp_nape.geom.ZPP_SimpleSeg"/></data>
		<swapped public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Void"/>
</f></swapped>
		<lt public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<c path="zpp_nape.geom.ZPP_SimpleSeg"/>
	<x path="Bool"/>
</f></lt>
		<alloc public="1" get="inline" set="null" line="4654"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="4647"><f a=""><x path="Void"/></f></free>
		<new public="1" set="method" line="4662"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent" params="" file="libSrc/napeLib/zpp_nape/util/RBTree.hx" module="zpp_nape.util.RBTree">
		<zpp_pool public="1" line="5510" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/></zpp_pool>
		<insert public="1" set="method" line="6331"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
</f></insert>
		<try_insert public="1" set="method" line="6239"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
</f></try_insert>
		<try_insert_bool public="1" set="method" line="6147"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></try_insert_bool>
		<__fix_dbl_red public="1" set="method" line="6058"><f a="x">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></__fix_dbl_red>
		<__fix_neg_red public="1" set="method" line="5991"><f a="negred">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></__fix_neg_red>
		<clear_node get="inline" set="null" line="5956"><f a="node:lambda">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
	<f a="">
		<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
</f></clear_node>
		<clear_with public="1" get="inline" set="null" line="5947"><f a="lambda">
	<f a="">
		<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></clear_with>
		<clear public="1" set="method" line="5943"><f a=""><x path="Void"/></f></clear>
		<remove_node public="1" set="method" line="5823"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></remove_node>
		<predecessor public="1" set="method" line="5811"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<t path="Null"><c path="zpp_nape.geom.ZPP_SimpleEvent"/></t>
</f></predecessor>
		<successor public="1" set="method" line="5799"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<t path="Null"><c path="zpp_nape.geom.ZPP_SimpleEvent"/></t>
</f></successor>
		<predecessor_node public="1" set="method" line="5776"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
</f></predecessor_node>
		<successor_node public="1" set="method" line="5753"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
</f></successor_node>
		<remove public="1" set="method" line="5741"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></remove>
		<pop_front public="1" set="method" line="5726"><f a=""><c path="zpp_nape.geom.ZPP_SimpleEvent"/></f></pop_front>
		<first public="1" set="method" line="5713"><f a=""><c path="zpp_nape.geom.ZPP_SimpleEvent"/></f></first>
		<lower_bound public="1" set="method" line="5676"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
</f></lower_bound>
		<find_weak public="1" set="method" line="5667"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
</f></find_weak>
		<has_weak public="1" set="method" line="5664"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></has_weak>
		<find public="1" set="method" line="5656"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/>
</f></find>
		<has public="1" set="method" line="5653"><f a="obj">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></has>
		<size public="1" set="method" line="5623"><f a=""><x path="Int"/></f></size>
		<singular public="1" set="method" line="5620"><f a=""><x path="Bool"/></f></singular>
		<empty public="1" set="method" line="5617"><f a=""><x path="Bool"/></f></empty>
		<verify public="1" set="method" line="5552"><f a=""><x path="Bool"/></f></verify>
		<colour public="1"><x path="Int"/></colour>
		<parent public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/></parent>
		<next public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/></next>
		<prev public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"/></prev>
		<data public="1"><c path="zpp_nape.geom.ZPP_SimpleEvent"/></data>
		<swapped public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Void"/>
</f></swapped>
		<lt public="1"><f a=":">
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<c path="zpp_nape.geom.ZPP_SimpleEvent"/>
	<x path="Bool"/>
</f></lt>
		<alloc public="1" get="inline" set="null" line="5543"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="5536"><f a=""><x path="Void"/></f></free>
		<new public="1" set="method" line="5551"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="zpp_nape.util.ZPP_Set_ZPP_CbSet" params="" file="libSrc/napeLib/zpp_nape/util/RBTree.hx" module="zpp_nape.util.RBTree">
		<zpp_pool public="1" line="6399" static="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/></zpp_pool>
		<insert public="1" set="method" line="7220"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
</f></insert>
		<try_insert public="1" set="method" line="7128"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
</f></try_insert>
		<try_insert_bool public="1" set="method" line="7036"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></try_insert_bool>
		<__fix_dbl_red public="1" set="method" line="6947"><f a="x">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
	<x path="Void"/>
</f></__fix_dbl_red>
		<__fix_neg_red public="1" set="method" line="6880"><f a="negred">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
	<x path="Void"/>
</f></__fix_neg_red>
		<clear_node get="inline" set="null" line="6845"><f a="node:lambda">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
	<f a="">
		<c path="zpp_nape.callbacks.ZPP_CbSet"/>
		<x path="Void"/>
	</f>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
</f></clear_node>
		<clear_with public="1" get="inline" set="null" line="6836"><f a="lambda">
	<f a="">
		<c path="zpp_nape.callbacks.ZPP_CbSet"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></clear_with>
		<clear public="1" set="method" line="6832"><f a=""><x path="Void"/></f></clear>
		<remove_node public="1" set="method" line="6712"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
	<x path="Void"/>
</f></remove_node>
		<predecessor public="1" set="method" line="6700"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<t path="Null"><c path="zpp_nape.callbacks.ZPP_CbSet"/></t>
</f></predecessor>
		<successor public="1" set="method" line="6688"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<t path="Null"><c path="zpp_nape.callbacks.ZPP_CbSet"/></t>
</f></successor>
		<predecessor_node public="1" set="method" line="6665"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
</f></predecessor_node>
		<successor_node public="1" set="method" line="6642"><f a="cur">
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
</f></successor_node>
		<remove public="1" set="method" line="6630"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Void"/>
</f></remove>
		<pop_front public="1" set="method" line="6615"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSet"/></f></pop_front>
		<first public="1" set="method" line="6602"><f a=""><c path="zpp_nape.callbacks.ZPP_CbSet"/></f></first>
		<lower_bound public="1" set="method" line="6565"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
</f></lower_bound>
		<find_weak public="1" set="method" line="6556"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
</f></find_weak>
		<has_weak public="1" set="method" line="6553"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></has_weak>
		<find public="1" set="method" line="6545"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/>
</f></find>
		<has public="1" set="method" line="6542"><f a="obj">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></has>
		<size public="1" set="method" line="6512"><f a=""><x path="Int"/></f></size>
		<singular public="1" set="method" line="6509"><f a=""><x path="Bool"/></f></singular>
		<empty public="1" set="method" line="6506"><f a=""><x path="Bool"/></f></empty>
		<verify public="1" set="method" line="6441"><f a=""><x path="Bool"/></f></verify>
		<colour public="1"><x path="Int"/></colour>
		<parent public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/></parent>
		<next public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/></next>
		<prev public="1"><c path="zpp_nape.util.ZPP_Set_ZPP_CbSet"/></prev>
		<data public="1"><c path="zpp_nape.callbacks.ZPP_CbSet"/></data>
		<swapped public="1"><f a=":">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Void"/>
</f></swapped>
		<lt public="1"><f a=":">
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<c path="zpp_nape.callbacks.ZPP_CbSet"/>
	<x path="Bool"/>
</f></lt>
		<alloc public="1" get="inline" set="null" line="6432"><f a=""><x path="Void"/></f></alloc>
		<free public="1" get="inline" set="null" line="6425"><f a=""><x path="Void"/></f></free>
		<new public="1" set="method" line="6440"><f a=""><x path="Void"/></f></new>
	</class>
</haxe>